//! Autogenerated XDR types
//!
// This code has been automatically generated on 2023-10-10
// using the code in folder `/autogenerator`
// Do not edit this file manually!

#[allow(unused_imports)]
use super::compound_types::{
    LimitedString, LimitedVarArray, LimitedVarOpaque, UnlimitedString, UnlimitedVarArray, UnlimitedVarOpaque,
};
#[allow(unused_imports)]
use super::streams::{DecodeError, ReadStream, WriteStream};
#[allow(unused_imports)]
use super::xdr_codec::XdrCodec;
#[allow(unused_imports)]
use core::convert::AsRef;
#[allow(unused_imports)]
use sp_std::{boxed::Box, prelude::*};

/// Autogenerated definition for constant CONTRACT_COST_COUNT_LIMIT
#[allow(dead_code)]
pub const CONTRACT_COST_COUNT_LIMIT: i32 = 1024;
/// Autogenerated definition for constant SC_SPEC_DOC_LIMIT
#[allow(dead_code)]
pub const SC_SPEC_DOC_LIMIT: i32 = 1024;
/// Autogenerated definition for constant SCSYMBOL_LIMIT
#[allow(dead_code)]
pub const SCSYMBOL_LIMIT: i32 = 32;
/// Autogenerated definition for constant MASK_ACCOUNT_FLAGS
#[allow(dead_code)]
pub const MASK_ACCOUNT_FLAGS: i32 = 7;
/// Autogenerated definition for constant MASK_ACCOUNT_FLAGS_V17
#[allow(dead_code)]
pub const MASK_ACCOUNT_FLAGS_V17: i32 = 15;
/// Autogenerated definition for constant MAX_SIGNERS
#[allow(dead_code)]
pub const MAX_SIGNERS: i32 = 20;
/// Autogenerated definition for constant MASK_TRUSTLINE_FLAGS
#[allow(dead_code)]
pub const MASK_TRUSTLINE_FLAGS: i32 = 1;
/// Autogenerated definition for constant MASK_TRUSTLINE_FLAGS_V13
#[allow(dead_code)]
pub const MASK_TRUSTLINE_FLAGS_V13: i32 = 3;
/// Autogenerated definition for constant MASK_TRUSTLINE_FLAGS_V17
#[allow(dead_code)]
pub const MASK_TRUSTLINE_FLAGS_V17: i32 = 7;
/// Autogenerated definition for constant MASK_OFFERENTRY_FLAGS
#[allow(dead_code)]
pub const MASK_OFFERENTRY_FLAGS: i32 = 1;
/// Autogenerated definition for constant MASK_CLAIMABLE_BALANCE_FLAGS
#[allow(dead_code)]
pub const MASK_CLAIMABLE_BALANCE_FLAGS: i32 = 1;
/// Autogenerated definition for constant MASK_LEDGER_HEADER_FLAGS
#[allow(dead_code)]
pub const MASK_LEDGER_HEADER_FLAGS: i32 = 7;
/// Autogenerated definition for constant AUTH_MSG_FLAG_FLOW_CONTROL_BYTES_REQUESTED
#[allow(dead_code)]
pub const AUTH_MSG_FLAG_FLOW_CONTROL_BYTES_REQUESTED: i32 = 200;
/// Autogenerated definition for constant TX_ADVERT_VECTOR_MAX_SIZE
#[allow(dead_code)]
pub const TX_ADVERT_VECTOR_MAX_SIZE: i32 = 1000;
/// Autogenerated definition for constant TX_DEMAND_VECTOR_MAX_SIZE
#[allow(dead_code)]
pub const TX_DEMAND_VECTOR_MAX_SIZE: i32 = 1000;
/// Autogenerated definition for constant MAX_OPS_PER_TX
#[allow(dead_code)]
pub const MAX_OPS_PER_TX: i32 = 100;
/// Autogenerated definition for constant LIQUIDITY_POOL_FEE_V18
#[allow(dead_code)]
pub const LIQUIDITY_POOL_FEE_V18: i32 = 30;

/// Autogenerated definition for type Value
#[allow(dead_code)]
#[cfg(feature = "all-types")]
pub type Value = UnlimitedVarOpaque;

/// Autogenerated definition for type ScpBallot
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScpBallot {
    pub counter: Uint32,
    pub value: Value,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScpBallot {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.counter.to_xdr_buffered(write_stream);
        self.value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScpBallot {
            counter: Uint32::from_xdr_buffered(read_stream)?,
            value: Value::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ScpStatementType
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ScpStatementType {
    ScpStPrepare = 0,
    ScpStConfirm = 1,
    ScpStExternalize = 2,
    ScpStNominate = 3,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScpStatementType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ScpStatementType::ScpStPrepare),
            1 => Ok(ScpStatementType::ScpStConfirm),
            2 => Ok(ScpStatementType::ScpStExternalize),
            3 => Ok(ScpStatementType::ScpStNominate),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ScpNomination
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScpNomination {
    pub quorum_set_hash: Hash,
    pub votes: UnlimitedVarArray<Value>,
    pub accepted: UnlimitedVarArray<Value>,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScpNomination {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.quorum_set_hash.to_xdr_buffered(write_stream);
        self.votes.to_xdr_buffered(write_stream);
        self.accepted.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScpNomination {
            quorum_set_hash: Hash::from_xdr_buffered(read_stream)?,
            votes: UnlimitedVarArray::<Value>::from_xdr_buffered(read_stream)?,
            accepted: UnlimitedVarArray::<Value>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ScpStatementPrepare
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScpStatementPrepare {
    pub quorum_set_hash: Hash,
    pub ballot: ScpBallot,
    pub prepared: Option<ScpBallot>,
    pub prepared_prime: Option<ScpBallot>,
    pub n_c: Uint32,
    pub n_h: Uint32,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScpStatementPrepare {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.quorum_set_hash.to_xdr_buffered(write_stream);
        self.ballot.to_xdr_buffered(write_stream);
        self.prepared.to_xdr_buffered(write_stream);
        self.prepared_prime.to_xdr_buffered(write_stream);
        self.n_c.to_xdr_buffered(write_stream);
        self.n_h.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScpStatementPrepare {
            quorum_set_hash: Hash::from_xdr_buffered(read_stream)?,
            ballot: ScpBallot::from_xdr_buffered(read_stream)?,
            prepared: Option::<ScpBallot>::from_xdr_buffered(read_stream)?,
            prepared_prime: Option::<ScpBallot>::from_xdr_buffered(read_stream)?,
            n_c: Uint32::from_xdr_buffered(read_stream)?,
            n_h: Uint32::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ScpStatementConfirm
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScpStatementConfirm {
    pub ballot: ScpBallot,
    pub n_prepared: Uint32,
    pub n_commit: Uint32,
    pub n_h: Uint32,
    pub quorum_set_hash: Hash,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScpStatementConfirm {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.ballot.to_xdr_buffered(write_stream);
        self.n_prepared.to_xdr_buffered(write_stream);
        self.n_commit.to_xdr_buffered(write_stream);
        self.n_h.to_xdr_buffered(write_stream);
        self.quorum_set_hash.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScpStatementConfirm {
            ballot: ScpBallot::from_xdr_buffered(read_stream)?,
            n_prepared: Uint32::from_xdr_buffered(read_stream)?,
            n_commit: Uint32::from_xdr_buffered(read_stream)?,
            n_h: Uint32::from_xdr_buffered(read_stream)?,
            quorum_set_hash: Hash::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ScpStatementExternalize
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScpStatementExternalize {
    pub commit: ScpBallot,
    pub n_h: Uint32,
    pub commit_quorum_set_hash: Hash,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScpStatementExternalize {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.commit.to_xdr_buffered(write_stream);
        self.n_h.to_xdr_buffered(write_stream);
        self.commit_quorum_set_hash.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScpStatementExternalize {
            commit: ScpBallot::from_xdr_buffered(read_stream)?,
            n_h: Uint32::from_xdr_buffered(read_stream)?,
            commit_quorum_set_hash: Hash::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ScpStatement
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScpStatement {
    pub node_id: NodeId,
    pub slot_index: Uint64,
    pub pledges: ScpStatementPledges,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScpStatement {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.node_id.to_xdr_buffered(write_stream);
        self.slot_index.to_xdr_buffered(write_stream);
        self.pledges.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScpStatement {
            node_id: NodeId::from_xdr_buffered(read_stream)?,
            slot_index: Uint64::from_xdr_buffered(read_stream)?,
            pledges: ScpStatementPledges::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ScpEnvelope
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScpEnvelope {
    pub statement: ScpStatement,
    pub signature: Signature,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScpEnvelope {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.statement.to_xdr_buffered(write_stream);
        self.signature.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScpEnvelope {
            statement: ScpStatement::from_xdr_buffered(read_stream)?,
            signature: Signature::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ScpQuorumSet
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScpQuorumSet {
    pub threshold: Uint32,
    pub validators: UnlimitedVarArray<NodeId>,
    pub inner_sets: UnlimitedVarArray<ScpQuorumSet>,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScpQuorumSet {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.threshold.to_xdr_buffered(write_stream);
        self.validators.to_xdr_buffered(write_stream);
        self.inner_sets.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScpQuorumSet {
            threshold: Uint32::from_xdr_buffered(read_stream)?,
            validators: UnlimitedVarArray::<NodeId>::from_xdr_buffered(read_stream)?,
            inner_sets: UnlimitedVarArray::<ScpQuorumSet>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ConfigSettingContractExecutionLanesV0
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ConfigSettingContractExecutionLanesV0 {
    pub ledger_max_tx_count: Uint32,
}

impl XdrCodec for ConfigSettingContractExecutionLanesV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.ledger_max_tx_count.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ConfigSettingContractExecutionLanesV0 { ledger_max_tx_count: Uint32::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type ConfigSettingContractComputeV0
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ConfigSettingContractComputeV0 {
    pub ledger_max_instructions: Int64,
    pub tx_max_instructions: Int64,
    pub fee_rate_per_instructions_increment: Int64,
    pub tx_memory_limit: Uint32,
}

impl XdrCodec for ConfigSettingContractComputeV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.ledger_max_instructions.to_xdr_buffered(write_stream);
        self.tx_max_instructions.to_xdr_buffered(write_stream);
        self.fee_rate_per_instructions_increment.to_xdr_buffered(write_stream);
        self.tx_memory_limit.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ConfigSettingContractComputeV0 {
            ledger_max_instructions: Int64::from_xdr_buffered(read_stream)?,
            tx_max_instructions: Int64::from_xdr_buffered(read_stream)?,
            fee_rate_per_instructions_increment: Int64::from_xdr_buffered(read_stream)?,
            tx_memory_limit: Uint32::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ConfigSettingContractLedgerCostV0
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ConfigSettingContractLedgerCostV0 {
    pub ledger_max_read_ledger_entries: Uint32,
    pub ledger_max_read_bytes: Uint32,
    pub ledger_max_write_ledger_entries: Uint32,
    pub ledger_max_write_bytes: Uint32,
    pub tx_max_read_ledger_entries: Uint32,
    pub tx_max_read_bytes: Uint32,
    pub tx_max_write_ledger_entries: Uint32,
    pub tx_max_write_bytes: Uint32,
    pub fee_read_ledger_entry: Int64,
    pub fee_write_ledger_entry: Int64,
    pub fee_read1_kb: Int64,
    pub bucket_list_target_size_bytes: Int64,
    pub write_fee1_kb_bucket_list_low: Int64,
    pub write_fee1_kb_bucket_list_high: Int64,
    pub bucket_list_write_fee_growth_factor: Uint32,
}

impl XdrCodec for ConfigSettingContractLedgerCostV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.ledger_max_read_ledger_entries.to_xdr_buffered(write_stream);
        self.ledger_max_read_bytes.to_xdr_buffered(write_stream);
        self.ledger_max_write_ledger_entries.to_xdr_buffered(write_stream);
        self.ledger_max_write_bytes.to_xdr_buffered(write_stream);
        self.tx_max_read_ledger_entries.to_xdr_buffered(write_stream);
        self.tx_max_read_bytes.to_xdr_buffered(write_stream);
        self.tx_max_write_ledger_entries.to_xdr_buffered(write_stream);
        self.tx_max_write_bytes.to_xdr_buffered(write_stream);
        self.fee_read_ledger_entry.to_xdr_buffered(write_stream);
        self.fee_write_ledger_entry.to_xdr_buffered(write_stream);
        self.fee_read1_kb.to_xdr_buffered(write_stream);
        self.bucket_list_target_size_bytes.to_xdr_buffered(write_stream);
        self.write_fee1_kb_bucket_list_low.to_xdr_buffered(write_stream);
        self.write_fee1_kb_bucket_list_high.to_xdr_buffered(write_stream);
        self.bucket_list_write_fee_growth_factor.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ConfigSettingContractLedgerCostV0 {
            ledger_max_read_ledger_entries: Uint32::from_xdr_buffered(read_stream)?,
            ledger_max_read_bytes: Uint32::from_xdr_buffered(read_stream)?,
            ledger_max_write_ledger_entries: Uint32::from_xdr_buffered(read_stream)?,
            ledger_max_write_bytes: Uint32::from_xdr_buffered(read_stream)?,
            tx_max_read_ledger_entries: Uint32::from_xdr_buffered(read_stream)?,
            tx_max_read_bytes: Uint32::from_xdr_buffered(read_stream)?,
            tx_max_write_ledger_entries: Uint32::from_xdr_buffered(read_stream)?,
            tx_max_write_bytes: Uint32::from_xdr_buffered(read_stream)?,
            fee_read_ledger_entry: Int64::from_xdr_buffered(read_stream)?,
            fee_write_ledger_entry: Int64::from_xdr_buffered(read_stream)?,
            fee_read1_kb: Int64::from_xdr_buffered(read_stream)?,
            bucket_list_target_size_bytes: Int64::from_xdr_buffered(read_stream)?,
            write_fee1_kb_bucket_list_low: Int64::from_xdr_buffered(read_stream)?,
            write_fee1_kb_bucket_list_high: Int64::from_xdr_buffered(read_stream)?,
            bucket_list_write_fee_growth_factor: Uint32::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ConfigSettingContractHistoricalDataV0
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ConfigSettingContractHistoricalDataV0 {
    pub fee_historical1_kb: Int64,
}

impl XdrCodec for ConfigSettingContractHistoricalDataV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.fee_historical1_kb.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ConfigSettingContractHistoricalDataV0 { fee_historical1_kb: Int64::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type ConfigSettingContractEventsV0
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ConfigSettingContractEventsV0 {
    pub tx_max_contract_events_size_bytes: Uint32,
    pub fee_contract_events1_kb: Int64,
}

impl XdrCodec for ConfigSettingContractEventsV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.tx_max_contract_events_size_bytes.to_xdr_buffered(write_stream);
        self.fee_contract_events1_kb.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ConfigSettingContractEventsV0 {
            tx_max_contract_events_size_bytes: Uint32::from_xdr_buffered(read_stream)?,
            fee_contract_events1_kb: Int64::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ConfigSettingContractBandwidthV0
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ConfigSettingContractBandwidthV0 {
    pub ledger_max_txs_size_bytes: Uint32,
    pub tx_max_size_bytes: Uint32,
    pub fee_tx_size1_kb: Int64,
}

impl XdrCodec for ConfigSettingContractBandwidthV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.ledger_max_txs_size_bytes.to_xdr_buffered(write_stream);
        self.tx_max_size_bytes.to_xdr_buffered(write_stream);
        self.fee_tx_size1_kb.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ConfigSettingContractBandwidthV0 {
            ledger_max_txs_size_bytes: Uint32::from_xdr_buffered(read_stream)?,
            tx_max_size_bytes: Uint32::from_xdr_buffered(read_stream)?,
            fee_tx_size1_kb: Int64::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ContractCostType
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ContractCostType {
    WasmInsnExec = 0,
    WasmMemAlloc = 1,
    HostMemAlloc = 2,
    HostMemCpy = 3,
    HostMemCmp = 4,
    DispatchHostFunction = 5,
    VisitObject = 6,
    ValSer = 7,
    ValDeser = 8,
    ComputeSha256Hash = 9,
    ComputeEd25519PubKey = 10,
    MapEntry = 11,
    VecEntry = 12,
    VerifyEd25519Sig = 13,
    VmMemRead = 14,
    VmMemWrite = 15,
    VmInstantiation = 16,
    VmCachedInstantiation = 17,
    InvokeVmFunction = 18,
    ComputeKeccak256Hash = 19,
    ComputeEcdsaSecp256k1Key = 20,
    ComputeEcdsaSecp256k1Sig = 21,
    RecoverEcdsaSecp256k1Key = 22,
    Int256AddSub = 23,
    Int256Mul = 24,
    Int256Div = 25,
    Int256Pow = 26,
    Int256Shift = 27,
    ChaCha20DrawBytes = 28,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ContractCostType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ContractCostType::WasmInsnExec),
            1 => Ok(ContractCostType::WasmMemAlloc),
            2 => Ok(ContractCostType::HostMemAlloc),
            3 => Ok(ContractCostType::HostMemCpy),
            4 => Ok(ContractCostType::HostMemCmp),
            5 => Ok(ContractCostType::DispatchHostFunction),
            6 => Ok(ContractCostType::VisitObject),
            7 => Ok(ContractCostType::ValSer),
            8 => Ok(ContractCostType::ValDeser),
            9 => Ok(ContractCostType::ComputeSha256Hash),
            10 => Ok(ContractCostType::ComputeEd25519PubKey),
            11 => Ok(ContractCostType::MapEntry),
            12 => Ok(ContractCostType::VecEntry),
            13 => Ok(ContractCostType::VerifyEd25519Sig),
            14 => Ok(ContractCostType::VmMemRead),
            15 => Ok(ContractCostType::VmMemWrite),
            16 => Ok(ContractCostType::VmInstantiation),
            17 => Ok(ContractCostType::VmCachedInstantiation),
            18 => Ok(ContractCostType::InvokeVmFunction),
            19 => Ok(ContractCostType::ComputeKeccak256Hash),
            20 => Ok(ContractCostType::ComputeEcdsaSecp256k1Key),
            21 => Ok(ContractCostType::ComputeEcdsaSecp256k1Sig),
            22 => Ok(ContractCostType::RecoverEcdsaSecp256k1Key),
            23 => Ok(ContractCostType::Int256AddSub),
            24 => Ok(ContractCostType::Int256Mul),
            25 => Ok(ContractCostType::Int256Div),
            26 => Ok(ContractCostType::Int256Pow),
            27 => Ok(ContractCostType::Int256Shift),
            28 => Ok(ContractCostType::ChaCha20DrawBytes),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ContractCostParamEntry
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ContractCostParamEntry {
    pub ext: ExtensionPoint,
    pub const_term: Int64,
    pub linear_term: Int64,
}

impl XdrCodec for ContractCostParamEntry {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.ext.to_xdr_buffered(write_stream);
        self.const_term.to_xdr_buffered(write_stream);
        self.linear_term.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ContractCostParamEntry {
            ext: ExtensionPoint::from_xdr_buffered(read_stream)?,
            const_term: Int64::from_xdr_buffered(read_stream)?,
            linear_term: Int64::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type StateArchivalSettings
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct StateArchivalSettings {
    pub max_entry_ttl: Uint32,
    pub min_temporary_ttl: Uint32,
    pub min_persistent_ttl: Uint32,
    pub persistent_rent_rate_denominator: Int64,
    pub temp_rent_rate_denominator: Int64,
    pub max_entries_to_archive: Uint32,
    pub bucket_list_size_window_sample_size: Uint32,
    pub eviction_scan_size: Uint64,
    pub starting_eviction_scan_level: Uint32,
}

impl XdrCodec for StateArchivalSettings {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.max_entry_ttl.to_xdr_buffered(write_stream);
        self.min_temporary_ttl.to_xdr_buffered(write_stream);
        self.min_persistent_ttl.to_xdr_buffered(write_stream);
        self.persistent_rent_rate_denominator.to_xdr_buffered(write_stream);
        self.temp_rent_rate_denominator.to_xdr_buffered(write_stream);
        self.max_entries_to_archive.to_xdr_buffered(write_stream);
        self.bucket_list_size_window_sample_size.to_xdr_buffered(write_stream);
        self.eviction_scan_size.to_xdr_buffered(write_stream);
        self.starting_eviction_scan_level.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(StateArchivalSettings {
            max_entry_ttl: Uint32::from_xdr_buffered(read_stream)?,
            min_temporary_ttl: Uint32::from_xdr_buffered(read_stream)?,
            min_persistent_ttl: Uint32::from_xdr_buffered(read_stream)?,
            persistent_rent_rate_denominator: Int64::from_xdr_buffered(read_stream)?,
            temp_rent_rate_denominator: Int64::from_xdr_buffered(read_stream)?,
            max_entries_to_archive: Uint32::from_xdr_buffered(read_stream)?,
            bucket_list_size_window_sample_size: Uint32::from_xdr_buffered(read_stream)?,
            eviction_scan_size: Uint64::from_xdr_buffered(read_stream)?,
            starting_eviction_scan_level: Uint32::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type EvictionIterator
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct EvictionIterator {
    pub bucket_list_level: Uint32,
    pub is_curr_bucket: bool,
    pub bucket_file_offset: Uint64,
}

impl XdrCodec for EvictionIterator {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.bucket_list_level.to_xdr_buffered(write_stream);
        self.is_curr_bucket.to_xdr_buffered(write_stream);
        self.bucket_file_offset.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(EvictionIterator {
            bucket_list_level: Uint32::from_xdr_buffered(read_stream)?,
            is_curr_bucket: bool::from_xdr_buffered(read_stream)?,
            bucket_file_offset: Uint64::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ContractCostParams
#[allow(dead_code)]
pub type ContractCostParams = LimitedVarArray<ContractCostParamEntry, CONTRACT_COST_COUNT_LIMIT>;

/// Autogenerated definition for type ConfigSettingId
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ConfigSettingId {
    ConfigSettingContractMaxSizeBytes = 0,
    ConfigSettingContractComputeV0 = 1,
    ConfigSettingContractLedgerCostV0 = 2,
    ConfigSettingContractHistoricalDataV0 = 3,
    ConfigSettingContractEventsV0 = 4,
    ConfigSettingContractBandwidthV0 = 5,
    ConfigSettingContractCostParamsCpuInstructions = 6,
    ConfigSettingContractCostParamsMemoryBytes = 7,
    ConfigSettingContractDataKeySizeBytes = 8,
    ConfigSettingContractDataEntrySizeBytes = 9,
    ConfigSettingStateArchival = 10,
    ConfigSettingContractExecutionLanes = 11,
    ConfigSettingBucketlistSizeWindow = 12,
    ConfigSettingEvictionIterator = 13,
}

impl XdrCodec for ConfigSettingId {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ConfigSettingId::ConfigSettingContractMaxSizeBytes),
            1 => Ok(ConfigSettingId::ConfigSettingContractComputeV0),
            2 => Ok(ConfigSettingId::ConfigSettingContractLedgerCostV0),
            3 => Ok(ConfigSettingId::ConfigSettingContractHistoricalDataV0),
            4 => Ok(ConfigSettingId::ConfigSettingContractEventsV0),
            5 => Ok(ConfigSettingId::ConfigSettingContractBandwidthV0),
            6 => Ok(ConfigSettingId::ConfigSettingContractCostParamsCpuInstructions),
            7 => Ok(ConfigSettingId::ConfigSettingContractCostParamsMemoryBytes),
            8 => Ok(ConfigSettingId::ConfigSettingContractDataKeySizeBytes),
            9 => Ok(ConfigSettingId::ConfigSettingContractDataEntrySizeBytes),
            10 => Ok(ConfigSettingId::ConfigSettingStateArchival),
            11 => Ok(ConfigSettingId::ConfigSettingContractExecutionLanes),
            12 => Ok(ConfigSettingId::ConfigSettingBucketlistSizeWindow),
            13 => Ok(ConfigSettingId::ConfigSettingEvictionIterator),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ScEnvMetaKind
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ScEnvMetaKind {
    ScEnvMetaKindInterfaceVersion = 0,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScEnvMetaKind {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ScEnvMetaKind::ScEnvMetaKindInterfaceVersion),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ScMetaV0
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScMetaV0 {
    pub key: UnlimitedString,
    pub val: UnlimitedString,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScMetaV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.key.to_xdr_buffered(write_stream);
        self.val.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScMetaV0 {
            key: UnlimitedString::from_xdr_buffered(read_stream)?,
            val: UnlimitedString::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ScMetaKind
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ScMetaKind {
    ScMetaV0 = 0,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScMetaKind {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ScMetaKind::ScMetaV0),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ScSpecType
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ScSpecType {
    ScSpecTypeVal = 0,
    ScSpecTypeBool = 1,
    ScSpecTypeVoid = 2,
    ScSpecTypeError = 3,
    ScSpecTypeU32 = 4,
    ScSpecTypeI32 = 5,
    ScSpecTypeU64 = 6,
    ScSpecTypeI64 = 7,
    ScSpecTypeTimepoint = 8,
    ScSpecTypeDuration = 9,
    ScSpecTypeU128 = 10,
    ScSpecTypeI128 = 11,
    ScSpecTypeU256 = 12,
    ScSpecTypeI256 = 13,
    ScSpecTypeBytes = 14,
    ScSpecTypeString = 16,
    ScSpecTypeSymbol = 17,
    ScSpecTypeAddress = 19,
    ScSpecTypeOption = 1000,
    ScSpecTypeResult = 1001,
    ScSpecTypeVec = 1002,
    ScSpecTypeMap = 1004,
    ScSpecTypeTuple = 1005,
    ScSpecTypeBytesN = 1006,
    ScSpecTypeUdt = 2000,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScSpecType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ScSpecType::ScSpecTypeVal),
            1 => Ok(ScSpecType::ScSpecTypeBool),
            2 => Ok(ScSpecType::ScSpecTypeVoid),
            3 => Ok(ScSpecType::ScSpecTypeError),
            4 => Ok(ScSpecType::ScSpecTypeU32),
            5 => Ok(ScSpecType::ScSpecTypeI32),
            6 => Ok(ScSpecType::ScSpecTypeU64),
            7 => Ok(ScSpecType::ScSpecTypeI64),
            8 => Ok(ScSpecType::ScSpecTypeTimepoint),
            9 => Ok(ScSpecType::ScSpecTypeDuration),
            10 => Ok(ScSpecType::ScSpecTypeU128),
            11 => Ok(ScSpecType::ScSpecTypeI128),
            12 => Ok(ScSpecType::ScSpecTypeU256),
            13 => Ok(ScSpecType::ScSpecTypeI256),
            14 => Ok(ScSpecType::ScSpecTypeBytes),
            16 => Ok(ScSpecType::ScSpecTypeString),
            17 => Ok(ScSpecType::ScSpecTypeSymbol),
            19 => Ok(ScSpecType::ScSpecTypeAddress),
            1000 => Ok(ScSpecType::ScSpecTypeOption),
            1001 => Ok(ScSpecType::ScSpecTypeResult),
            1002 => Ok(ScSpecType::ScSpecTypeVec),
            1004 => Ok(ScSpecType::ScSpecTypeMap),
            1005 => Ok(ScSpecType::ScSpecTypeTuple),
            1006 => Ok(ScSpecType::ScSpecTypeBytesN),
            2000 => Ok(ScSpecType::ScSpecTypeUdt),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ScSpecTypeOption
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScSpecTypeOption {
    pub value_type: Box<ScSpecTypeDef>,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScSpecTypeOption {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.value_type.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScSpecTypeOption { value_type: Box::new(ScSpecTypeDef::from_xdr_buffered(read_stream)?) })
    }
}

/// Autogenerated definition for type ScSpecTypeResult
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScSpecTypeResult {
    pub ok_type: Box<ScSpecTypeDef>,
    pub error_type: ScSpecTypeDef,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScSpecTypeResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.ok_type.to_xdr_buffered(write_stream);
        self.error_type.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScSpecTypeResult {
            ok_type: Box::new(ScSpecTypeDef::from_xdr_buffered(read_stream)?),
            error_type: ScSpecTypeDef::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ScSpecTypeVec
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScSpecTypeVec {
    pub element_type: Box<ScSpecTypeDef>,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScSpecTypeVec {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.element_type.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScSpecTypeVec { element_type: Box::new(ScSpecTypeDef::from_xdr_buffered(read_stream)?) })
    }
}

/// Autogenerated definition for type ScSpecTypeMap
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScSpecTypeMap {
    pub key_type: Box<ScSpecTypeDef>,
    pub value_type: ScSpecTypeDef,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScSpecTypeMap {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.key_type.to_xdr_buffered(write_stream);
        self.value_type.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScSpecTypeMap {
            key_type: Box::new(ScSpecTypeDef::from_xdr_buffered(read_stream)?),
            value_type: ScSpecTypeDef::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ScSpecTypeTuple
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScSpecTypeTuple {
    pub value_types: Box<LimitedVarArray<ScSpecTypeDef, 12>>,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScSpecTypeTuple {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.value_types.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScSpecTypeTuple {
            value_types: Box::new(LimitedVarArray::<ScSpecTypeDef, 12>::from_xdr_buffered(read_stream)?),
        })
    }
}

/// Autogenerated definition for type ScSpecTypeBytesN
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScSpecTypeBytesN {
    pub n: Box<Uint32>,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScSpecTypeBytesN {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.n.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScSpecTypeBytesN { n: Box::new(Uint32::from_xdr_buffered(read_stream)?) })
    }
}

/// Autogenerated definition for type ScSpecTypeUdt
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScSpecTypeUdt {
    pub name: Box<LimitedString<60>>,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScSpecTypeUdt {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.name.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScSpecTypeUdt { name: Box::new(LimitedString::<60>::from_xdr_buffered(read_stream)?) })
    }
}

/// Autogenerated definition for type ScSpecUdtStructFieldV0
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScSpecUdtStructFieldV0 {
    pub doc: LimitedString<1024>,
    pub name: LimitedString<30>,
    pub type_: ScSpecTypeDef,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScSpecUdtStructFieldV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.doc.to_xdr_buffered(write_stream);
        self.name.to_xdr_buffered(write_stream);
        self.type_.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScSpecUdtStructFieldV0 {
            doc: LimitedString::<1024>::from_xdr_buffered(read_stream)?,
            name: LimitedString::<30>::from_xdr_buffered(read_stream)?,
            type_: ScSpecTypeDef::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ScSpecUdtStructV0
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScSpecUdtStructV0 {
    pub doc: LimitedString<1024>,
    pub lib: LimitedString<80>,
    pub name: LimitedString<60>,
    pub fields: LimitedVarArray<ScSpecUdtStructFieldV0, 40>,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScSpecUdtStructV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.doc.to_xdr_buffered(write_stream);
        self.lib.to_xdr_buffered(write_stream);
        self.name.to_xdr_buffered(write_stream);
        self.fields.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScSpecUdtStructV0 {
            doc: LimitedString::<1024>::from_xdr_buffered(read_stream)?,
            lib: LimitedString::<80>::from_xdr_buffered(read_stream)?,
            name: LimitedString::<60>::from_xdr_buffered(read_stream)?,
            fields: LimitedVarArray::<ScSpecUdtStructFieldV0, 40>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ScSpecUdtUnionCaseVoidV0
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScSpecUdtUnionCaseVoidV0 {
    pub doc: LimitedString<1024>,
    pub name: LimitedString<60>,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScSpecUdtUnionCaseVoidV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.doc.to_xdr_buffered(write_stream);
        self.name.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScSpecUdtUnionCaseVoidV0 {
            doc: LimitedString::<1024>::from_xdr_buffered(read_stream)?,
            name: LimitedString::<60>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ScSpecUdtUnionCaseTupleV0
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScSpecUdtUnionCaseTupleV0 {
    pub doc: LimitedString<1024>,
    pub name: LimitedString<60>,
    pub type_: LimitedVarArray<ScSpecTypeDef, 12>,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScSpecUdtUnionCaseTupleV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.doc.to_xdr_buffered(write_stream);
        self.name.to_xdr_buffered(write_stream);
        self.type_.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScSpecUdtUnionCaseTupleV0 {
            doc: LimitedString::<1024>::from_xdr_buffered(read_stream)?,
            name: LimitedString::<60>::from_xdr_buffered(read_stream)?,
            type_: LimitedVarArray::<ScSpecTypeDef, 12>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ScSpecUdtUnionCaseV0Kind
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ScSpecUdtUnionCaseV0Kind {
    ScSpecUdtUnionCaseVoidV0 = 0,
    ScSpecUdtUnionCaseTupleV0 = 1,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScSpecUdtUnionCaseV0Kind {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ScSpecUdtUnionCaseV0Kind::ScSpecUdtUnionCaseVoidV0),
            1 => Ok(ScSpecUdtUnionCaseV0Kind::ScSpecUdtUnionCaseTupleV0),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ScSpecUdtUnionV0
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScSpecUdtUnionV0 {
    pub doc: LimitedString<1024>,
    pub lib: LimitedString<80>,
    pub name: LimitedString<60>,
    pub cases: LimitedVarArray<ScSpecUdtUnionCaseV0, 50>,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScSpecUdtUnionV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.doc.to_xdr_buffered(write_stream);
        self.lib.to_xdr_buffered(write_stream);
        self.name.to_xdr_buffered(write_stream);
        self.cases.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScSpecUdtUnionV0 {
            doc: LimitedString::<1024>::from_xdr_buffered(read_stream)?,
            lib: LimitedString::<80>::from_xdr_buffered(read_stream)?,
            name: LimitedString::<60>::from_xdr_buffered(read_stream)?,
            cases: LimitedVarArray::<ScSpecUdtUnionCaseV0, 50>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ScSpecUdtEnumCaseV0
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScSpecUdtEnumCaseV0 {
    pub doc: LimitedString<1024>,
    pub name: LimitedString<60>,
    pub value: Uint32,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScSpecUdtEnumCaseV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.doc.to_xdr_buffered(write_stream);
        self.name.to_xdr_buffered(write_stream);
        self.value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScSpecUdtEnumCaseV0 {
            doc: LimitedString::<1024>::from_xdr_buffered(read_stream)?,
            name: LimitedString::<60>::from_xdr_buffered(read_stream)?,
            value: Uint32::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ScSpecUdtEnumV0
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScSpecUdtEnumV0 {
    pub doc: LimitedString<1024>,
    pub lib: LimitedString<80>,
    pub name: LimitedString<60>,
    pub cases: LimitedVarArray<ScSpecUdtEnumCaseV0, 50>,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScSpecUdtEnumV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.doc.to_xdr_buffered(write_stream);
        self.lib.to_xdr_buffered(write_stream);
        self.name.to_xdr_buffered(write_stream);
        self.cases.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScSpecUdtEnumV0 {
            doc: LimitedString::<1024>::from_xdr_buffered(read_stream)?,
            lib: LimitedString::<80>::from_xdr_buffered(read_stream)?,
            name: LimitedString::<60>::from_xdr_buffered(read_stream)?,
            cases: LimitedVarArray::<ScSpecUdtEnumCaseV0, 50>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ScSpecUdtErrorEnumCaseV0
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScSpecUdtErrorEnumCaseV0 {
    pub doc: LimitedString<1024>,
    pub name: LimitedString<60>,
    pub value: Uint32,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScSpecUdtErrorEnumCaseV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.doc.to_xdr_buffered(write_stream);
        self.name.to_xdr_buffered(write_stream);
        self.value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScSpecUdtErrorEnumCaseV0 {
            doc: LimitedString::<1024>::from_xdr_buffered(read_stream)?,
            name: LimitedString::<60>::from_xdr_buffered(read_stream)?,
            value: Uint32::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ScSpecUdtErrorEnumV0
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScSpecUdtErrorEnumV0 {
    pub doc: LimitedString<1024>,
    pub lib: LimitedString<80>,
    pub name: LimitedString<60>,
    pub cases: LimitedVarArray<ScSpecUdtErrorEnumCaseV0, 50>,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScSpecUdtErrorEnumV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.doc.to_xdr_buffered(write_stream);
        self.lib.to_xdr_buffered(write_stream);
        self.name.to_xdr_buffered(write_stream);
        self.cases.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScSpecUdtErrorEnumV0 {
            doc: LimitedString::<1024>::from_xdr_buffered(read_stream)?,
            lib: LimitedString::<80>::from_xdr_buffered(read_stream)?,
            name: LimitedString::<60>::from_xdr_buffered(read_stream)?,
            cases: LimitedVarArray::<ScSpecUdtErrorEnumCaseV0, 50>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ScSpecFunctionInputV0
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScSpecFunctionInputV0 {
    pub doc: LimitedString<1024>,
    pub name: LimitedString<30>,
    pub type_: ScSpecTypeDef,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScSpecFunctionInputV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.doc.to_xdr_buffered(write_stream);
        self.name.to_xdr_buffered(write_stream);
        self.type_.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScSpecFunctionInputV0 {
            doc: LimitedString::<1024>::from_xdr_buffered(read_stream)?,
            name: LimitedString::<30>::from_xdr_buffered(read_stream)?,
            type_: ScSpecTypeDef::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ScSpecFunctionV0
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScSpecFunctionV0 {
    pub doc: LimitedString<1024>,
    pub name: ScSymbol,
    pub inputs: LimitedVarArray<ScSpecFunctionInputV0, 10>,
    pub outputs: LimitedVarArray<ScSpecTypeDef, 1>,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScSpecFunctionV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.doc.to_xdr_buffered(write_stream);
        self.name.to_xdr_buffered(write_stream);
        self.inputs.to_xdr_buffered(write_stream);
        self.outputs.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScSpecFunctionV0 {
            doc: LimitedString::<1024>::from_xdr_buffered(read_stream)?,
            name: ScSymbol::from_xdr_buffered(read_stream)?,
            inputs: LimitedVarArray::<ScSpecFunctionInputV0, 10>::from_xdr_buffered(read_stream)?,
            outputs: LimitedVarArray::<ScSpecTypeDef, 1>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ScSpecEntryKind
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ScSpecEntryKind {
    ScSpecEntryFunctionV0 = 0,
    ScSpecEntryUdtStructV0 = 1,
    ScSpecEntryUdtUnionV0 = 2,
    ScSpecEntryUdtEnumV0 = 3,
    ScSpecEntryUdtErrorEnumV0 = 4,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScSpecEntryKind {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ScSpecEntryKind::ScSpecEntryFunctionV0),
            1 => Ok(ScSpecEntryKind::ScSpecEntryUdtStructV0),
            2 => Ok(ScSpecEntryKind::ScSpecEntryUdtUnionV0),
            3 => Ok(ScSpecEntryKind::ScSpecEntryUdtEnumV0),
            4 => Ok(ScSpecEntryKind::ScSpecEntryUdtErrorEnumV0),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ScValType
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ScValType {
    ScvBool = 0,
    ScvVoid = 1,
    ScvError = 2,
    ScvU32 = 3,
    ScvI32 = 4,
    ScvU64 = 5,
    ScvI64 = 6,
    ScvTimepoint = 7,
    ScvDuration = 8,
    ScvU128 = 9,
    ScvI128 = 10,
    ScvU256 = 11,
    ScvI256 = 12,
    ScvBytes = 13,
    ScvString = 14,
    ScvSymbol = 15,
    ScvVec = 16,
    ScvMap = 17,
    ScvAddress = 18,
    ScvContractInstance = 19,
    ScvLedgerKeyContractInstance = 20,
    ScvLedgerKeyNonce = 21,
}

impl XdrCodec for ScValType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ScValType::ScvBool),
            1 => Ok(ScValType::ScvVoid),
            2 => Ok(ScValType::ScvError),
            3 => Ok(ScValType::ScvU32),
            4 => Ok(ScValType::ScvI32),
            5 => Ok(ScValType::ScvU64),
            6 => Ok(ScValType::ScvI64),
            7 => Ok(ScValType::ScvTimepoint),
            8 => Ok(ScValType::ScvDuration),
            9 => Ok(ScValType::ScvU128),
            10 => Ok(ScValType::ScvI128),
            11 => Ok(ScValType::ScvU256),
            12 => Ok(ScValType::ScvI256),
            13 => Ok(ScValType::ScvBytes),
            14 => Ok(ScValType::ScvString),
            15 => Ok(ScValType::ScvSymbol),
            16 => Ok(ScValType::ScvVec),
            17 => Ok(ScValType::ScvMap),
            18 => Ok(ScValType::ScvAddress),
            19 => Ok(ScValType::ScvContractInstance),
            20 => Ok(ScValType::ScvLedgerKeyContractInstance),
            21 => Ok(ScValType::ScvLedgerKeyNonce),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ScErrorType
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ScErrorType {
    SceContract = 0,
    SceWasmVm = 1,
    SceContext = 2,
    SceStorage = 3,
    SceObject = 4,
    SceCrypto = 5,
    SceEvents = 6,
    SceBudget = 7,
    SceValue = 8,
    SceAuth = 9,
}

impl XdrCodec for ScErrorType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ScErrorType::SceContract),
            1 => Ok(ScErrorType::SceWasmVm),
            2 => Ok(ScErrorType::SceContext),
            3 => Ok(ScErrorType::SceStorage),
            4 => Ok(ScErrorType::SceObject),
            5 => Ok(ScErrorType::SceCrypto),
            6 => Ok(ScErrorType::SceEvents),
            7 => Ok(ScErrorType::SceBudget),
            8 => Ok(ScErrorType::SceValue),
            9 => Ok(ScErrorType::SceAuth),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ScErrorCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ScErrorCode {
    ScecArithDomain = 0,
    ScecIndexBounds = 1,
    ScecInvalidInput = 2,
    ScecMissingValue = 3,
    ScecExistingValue = 4,
    ScecExceededLimit = 5,
    ScecInvalidAction = 6,
    ScecInternalError = 7,
    ScecUnexpectedType = 8,
    ScecUnexpectedSize = 9,
}

impl XdrCodec for ScErrorCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ScErrorCode::ScecArithDomain),
            1 => Ok(ScErrorCode::ScecIndexBounds),
            2 => Ok(ScErrorCode::ScecInvalidInput),
            3 => Ok(ScErrorCode::ScecMissingValue),
            4 => Ok(ScErrorCode::ScecExistingValue),
            5 => Ok(ScErrorCode::ScecExceededLimit),
            6 => Ok(ScErrorCode::ScecInvalidAction),
            7 => Ok(ScErrorCode::ScecInternalError),
            8 => Ok(ScErrorCode::ScecUnexpectedType),
            9 => Ok(ScErrorCode::ScecUnexpectedSize),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type UInt128Parts
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct UInt128Parts {
    pub hi: Uint64,
    pub lo: Uint64,
}

impl XdrCodec for UInt128Parts {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.hi.to_xdr_buffered(write_stream);
        self.lo.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(UInt128Parts { hi: Uint64::from_xdr_buffered(read_stream)?, lo: Uint64::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type Int128Parts
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct Int128Parts {
    pub hi: Int64,
    pub lo: Uint64,
}

impl XdrCodec for Int128Parts {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.hi.to_xdr_buffered(write_stream);
        self.lo.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(Int128Parts { hi: Int64::from_xdr_buffered(read_stream)?, lo: Uint64::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type UInt256Parts
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct UInt256Parts {
    pub hi_hi: Uint64,
    pub hi_lo: Uint64,
    pub lo_hi: Uint64,
    pub lo_lo: Uint64,
}

impl XdrCodec for UInt256Parts {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.hi_hi.to_xdr_buffered(write_stream);
        self.hi_lo.to_xdr_buffered(write_stream);
        self.lo_hi.to_xdr_buffered(write_stream);
        self.lo_lo.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(UInt256Parts {
            hi_hi: Uint64::from_xdr_buffered(read_stream)?,
            hi_lo: Uint64::from_xdr_buffered(read_stream)?,
            lo_hi: Uint64::from_xdr_buffered(read_stream)?,
            lo_lo: Uint64::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type Int256Parts
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct Int256Parts {
    pub hi_hi: Int64,
    pub hi_lo: Uint64,
    pub lo_hi: Uint64,
    pub lo_lo: Uint64,
}

impl XdrCodec for Int256Parts {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.hi_hi.to_xdr_buffered(write_stream);
        self.hi_lo.to_xdr_buffered(write_stream);
        self.lo_hi.to_xdr_buffered(write_stream);
        self.lo_lo.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(Int256Parts {
            hi_hi: Int64::from_xdr_buffered(read_stream)?,
            hi_lo: Uint64::from_xdr_buffered(read_stream)?,
            lo_hi: Uint64::from_xdr_buffered(read_stream)?,
            lo_lo: Uint64::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ContractExecutableType
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ContractExecutableType {
    ContractExecutableWasm = 0,
    ContractExecutableStellarAsset = 1,
}

impl XdrCodec for ContractExecutableType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ContractExecutableType::ContractExecutableWasm),
            1 => Ok(ContractExecutableType::ContractExecutableStellarAsset),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ScAddressType
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ScAddressType {
    ScAddressTypeAccount = 0,
    ScAddressTypeContract = 1,
}

impl XdrCodec for ScAddressType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ScAddressType::ScAddressTypeAccount),
            1 => Ok(ScAddressType::ScAddressTypeContract),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ScVec
#[allow(dead_code)]
pub type ScVec = UnlimitedVarArray<ScVal>;

/// Autogenerated definition for type ScMap
#[allow(dead_code)]
pub type ScMap = UnlimitedVarArray<ScMapEntry>;

/// Autogenerated definition for type ScBytes
#[allow(dead_code)]
pub type ScBytes = UnlimitedVarOpaque;

/// Autogenerated definition for type ScString
#[allow(dead_code)]
pub type ScString = UnlimitedString;

/// Autogenerated definition for type ScSymbol
#[allow(dead_code)]
pub type ScSymbol = LimitedString<32>;

/// Autogenerated definition for type ScNonceKey
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScNonceKey {
    pub nonce: Int64,
}

impl XdrCodec for ScNonceKey {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.nonce.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScNonceKey { nonce: Int64::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type ScContractInstance
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScContractInstance {
    pub executable: ContractExecutable,
    pub storage: Option<ScMap>,
}

impl XdrCodec for ScContractInstance {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.executable.to_xdr_buffered(write_stream);
        self.storage.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScContractInstance {
            executable: ContractExecutable::from_xdr_buffered(read_stream)?,
            storage: Option::<ScMap>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ScMapEntry
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScMapEntry {
    pub key: ScVal,
    pub val: ScVal,
}

impl XdrCodec for ScMapEntry {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.key.to_xdr_buffered(write_stream);
        self.val.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScMapEntry { key: ScVal::from_xdr_buffered(read_stream)?, val: ScVal::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type StoredDebugTransactionSet
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct StoredDebugTransactionSet {
    pub tx_set: StoredTransactionSet,
    pub ledger_seq: Uint32,
    pub scp_value: StellarValue,
}

#[cfg(feature = "all-types")]
impl XdrCodec for StoredDebugTransactionSet {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.tx_set.to_xdr_buffered(write_stream);
        self.ledger_seq.to_xdr_buffered(write_stream);
        self.scp_value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(StoredDebugTransactionSet {
            tx_set: StoredTransactionSet::from_xdr_buffered(read_stream)?,
            ledger_seq: Uint32::from_xdr_buffered(read_stream)?,
            scp_value: StellarValue::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type PersistedScpStateV0
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct PersistedScpStateV0 {
    pub scp_envelopes: UnlimitedVarArray<ScpEnvelope>,
    pub quorum_sets: UnlimitedVarArray<ScpQuorumSet>,
    pub tx_sets: UnlimitedVarArray<StoredTransactionSet>,
}

#[cfg(feature = "all-types")]
impl XdrCodec for PersistedScpStateV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.scp_envelopes.to_xdr_buffered(write_stream);
        self.quorum_sets.to_xdr_buffered(write_stream);
        self.tx_sets.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(PersistedScpStateV0 {
            scp_envelopes: UnlimitedVarArray::<ScpEnvelope>::from_xdr_buffered(read_stream)?,
            quorum_sets: UnlimitedVarArray::<ScpQuorumSet>::from_xdr_buffered(read_stream)?,
            tx_sets: UnlimitedVarArray::<StoredTransactionSet>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type PersistedScpStateV1
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct PersistedScpStateV1 {
    pub scp_envelopes: UnlimitedVarArray<ScpEnvelope>,
    pub quorum_sets: UnlimitedVarArray<ScpQuorumSet>,
}

#[cfg(feature = "all-types")]
impl XdrCodec for PersistedScpStateV1 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.scp_envelopes.to_xdr_buffered(write_stream);
        self.quorum_sets.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(PersistedScpStateV1 {
            scp_envelopes: UnlimitedVarArray::<ScpEnvelope>::from_xdr_buffered(read_stream)?,
            quorum_sets: UnlimitedVarArray::<ScpQuorumSet>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type Thresholds
#[allow(dead_code)]
pub type Thresholds = [u8; 4];

/// Autogenerated definition for type String32
#[allow(dead_code)]
pub type String32 = LimitedString<32>;

/// Autogenerated definition for type String64
#[allow(dead_code)]
pub type String64 = LimitedString<64>;

/// Autogenerated definition for type SequenceNumber
#[allow(dead_code)]
pub type SequenceNumber = Int64;

/// Autogenerated definition for type DataValue
#[allow(dead_code)]
pub type DataValue = LimitedVarOpaque<64>;

/// Autogenerated definition for type PoolId
#[allow(dead_code)]
pub type PoolId = Hash;

/// Autogenerated definition for type AssetCode4
#[allow(dead_code)]
pub type AssetCode4 = [u8; 4];

/// Autogenerated definition for type AssetCode12
#[allow(dead_code)]
pub type AssetCode12 = [u8; 12];

/// Autogenerated definition for type AssetType
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum AssetType {
    AssetTypeNative = 0,
    AssetTypeCreditAlphanum4 = 1,
    AssetTypeCreditAlphanum12 = 2,
    AssetTypePoolShare = 3,
}

impl XdrCodec for AssetType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(AssetType::AssetTypeNative),
            1 => Ok(AssetType::AssetTypeCreditAlphanum4),
            2 => Ok(AssetType::AssetTypeCreditAlphanum12),
            3 => Ok(AssetType::AssetTypePoolShare),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type AlphaNum4
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct AlphaNum4 {
    pub asset_code: AssetCode4,
    pub issuer: AccountId,
}

impl XdrCodec for AlphaNum4 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.asset_code.to_xdr_buffered(write_stream);
        self.issuer.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(AlphaNum4 {
            asset_code: AssetCode4::from_xdr_buffered(read_stream)?,
            issuer: AccountId::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type AlphaNum12
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct AlphaNum12 {
    pub asset_code: AssetCode12,
    pub issuer: AccountId,
}

impl XdrCodec for AlphaNum12 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.asset_code.to_xdr_buffered(write_stream);
        self.issuer.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(AlphaNum12 {
            asset_code: AssetCode12::from_xdr_buffered(read_stream)?,
            issuer: AccountId::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type Price
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct Price {
    pub n: Int32,
    pub d: Int32,
}

impl XdrCodec for Price {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.n.to_xdr_buffered(write_stream);
        self.d.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(Price { n: Int32::from_xdr_buffered(read_stream)?, d: Int32::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type Liabilities
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct Liabilities {
    pub buying: Int64,
    pub selling: Int64,
}

impl XdrCodec for Liabilities {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.buying.to_xdr_buffered(write_stream);
        self.selling.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(Liabilities {
            buying: Int64::from_xdr_buffered(read_stream)?,
            selling: Int64::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ThresholdIndices
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ThresholdIndices {
    ThresholdMasterWeight = 0,
    ThresholdLow = 1,
    ThresholdMed = 2,
    ThresholdHigh = 3,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ThresholdIndices {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ThresholdIndices::ThresholdMasterWeight),
            1 => Ok(ThresholdIndices::ThresholdLow),
            2 => Ok(ThresholdIndices::ThresholdMed),
            3 => Ok(ThresholdIndices::ThresholdHigh),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type LedgerEntryType
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum LedgerEntryType {
    Account = 0,
    Trustline = 1,
    Offer = 2,
    Data = 3,
    ClaimableBalance = 4,
    LiquidityPool = 5,
    ContractData = 6,
    ContractCode = 7,
    ConfigSetting = 8,
    Ttl = 9,
}

impl XdrCodec for LedgerEntryType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(LedgerEntryType::Account),
            1 => Ok(LedgerEntryType::Trustline),
            2 => Ok(LedgerEntryType::Offer),
            3 => Ok(LedgerEntryType::Data),
            4 => Ok(LedgerEntryType::ClaimableBalance),
            5 => Ok(LedgerEntryType::LiquidityPool),
            6 => Ok(LedgerEntryType::ContractData),
            7 => Ok(LedgerEntryType::ContractCode),
            8 => Ok(LedgerEntryType::ConfigSetting),
            9 => Ok(LedgerEntryType::Ttl),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type Signer
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct Signer {
    pub key: SignerKey,
    pub weight: Uint32,
}

impl XdrCodec for Signer {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.key.to_xdr_buffered(write_stream);
        self.weight.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(Signer { key: SignerKey::from_xdr_buffered(read_stream)?, weight: Uint32::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type AccountFlags
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum AccountFlags {
    AuthRequiredFlag = 1,
    AuthRevocableFlag = 2,
    AuthImmutableFlag = 4,
    AuthClawbackEnabledFlag = 8,
}

#[cfg(feature = "all-types")]
impl XdrCodec for AccountFlags {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            1 => Ok(AccountFlags::AuthRequiredFlag),
            2 => Ok(AccountFlags::AuthRevocableFlag),
            4 => Ok(AccountFlags::AuthImmutableFlag),
            8 => Ok(AccountFlags::AuthClawbackEnabledFlag),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type SponsorshipDescriptor
#[allow(dead_code)]
pub type SponsorshipDescriptor = Option<AccountId>;

/// Autogenerated definition for type AccountEntryExtensionV3
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct AccountEntryExtensionV3 {
    pub ext: ExtensionPoint,
    pub seq_ledger: Uint32,
    pub seq_time: TimePoint,
}

impl XdrCodec for AccountEntryExtensionV3 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.ext.to_xdr_buffered(write_stream);
        self.seq_ledger.to_xdr_buffered(write_stream);
        self.seq_time.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(AccountEntryExtensionV3 {
            ext: ExtensionPoint::from_xdr_buffered(read_stream)?,
            seq_ledger: Uint32::from_xdr_buffered(read_stream)?,
            seq_time: TimePoint::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type AccountEntryExtensionV2
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct AccountEntryExtensionV2 {
    pub num_sponsored: Uint32,
    pub num_sponsoring: Uint32,
    pub signer_sponsoring_i_ds: LimitedVarArray<SponsorshipDescriptor, MAX_SIGNERS>,
    pub ext: AccountEntryExtensionV2Ext,
}

impl XdrCodec for AccountEntryExtensionV2 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.num_sponsored.to_xdr_buffered(write_stream);
        self.num_sponsoring.to_xdr_buffered(write_stream);
        self.signer_sponsoring_i_ds.to_xdr_buffered(write_stream);
        self.ext.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(AccountEntryExtensionV2 {
            num_sponsored: Uint32::from_xdr_buffered(read_stream)?,
            num_sponsoring: Uint32::from_xdr_buffered(read_stream)?,
            signer_sponsoring_i_ds: LimitedVarArray::<SponsorshipDescriptor, MAX_SIGNERS>::from_xdr_buffered(
                read_stream,
            )?,
            ext: AccountEntryExtensionV2Ext::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type AccountEntryExtensionV1
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct AccountEntryExtensionV1 {
    pub liabilities: Liabilities,
    pub ext: AccountEntryExtensionV1Ext,
}

impl XdrCodec for AccountEntryExtensionV1 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.liabilities.to_xdr_buffered(write_stream);
        self.ext.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(AccountEntryExtensionV1 {
            liabilities: Liabilities::from_xdr_buffered(read_stream)?,
            ext: AccountEntryExtensionV1Ext::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type AccountEntry
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct AccountEntry {
    pub account_id: AccountId,
    pub balance: Int64,
    pub seq_num: SequenceNumber,
    pub num_sub_entries: Uint32,
    pub inflation_dest: Option<AccountId>,
    pub flags: Uint32,
    pub home_domain: String32,
    pub thresholds: Thresholds,
    pub signers: LimitedVarArray<Signer, MAX_SIGNERS>,
    pub ext: AccountEntryExt,
}

impl XdrCodec for AccountEntry {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.account_id.to_xdr_buffered(write_stream);
        self.balance.to_xdr_buffered(write_stream);
        self.seq_num.to_xdr_buffered(write_stream);
        self.num_sub_entries.to_xdr_buffered(write_stream);
        self.inflation_dest.to_xdr_buffered(write_stream);
        self.flags.to_xdr_buffered(write_stream);
        self.home_domain.to_xdr_buffered(write_stream);
        self.thresholds.to_xdr_buffered(write_stream);
        self.signers.to_xdr_buffered(write_stream);
        self.ext.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(AccountEntry {
            account_id: AccountId::from_xdr_buffered(read_stream)?,
            balance: Int64::from_xdr_buffered(read_stream)?,
            seq_num: SequenceNumber::from_xdr_buffered(read_stream)?,
            num_sub_entries: Uint32::from_xdr_buffered(read_stream)?,
            inflation_dest: Option::<AccountId>::from_xdr_buffered(read_stream)?,
            flags: Uint32::from_xdr_buffered(read_stream)?,
            home_domain: String32::from_xdr_buffered(read_stream)?,
            thresholds: Thresholds::from_xdr_buffered(read_stream)?,
            signers: LimitedVarArray::<Signer, MAX_SIGNERS>::from_xdr_buffered(read_stream)?,
            ext: AccountEntryExt::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type TrustLineFlags
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum TrustLineFlags {
    AuthorizedFlag = 1,
    AuthorizedToMaintainLiabilitiesFlag = 2,
    TrustlineClawbackEnabledFlag = 4,
}

impl XdrCodec for TrustLineFlags {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            1 => Ok(TrustLineFlags::AuthorizedFlag),
            2 => Ok(TrustLineFlags::AuthorizedToMaintainLiabilitiesFlag),
            4 => Ok(TrustLineFlags::TrustlineClawbackEnabledFlag),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type LiquidityPoolType
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum LiquidityPoolType {
    LiquidityPoolConstantProduct = 0,
}

impl XdrCodec for LiquidityPoolType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(LiquidityPoolType::LiquidityPoolConstantProduct),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type TrustLineEntryExtensionV2
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct TrustLineEntryExtensionV2 {
    pub liquidity_pool_use_count: Int32,
    pub ext: TrustLineEntryExtensionV2Ext,
}

impl XdrCodec for TrustLineEntryExtensionV2 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.liquidity_pool_use_count.to_xdr_buffered(write_stream);
        self.ext.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(TrustLineEntryExtensionV2 {
            liquidity_pool_use_count: Int32::from_xdr_buffered(read_stream)?,
            ext: TrustLineEntryExtensionV2Ext::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type TrustLineEntryV1
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct TrustLineEntryV1 {
    pub liabilities: Liabilities,
    pub ext: TrustLineEntryV1Ext,
}

impl XdrCodec for TrustLineEntryV1 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.liabilities.to_xdr_buffered(write_stream);
        self.ext.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(TrustLineEntryV1 {
            liabilities: Liabilities::from_xdr_buffered(read_stream)?,
            ext: TrustLineEntryV1Ext::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type TrustLineEntry
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct TrustLineEntry {
    pub account_id: AccountId,
    pub asset: TrustLineAsset,
    pub balance: Int64,
    pub limit: Int64,
    pub flags: Uint32,
    pub ext: TrustLineEntryExt,
}

impl XdrCodec for TrustLineEntry {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.account_id.to_xdr_buffered(write_stream);
        self.asset.to_xdr_buffered(write_stream);
        self.balance.to_xdr_buffered(write_stream);
        self.limit.to_xdr_buffered(write_stream);
        self.flags.to_xdr_buffered(write_stream);
        self.ext.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(TrustLineEntry {
            account_id: AccountId::from_xdr_buffered(read_stream)?,
            asset: TrustLineAsset::from_xdr_buffered(read_stream)?,
            balance: Int64::from_xdr_buffered(read_stream)?,
            limit: Int64::from_xdr_buffered(read_stream)?,
            flags: Uint32::from_xdr_buffered(read_stream)?,
            ext: TrustLineEntryExt::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type OfferEntryFlags
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum OfferEntryFlags {
    PassiveFlag = 1,
}

#[cfg(feature = "all-types")]
impl XdrCodec for OfferEntryFlags {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            1 => Ok(OfferEntryFlags::PassiveFlag),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type OfferEntry
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct OfferEntry {
    pub seller_id: AccountId,
    pub offer_id: Int64,
    pub selling: Asset,
    pub buying: Asset,
    pub amount: Int64,
    pub price: Price,
    pub flags: Uint32,
    pub ext: OfferEntryExt,
}

impl XdrCodec for OfferEntry {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.seller_id.to_xdr_buffered(write_stream);
        self.offer_id.to_xdr_buffered(write_stream);
        self.selling.to_xdr_buffered(write_stream);
        self.buying.to_xdr_buffered(write_stream);
        self.amount.to_xdr_buffered(write_stream);
        self.price.to_xdr_buffered(write_stream);
        self.flags.to_xdr_buffered(write_stream);
        self.ext.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(OfferEntry {
            seller_id: AccountId::from_xdr_buffered(read_stream)?,
            offer_id: Int64::from_xdr_buffered(read_stream)?,
            selling: Asset::from_xdr_buffered(read_stream)?,
            buying: Asset::from_xdr_buffered(read_stream)?,
            amount: Int64::from_xdr_buffered(read_stream)?,
            price: Price::from_xdr_buffered(read_stream)?,
            flags: Uint32::from_xdr_buffered(read_stream)?,
            ext: OfferEntryExt::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type DataEntry
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct DataEntry {
    pub account_id: AccountId,
    pub data_name: String64,
    pub data_value: DataValue,
    pub ext: DataEntryExt,
}

impl XdrCodec for DataEntry {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.account_id.to_xdr_buffered(write_stream);
        self.data_name.to_xdr_buffered(write_stream);
        self.data_value.to_xdr_buffered(write_stream);
        self.ext.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(DataEntry {
            account_id: AccountId::from_xdr_buffered(read_stream)?,
            data_name: String64::from_xdr_buffered(read_stream)?,
            data_value: DataValue::from_xdr_buffered(read_stream)?,
            ext: DataEntryExt::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ClaimPredicateType
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ClaimPredicateType {
    ClaimPredicateUnconditional = 0,
    ClaimPredicateAnd = 1,
    ClaimPredicateOr = 2,
    ClaimPredicateNot = 3,
    ClaimPredicateBeforeAbsoluteTime = 4,
    ClaimPredicateBeforeRelativeTime = 5,
}

impl XdrCodec for ClaimPredicateType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ClaimPredicateType::ClaimPredicateUnconditional),
            1 => Ok(ClaimPredicateType::ClaimPredicateAnd),
            2 => Ok(ClaimPredicateType::ClaimPredicateOr),
            3 => Ok(ClaimPredicateType::ClaimPredicateNot),
            4 => Ok(ClaimPredicateType::ClaimPredicateBeforeAbsoluteTime),
            5 => Ok(ClaimPredicateType::ClaimPredicateBeforeRelativeTime),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ClaimantType
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ClaimantType {
    ClaimantTypeV0 = 0,
}

impl XdrCodec for ClaimantType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ClaimantType::ClaimantTypeV0),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ClaimantV0
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ClaimantV0 {
    pub destination: AccountId,
    pub predicate: ClaimPredicate,
}

impl XdrCodec for ClaimantV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.destination.to_xdr_buffered(write_stream);
        self.predicate.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ClaimantV0 {
            destination: AccountId::from_xdr_buffered(read_stream)?,
            predicate: ClaimPredicate::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ClaimableBalanceIdType
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ClaimableBalanceIdType {
    ClaimableBalanceIdTypeV0 = 0,
}

impl XdrCodec for ClaimableBalanceIdType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ClaimableBalanceIdType::ClaimableBalanceIdTypeV0),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ClaimableBalanceFlags
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ClaimableBalanceFlags {
    ClaimableBalanceClawbackEnabledFlag = 1,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ClaimableBalanceFlags {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            1 => Ok(ClaimableBalanceFlags::ClaimableBalanceClawbackEnabledFlag),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ClaimableBalanceEntryExtensionV1
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ClaimableBalanceEntryExtensionV1 {
    pub ext: ClaimableBalanceEntryExtensionV1Ext,
    pub flags: Uint32,
}

impl XdrCodec for ClaimableBalanceEntryExtensionV1 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.ext.to_xdr_buffered(write_stream);
        self.flags.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ClaimableBalanceEntryExtensionV1 {
            ext: ClaimableBalanceEntryExtensionV1Ext::from_xdr_buffered(read_stream)?,
            flags: Uint32::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ClaimableBalanceEntry
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ClaimableBalanceEntry {
    pub balance_id: ClaimableBalanceId,
    pub claimants: LimitedVarArray<Claimant, 10>,
    pub asset: Asset,
    pub amount: Int64,
    pub ext: ClaimableBalanceEntryExt,
}

impl XdrCodec for ClaimableBalanceEntry {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.balance_id.to_xdr_buffered(write_stream);
        self.claimants.to_xdr_buffered(write_stream);
        self.asset.to_xdr_buffered(write_stream);
        self.amount.to_xdr_buffered(write_stream);
        self.ext.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ClaimableBalanceEntry {
            balance_id: ClaimableBalanceId::from_xdr_buffered(read_stream)?,
            claimants: LimitedVarArray::<Claimant, 10>::from_xdr_buffered(read_stream)?,
            asset: Asset::from_xdr_buffered(read_stream)?,
            amount: Int64::from_xdr_buffered(read_stream)?,
            ext: ClaimableBalanceEntryExt::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type LiquidityPoolConstantProductParameters
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct LiquidityPoolConstantProductParameters {
    pub asset_a: Asset,
    pub asset_b: Asset,
    pub fee: Int32,
}

impl XdrCodec for LiquidityPoolConstantProductParameters {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.asset_a.to_xdr_buffered(write_stream);
        self.asset_b.to_xdr_buffered(write_stream);
        self.fee.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(LiquidityPoolConstantProductParameters {
            asset_a: Asset::from_xdr_buffered(read_stream)?,
            asset_b: Asset::from_xdr_buffered(read_stream)?,
            fee: Int32::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type LiquidityPoolEntryConstantProduct
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct LiquidityPoolEntryConstantProduct {
    pub params: LiquidityPoolConstantProductParameters,
    pub reserve_a: Int64,
    pub reserve_b: Int64,
    pub total_pool_shares: Int64,
    pub pool_shares_trust_line_count: Int64,
}

impl XdrCodec for LiquidityPoolEntryConstantProduct {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.params.to_xdr_buffered(write_stream);
        self.reserve_a.to_xdr_buffered(write_stream);
        self.reserve_b.to_xdr_buffered(write_stream);
        self.total_pool_shares.to_xdr_buffered(write_stream);
        self.pool_shares_trust_line_count.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(LiquidityPoolEntryConstantProduct {
            params: LiquidityPoolConstantProductParameters::from_xdr_buffered(read_stream)?,
            reserve_a: Int64::from_xdr_buffered(read_stream)?,
            reserve_b: Int64::from_xdr_buffered(read_stream)?,
            total_pool_shares: Int64::from_xdr_buffered(read_stream)?,
            pool_shares_trust_line_count: Int64::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type LiquidityPoolEntry
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct LiquidityPoolEntry {
    pub liquidity_pool_id: PoolId,
    pub body: LiquidityPoolEntryBody,
}

impl XdrCodec for LiquidityPoolEntry {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.liquidity_pool_id.to_xdr_buffered(write_stream);
        self.body.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(LiquidityPoolEntry {
            liquidity_pool_id: PoolId::from_xdr_buffered(read_stream)?,
            body: LiquidityPoolEntryBody::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ContractDataDurability
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ContractDataDurability {
    Temporary = 0,
    Persistent = 1,
}

impl XdrCodec for ContractDataDurability {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ContractDataDurability::Temporary),
            1 => Ok(ContractDataDurability::Persistent),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ContractDataEntry
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ContractDataEntry {
    pub ext: ExtensionPoint,
    pub contract: ScAddress,
    pub key: ScVal,
    pub durability: ContractDataDurability,
    pub val: ScVal,
}

impl XdrCodec for ContractDataEntry {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.ext.to_xdr_buffered(write_stream);
        self.contract.to_xdr_buffered(write_stream);
        self.key.to_xdr_buffered(write_stream);
        self.durability.to_xdr_buffered(write_stream);
        self.val.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ContractDataEntry {
            ext: ExtensionPoint::from_xdr_buffered(read_stream)?,
            contract: ScAddress::from_xdr_buffered(read_stream)?,
            key: ScVal::from_xdr_buffered(read_stream)?,
            durability: ContractDataDurability::from_xdr_buffered(read_stream)?,
            val: ScVal::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ContractCodeEntry
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ContractCodeEntry {
    pub ext: ExtensionPoint,
    pub hash: Hash,
    pub code: UnlimitedVarOpaque,
}

impl XdrCodec for ContractCodeEntry {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.ext.to_xdr_buffered(write_stream);
        self.hash.to_xdr_buffered(write_stream);
        self.code.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ContractCodeEntry {
            ext: ExtensionPoint::from_xdr_buffered(read_stream)?,
            hash: Hash::from_xdr_buffered(read_stream)?,
            code: UnlimitedVarOpaque::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type TtlEntry
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct TtlEntry {
    pub key_hash: Hash,
    pub live_until_ledger_seq: Uint32,
}

impl XdrCodec for TtlEntry {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.key_hash.to_xdr_buffered(write_stream);
        self.live_until_ledger_seq.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(TtlEntry {
            key_hash: Hash::from_xdr_buffered(read_stream)?,
            live_until_ledger_seq: Uint32::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type LedgerEntryExtensionV1
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct LedgerEntryExtensionV1 {
    pub sponsoring_id: SponsorshipDescriptor,
    pub ext: LedgerEntryExtensionV1Ext,
}

impl XdrCodec for LedgerEntryExtensionV1 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.sponsoring_id.to_xdr_buffered(write_stream);
        self.ext.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(LedgerEntryExtensionV1 {
            sponsoring_id: SponsorshipDescriptor::from_xdr_buffered(read_stream)?,
            ext: LedgerEntryExtensionV1Ext::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type LedgerEntry
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct LedgerEntry {
    pub last_modified_ledger_seq: Uint32,
    pub data: LedgerEntryData,
    pub ext: LedgerEntryExt,
}

impl XdrCodec for LedgerEntry {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.last_modified_ledger_seq.to_xdr_buffered(write_stream);
        self.data.to_xdr_buffered(write_stream);
        self.ext.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(LedgerEntry {
            last_modified_ledger_seq: Uint32::from_xdr_buffered(read_stream)?,
            data: LedgerEntryData::from_xdr_buffered(read_stream)?,
            ext: LedgerEntryExt::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type LedgerKeyAccount
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct LedgerKeyAccount {
    pub account_id: AccountId,
}

impl XdrCodec for LedgerKeyAccount {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.account_id.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(LedgerKeyAccount { account_id: AccountId::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type LedgerKeyTrustLine
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct LedgerKeyTrustLine {
    pub account_id: AccountId,
    pub asset: TrustLineAsset,
}

impl XdrCodec for LedgerKeyTrustLine {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.account_id.to_xdr_buffered(write_stream);
        self.asset.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(LedgerKeyTrustLine {
            account_id: AccountId::from_xdr_buffered(read_stream)?,
            asset: TrustLineAsset::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type LedgerKeyOffer
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct LedgerKeyOffer {
    pub seller_id: AccountId,
    pub offer_id: Int64,
}

impl XdrCodec for LedgerKeyOffer {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.seller_id.to_xdr_buffered(write_stream);
        self.offer_id.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(LedgerKeyOffer {
            seller_id: AccountId::from_xdr_buffered(read_stream)?,
            offer_id: Int64::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type LedgerKeyData
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct LedgerKeyData {
    pub account_id: AccountId,
    pub data_name: String64,
}

impl XdrCodec for LedgerKeyData {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.account_id.to_xdr_buffered(write_stream);
        self.data_name.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(LedgerKeyData {
            account_id: AccountId::from_xdr_buffered(read_stream)?,
            data_name: String64::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type LedgerKeyClaimableBalance
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct LedgerKeyClaimableBalance {
    pub balance_id: ClaimableBalanceId,
}

impl XdrCodec for LedgerKeyClaimableBalance {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.balance_id.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(LedgerKeyClaimableBalance { balance_id: ClaimableBalanceId::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type LedgerKeyLiquidityPool
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct LedgerKeyLiquidityPool {
    pub liquidity_pool_id: PoolId,
}

impl XdrCodec for LedgerKeyLiquidityPool {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.liquidity_pool_id.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(LedgerKeyLiquidityPool { liquidity_pool_id: PoolId::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type LedgerKeyContractData
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct LedgerKeyContractData {
    pub contract: ScAddress,
    pub key: ScVal,
    pub durability: ContractDataDurability,
}

impl XdrCodec for LedgerKeyContractData {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.contract.to_xdr_buffered(write_stream);
        self.key.to_xdr_buffered(write_stream);
        self.durability.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(LedgerKeyContractData {
            contract: ScAddress::from_xdr_buffered(read_stream)?,
            key: ScVal::from_xdr_buffered(read_stream)?,
            durability: ContractDataDurability::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type LedgerKeyContractCode
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct LedgerKeyContractCode {
    pub hash: Hash,
}

impl XdrCodec for LedgerKeyContractCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.hash.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(LedgerKeyContractCode { hash: Hash::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type LedgerKeyConfigSetting
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct LedgerKeyConfigSetting {
    pub config_setting_id: ConfigSettingId,
}

impl XdrCodec for LedgerKeyConfigSetting {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.config_setting_id.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(LedgerKeyConfigSetting { config_setting_id: ConfigSettingId::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type LedgerKeyTtl
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct LedgerKeyTtl {
    pub key_hash: Hash,
}

impl XdrCodec for LedgerKeyTtl {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.key_hash.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(LedgerKeyTtl { key_hash: Hash::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type EnvelopeType
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum EnvelopeType {
    EnvelopeTypeTxV0 = 0,
    EnvelopeTypeScp = 1,
    EnvelopeTypeTx = 2,
    EnvelopeTypeAuth = 3,
    EnvelopeTypeScpvalue = 4,
    EnvelopeTypeTxFeeBump = 5,
    EnvelopeTypeOpId = 6,
    EnvelopeTypePoolRevokeOpId = 7,
    EnvelopeTypeContractId = 8,
    EnvelopeTypeSorobanAuthorization = 9,
}

impl XdrCodec for EnvelopeType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(EnvelopeType::EnvelopeTypeTxV0),
            1 => Ok(EnvelopeType::EnvelopeTypeScp),
            2 => Ok(EnvelopeType::EnvelopeTypeTx),
            3 => Ok(EnvelopeType::EnvelopeTypeAuth),
            4 => Ok(EnvelopeType::EnvelopeTypeScpvalue),
            5 => Ok(EnvelopeType::EnvelopeTypeTxFeeBump),
            6 => Ok(EnvelopeType::EnvelopeTypeOpId),
            7 => Ok(EnvelopeType::EnvelopeTypePoolRevokeOpId),
            8 => Ok(EnvelopeType::EnvelopeTypeContractId),
            9 => Ok(EnvelopeType::EnvelopeTypeSorobanAuthorization),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type UpgradeType
#[allow(dead_code)]
#[cfg(feature = "all-types")]
pub type UpgradeType = LimitedVarOpaque<128>;

/// Autogenerated definition for type StellarValueType
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum StellarValueType {
    StellarValueBasic = 0,
    StellarValueSigned = 1,
}

#[cfg(feature = "all-types")]
impl XdrCodec for StellarValueType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(StellarValueType::StellarValueBasic),
            1 => Ok(StellarValueType::StellarValueSigned),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type LedgerCloseValueSignature
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct LedgerCloseValueSignature {
    pub node_id: NodeId,
    pub signature: Signature,
}

#[cfg(feature = "all-types")]
impl XdrCodec for LedgerCloseValueSignature {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.node_id.to_xdr_buffered(write_stream);
        self.signature.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(LedgerCloseValueSignature {
            node_id: NodeId::from_xdr_buffered(read_stream)?,
            signature: Signature::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type StellarValue
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct StellarValue {
    pub tx_set_hash: Hash,
    pub close_time: TimePoint,
    pub upgrades: LimitedVarArray<UpgradeType, 6>,
    pub ext: StellarValueExt,
}

#[cfg(feature = "all-types")]
impl XdrCodec for StellarValue {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.tx_set_hash.to_xdr_buffered(write_stream);
        self.close_time.to_xdr_buffered(write_stream);
        self.upgrades.to_xdr_buffered(write_stream);
        self.ext.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(StellarValue {
            tx_set_hash: Hash::from_xdr_buffered(read_stream)?,
            close_time: TimePoint::from_xdr_buffered(read_stream)?,
            upgrades: LimitedVarArray::<UpgradeType, 6>::from_xdr_buffered(read_stream)?,
            ext: StellarValueExt::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type LedgerHeaderFlags
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum LedgerHeaderFlags {
    DisableLiquidityPoolTradingFlag = 1,
    DisableLiquidityPoolDepositFlag = 2,
    DisableLiquidityPoolWithdrawalFlag = 4,
}

#[cfg(feature = "all-types")]
impl XdrCodec for LedgerHeaderFlags {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            1 => Ok(LedgerHeaderFlags::DisableLiquidityPoolTradingFlag),
            2 => Ok(LedgerHeaderFlags::DisableLiquidityPoolDepositFlag),
            4 => Ok(LedgerHeaderFlags::DisableLiquidityPoolWithdrawalFlag),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type LedgerHeaderExtensionV1
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct LedgerHeaderExtensionV1 {
    pub flags: Uint32,
    pub ext: LedgerHeaderExtensionV1Ext,
}

#[cfg(feature = "all-types")]
impl XdrCodec for LedgerHeaderExtensionV1 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.flags.to_xdr_buffered(write_stream);
        self.ext.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(LedgerHeaderExtensionV1 {
            flags: Uint32::from_xdr_buffered(read_stream)?,
            ext: LedgerHeaderExtensionV1Ext::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type LedgerHeader
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct LedgerHeader {
    pub ledger_version: Uint32,
    pub previous_ledger_hash: Hash,
    pub scp_value: StellarValue,
    pub tx_set_result_hash: Hash,
    pub bucket_list_hash: Hash,
    pub ledger_seq: Uint32,
    pub total_coins: Int64,
    pub fee_pool: Int64,
    pub inflation_seq: Uint32,
    pub id_pool: Uint64,
    pub base_fee: Uint32,
    pub base_reserve: Uint32,
    pub max_tx_set_size: Uint32,
    pub skip_list: [Hash; 4],
    pub ext: LedgerHeaderExt,
}

#[cfg(feature = "all-types")]
impl XdrCodec for LedgerHeader {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.ledger_version.to_xdr_buffered(write_stream);
        self.previous_ledger_hash.to_xdr_buffered(write_stream);
        self.scp_value.to_xdr_buffered(write_stream);
        self.tx_set_result_hash.to_xdr_buffered(write_stream);
        self.bucket_list_hash.to_xdr_buffered(write_stream);
        self.ledger_seq.to_xdr_buffered(write_stream);
        self.total_coins.to_xdr_buffered(write_stream);
        self.fee_pool.to_xdr_buffered(write_stream);
        self.inflation_seq.to_xdr_buffered(write_stream);
        self.id_pool.to_xdr_buffered(write_stream);
        self.base_fee.to_xdr_buffered(write_stream);
        self.base_reserve.to_xdr_buffered(write_stream);
        self.max_tx_set_size.to_xdr_buffered(write_stream);
        self.skip_list.to_xdr_buffered(write_stream);
        self.ext.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(LedgerHeader {
            ledger_version: Uint32::from_xdr_buffered(read_stream)?,
            previous_ledger_hash: Hash::from_xdr_buffered(read_stream)?,
            scp_value: StellarValue::from_xdr_buffered(read_stream)?,
            tx_set_result_hash: Hash::from_xdr_buffered(read_stream)?,
            bucket_list_hash: Hash::from_xdr_buffered(read_stream)?,
            ledger_seq: Uint32::from_xdr_buffered(read_stream)?,
            total_coins: Int64::from_xdr_buffered(read_stream)?,
            fee_pool: Int64::from_xdr_buffered(read_stream)?,
            inflation_seq: Uint32::from_xdr_buffered(read_stream)?,
            id_pool: Uint64::from_xdr_buffered(read_stream)?,
            base_fee: Uint32::from_xdr_buffered(read_stream)?,
            base_reserve: Uint32::from_xdr_buffered(read_stream)?,
            max_tx_set_size: Uint32::from_xdr_buffered(read_stream)?,
            skip_list: <[Hash; 4]>::from_xdr_buffered(read_stream)?,
            ext: LedgerHeaderExt::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type LedgerUpgradeType
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum LedgerUpgradeType {
    LedgerUpgradeVersion = 1,
    LedgerUpgradeBaseFee = 2,
    LedgerUpgradeMaxTxSetSize = 3,
    LedgerUpgradeBaseReserve = 4,
    LedgerUpgradeFlags = 5,
    LedgerUpgradeConfig = 6,
    LedgerUpgradeMaxSorobanTxSetSize = 7,
}

#[cfg(feature = "all-types")]
impl XdrCodec for LedgerUpgradeType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            1 => Ok(LedgerUpgradeType::LedgerUpgradeVersion),
            2 => Ok(LedgerUpgradeType::LedgerUpgradeBaseFee),
            3 => Ok(LedgerUpgradeType::LedgerUpgradeMaxTxSetSize),
            4 => Ok(LedgerUpgradeType::LedgerUpgradeBaseReserve),
            5 => Ok(LedgerUpgradeType::LedgerUpgradeFlags),
            6 => Ok(LedgerUpgradeType::LedgerUpgradeConfig),
            7 => Ok(LedgerUpgradeType::LedgerUpgradeMaxSorobanTxSetSize),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ConfigUpgradeSetKey
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ConfigUpgradeSetKey {
    pub contract_id: Hash,
    pub content_hash: Hash,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ConfigUpgradeSetKey {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.contract_id.to_xdr_buffered(write_stream);
        self.content_hash.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ConfigUpgradeSetKey {
            contract_id: Hash::from_xdr_buffered(read_stream)?,
            content_hash: Hash::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ConfigUpgradeSet
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ConfigUpgradeSet {
    pub updated_entry: UnlimitedVarArray<ConfigSettingEntry>,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ConfigUpgradeSet {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.updated_entry.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ConfigUpgradeSet { updated_entry: UnlimitedVarArray::<ConfigSettingEntry>::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type BucketEntryType
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum BucketEntryType {
    Metaentry = -1,
    Liveentry = 0,
    Deadentry = 1,
    Initentry = 2,
}

#[cfg(feature = "all-types")]
impl XdrCodec for BucketEntryType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            -1 => Ok(BucketEntryType::Metaentry),
            0 => Ok(BucketEntryType::Liveentry),
            1 => Ok(BucketEntryType::Deadentry),
            2 => Ok(BucketEntryType::Initentry),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type BucketMetadata
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct BucketMetadata {
    pub ledger_version: Uint32,
    pub ext: BucketMetadataExt,
}

#[cfg(feature = "all-types")]
impl XdrCodec for BucketMetadata {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.ledger_version.to_xdr_buffered(write_stream);
        self.ext.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(BucketMetadata {
            ledger_version: Uint32::from_xdr_buffered(read_stream)?,
            ext: BucketMetadataExt::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type TxSetComponentType
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum TxSetComponentType {
    TxsetCompTxsMaybeDiscountedFee = 0,
}

#[cfg(feature = "all-types")]
impl XdrCodec for TxSetComponentType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(TxSetComponentType::TxsetCompTxsMaybeDiscountedFee),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type TxSetComponentTxsMaybeDiscountedFee
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct TxSetComponentTxsMaybeDiscountedFee {
    pub base_fee: Option<Int64>,
    pub txes: UnlimitedVarArray<TransactionEnvelope>,
}

#[cfg(feature = "all-types")]
impl XdrCodec for TxSetComponentTxsMaybeDiscountedFee {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.base_fee.to_xdr_buffered(write_stream);
        self.txes.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(TxSetComponentTxsMaybeDiscountedFee {
            base_fee: Option::<Int64>::from_xdr_buffered(read_stream)?,
            txes: UnlimitedVarArray::<TransactionEnvelope>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type TransactionSet
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct TransactionSet {
    pub previous_ledger_hash: Hash,
    pub txes: UnlimitedVarArray<TransactionEnvelope>,
}

#[cfg(feature = "all-types")]
impl XdrCodec for TransactionSet {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.previous_ledger_hash.to_xdr_buffered(write_stream);
        self.txes.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(TransactionSet {
            previous_ledger_hash: Hash::from_xdr_buffered(read_stream)?,
            txes: UnlimitedVarArray::<TransactionEnvelope>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type TransactionSetV1
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct TransactionSetV1 {
    pub previous_ledger_hash: Hash,
    pub phases: UnlimitedVarArray<TransactionPhase>,
}

#[cfg(feature = "all-types")]
impl XdrCodec for TransactionSetV1 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.previous_ledger_hash.to_xdr_buffered(write_stream);
        self.phases.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(TransactionSetV1 {
            previous_ledger_hash: Hash::from_xdr_buffered(read_stream)?,
            phases: UnlimitedVarArray::<TransactionPhase>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type TransactionResultPair
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct TransactionResultPair {
    pub transaction_hash: Hash,
    pub result: TransactionResult,
}

#[cfg(feature = "all-types")]
impl XdrCodec for TransactionResultPair {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.transaction_hash.to_xdr_buffered(write_stream);
        self.result.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(TransactionResultPair {
            transaction_hash: Hash::from_xdr_buffered(read_stream)?,
            result: TransactionResult::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type TransactionResultSet
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct TransactionResultSet {
    pub results: UnlimitedVarArray<TransactionResultPair>,
}

#[cfg(feature = "all-types")]
impl XdrCodec for TransactionResultSet {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.results.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(TransactionResultSet {
            results: UnlimitedVarArray::<TransactionResultPair>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type TransactionHistoryEntry
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct TransactionHistoryEntry {
    pub ledger_seq: Uint32,
    pub tx_set: TransactionSet,
    pub ext: TransactionHistoryEntryExt,
}

#[cfg(feature = "all-types")]
impl XdrCodec for TransactionHistoryEntry {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.ledger_seq.to_xdr_buffered(write_stream);
        self.tx_set.to_xdr_buffered(write_stream);
        self.ext.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(TransactionHistoryEntry {
            ledger_seq: Uint32::from_xdr_buffered(read_stream)?,
            tx_set: TransactionSet::from_xdr_buffered(read_stream)?,
            ext: TransactionHistoryEntryExt::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type TransactionHistoryResultEntry
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct TransactionHistoryResultEntry {
    pub ledger_seq: Uint32,
    pub tx_result_set: TransactionResultSet,
    pub ext: TransactionHistoryResultEntryExt,
}

#[cfg(feature = "all-types")]
impl XdrCodec for TransactionHistoryResultEntry {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.ledger_seq.to_xdr_buffered(write_stream);
        self.tx_result_set.to_xdr_buffered(write_stream);
        self.ext.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(TransactionHistoryResultEntry {
            ledger_seq: Uint32::from_xdr_buffered(read_stream)?,
            tx_result_set: TransactionResultSet::from_xdr_buffered(read_stream)?,
            ext: TransactionHistoryResultEntryExt::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type LedgerHeaderHistoryEntry
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct LedgerHeaderHistoryEntry {
    pub hash: Hash,
    pub header: LedgerHeader,
    pub ext: LedgerHeaderHistoryEntryExt,
}

#[cfg(feature = "all-types")]
impl XdrCodec for LedgerHeaderHistoryEntry {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.hash.to_xdr_buffered(write_stream);
        self.header.to_xdr_buffered(write_stream);
        self.ext.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(LedgerHeaderHistoryEntry {
            hash: Hash::from_xdr_buffered(read_stream)?,
            header: LedgerHeader::from_xdr_buffered(read_stream)?,
            ext: LedgerHeaderHistoryEntryExt::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type LedgerScpMessages
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct LedgerScpMessages {
    pub ledger_seq: Uint32,
    pub messages: UnlimitedVarArray<ScpEnvelope>,
}

#[cfg(feature = "all-types")]
impl XdrCodec for LedgerScpMessages {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.ledger_seq.to_xdr_buffered(write_stream);
        self.messages.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(LedgerScpMessages {
            ledger_seq: Uint32::from_xdr_buffered(read_stream)?,
            messages: UnlimitedVarArray::<ScpEnvelope>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ScpHistoryEntryV0
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ScpHistoryEntryV0 {
    pub quorum_sets: UnlimitedVarArray<ScpQuorumSet>,
    pub ledger_messages: LedgerScpMessages,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScpHistoryEntryV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.quorum_sets.to_xdr_buffered(write_stream);
        self.ledger_messages.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ScpHistoryEntryV0 {
            quorum_sets: UnlimitedVarArray::<ScpQuorumSet>::from_xdr_buffered(read_stream)?,
            ledger_messages: LedgerScpMessages::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type LedgerEntryChangeType
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum LedgerEntryChangeType {
    LedgerEntryCreated = 0,
    LedgerEntryUpdated = 1,
    LedgerEntryRemoved = 2,
    LedgerEntryState = 3,
}

impl XdrCodec for LedgerEntryChangeType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(LedgerEntryChangeType::LedgerEntryCreated),
            1 => Ok(LedgerEntryChangeType::LedgerEntryUpdated),
            2 => Ok(LedgerEntryChangeType::LedgerEntryRemoved),
            3 => Ok(LedgerEntryChangeType::LedgerEntryState),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type LedgerEntryChanges
#[allow(dead_code)]
pub type LedgerEntryChanges = UnlimitedVarArray<LedgerEntryChange>;

/// Autogenerated definition for type OperationMeta
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct OperationMeta {
    pub changes: LedgerEntryChanges,
}

impl XdrCodec for OperationMeta {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.changes.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(OperationMeta { changes: LedgerEntryChanges::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type TransactionMetaV1
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct TransactionMetaV1 {
    pub tx_changes: LedgerEntryChanges,
    pub operations: UnlimitedVarArray<OperationMeta>,
}

impl XdrCodec for TransactionMetaV1 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.tx_changes.to_xdr_buffered(write_stream);
        self.operations.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(TransactionMetaV1 {
            tx_changes: LedgerEntryChanges::from_xdr_buffered(read_stream)?,
            operations: UnlimitedVarArray::<OperationMeta>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type TransactionMetaV2
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct TransactionMetaV2 {
    pub tx_changes_before: LedgerEntryChanges,
    pub operations: UnlimitedVarArray<OperationMeta>,
    pub tx_changes_after: LedgerEntryChanges,
}

impl XdrCodec for TransactionMetaV2 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.tx_changes_before.to_xdr_buffered(write_stream);
        self.operations.to_xdr_buffered(write_stream);
        self.tx_changes_after.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(TransactionMetaV2 {
            tx_changes_before: LedgerEntryChanges::from_xdr_buffered(read_stream)?,
            operations: UnlimitedVarArray::<OperationMeta>::from_xdr_buffered(read_stream)?,
            tx_changes_after: LedgerEntryChanges::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ContractEventType
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ContractEventType {
    System = 0,
    Contract = 1,
    Diagnostic = 2,
}

impl XdrCodec for ContractEventType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ContractEventType::System),
            1 => Ok(ContractEventType::Contract),
            2 => Ok(ContractEventType::Diagnostic),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ContractEventV0
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ContractEventV0 {
    pub topics: UnlimitedVarArray<ScVal>,
    pub data: ScVal,
}

impl XdrCodec for ContractEventV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.topics.to_xdr_buffered(write_stream);
        self.data.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ContractEventV0 {
            topics: UnlimitedVarArray::<ScVal>::from_xdr_buffered(read_stream)?,
            data: ScVal::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ContractEvent
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ContractEvent {
    pub ext: ExtensionPoint,
    pub contract_id: Option<Hash>,
    pub type_: ContractEventType,
    pub body: ContractEventBody,
}

impl XdrCodec for ContractEvent {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.ext.to_xdr_buffered(write_stream);
        self.contract_id.to_xdr_buffered(write_stream);
        self.type_.to_xdr_buffered(write_stream);
        self.body.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ContractEvent {
            ext: ExtensionPoint::from_xdr_buffered(read_stream)?,
            contract_id: Option::<Hash>::from_xdr_buffered(read_stream)?,
            type_: ContractEventType::from_xdr_buffered(read_stream)?,
            body: ContractEventBody::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type DiagnosticEvent
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct DiagnosticEvent {
    pub in_successful_contract_call: bool,
    pub event: ContractEvent,
}

impl XdrCodec for DiagnosticEvent {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.in_successful_contract_call.to_xdr_buffered(write_stream);
        self.event.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(DiagnosticEvent {
            in_successful_contract_call: bool::from_xdr_buffered(read_stream)?,
            event: ContractEvent::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type SorobanTransactionMeta
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct SorobanTransactionMeta {
    pub ext: ExtensionPoint,
    pub events: UnlimitedVarArray<ContractEvent>,
    pub return_value: ScVal,
    pub diagnostic_events: UnlimitedVarArray<DiagnosticEvent>,
}

impl XdrCodec for SorobanTransactionMeta {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.ext.to_xdr_buffered(write_stream);
        self.events.to_xdr_buffered(write_stream);
        self.return_value.to_xdr_buffered(write_stream);
        self.diagnostic_events.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(SorobanTransactionMeta {
            ext: ExtensionPoint::from_xdr_buffered(read_stream)?,
            events: UnlimitedVarArray::<ContractEvent>::from_xdr_buffered(read_stream)?,
            return_value: ScVal::from_xdr_buffered(read_stream)?,
            diagnostic_events: UnlimitedVarArray::<DiagnosticEvent>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type TransactionMetaV3
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct TransactionMetaV3 {
    pub ext: ExtensionPoint,
    pub tx_changes_before: LedgerEntryChanges,
    pub operations: UnlimitedVarArray<OperationMeta>,
    pub tx_changes_after: LedgerEntryChanges,
    pub soroban_meta: Option<SorobanTransactionMeta>,
}

impl XdrCodec for TransactionMetaV3 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.ext.to_xdr_buffered(write_stream);
        self.tx_changes_before.to_xdr_buffered(write_stream);
        self.operations.to_xdr_buffered(write_stream);
        self.tx_changes_after.to_xdr_buffered(write_stream);
        self.soroban_meta.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(TransactionMetaV3 {
            ext: ExtensionPoint::from_xdr_buffered(read_stream)?,
            tx_changes_before: LedgerEntryChanges::from_xdr_buffered(read_stream)?,
            operations: UnlimitedVarArray::<OperationMeta>::from_xdr_buffered(read_stream)?,
            tx_changes_after: LedgerEntryChanges::from_xdr_buffered(read_stream)?,
            soroban_meta: Option::<SorobanTransactionMeta>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type InvokeHostFunctionSuccessPreImage
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct InvokeHostFunctionSuccessPreImage {
    pub return_value: ScVal,
    pub events: UnlimitedVarArray<ContractEvent>,
}

#[cfg(feature = "all-types")]
impl XdrCodec for InvokeHostFunctionSuccessPreImage {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.return_value.to_xdr_buffered(write_stream);
        self.events.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(InvokeHostFunctionSuccessPreImage {
            return_value: ScVal::from_xdr_buffered(read_stream)?,
            events: UnlimitedVarArray::<ContractEvent>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type TransactionResultMeta
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct TransactionResultMeta {
    pub result: TransactionResultPair,
    pub fee_processing: LedgerEntryChanges,
    pub tx_apply_processing: TransactionMeta,
}

#[cfg(feature = "all-types")]
impl XdrCodec for TransactionResultMeta {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.result.to_xdr_buffered(write_stream);
        self.fee_processing.to_xdr_buffered(write_stream);
        self.tx_apply_processing.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(TransactionResultMeta {
            result: TransactionResultPair::from_xdr_buffered(read_stream)?,
            fee_processing: LedgerEntryChanges::from_xdr_buffered(read_stream)?,
            tx_apply_processing: TransactionMeta::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type UpgradeEntryMeta
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct UpgradeEntryMeta {
    pub upgrade: LedgerUpgrade,
    pub changes: LedgerEntryChanges,
}

#[cfg(feature = "all-types")]
impl XdrCodec for UpgradeEntryMeta {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.upgrade.to_xdr_buffered(write_stream);
        self.changes.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(UpgradeEntryMeta {
            upgrade: LedgerUpgrade::from_xdr_buffered(read_stream)?,
            changes: LedgerEntryChanges::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type LedgerCloseMetaV0
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct LedgerCloseMetaV0 {
    pub ledger_header: LedgerHeaderHistoryEntry,
    pub tx_set: TransactionSet,
    pub tx_processing: UnlimitedVarArray<TransactionResultMeta>,
    pub upgrades_processing: UnlimitedVarArray<UpgradeEntryMeta>,
    pub scp_info: UnlimitedVarArray<ScpHistoryEntry>,
}

#[cfg(feature = "all-types")]
impl XdrCodec for LedgerCloseMetaV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.ledger_header.to_xdr_buffered(write_stream);
        self.tx_set.to_xdr_buffered(write_stream);
        self.tx_processing.to_xdr_buffered(write_stream);
        self.upgrades_processing.to_xdr_buffered(write_stream);
        self.scp_info.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(LedgerCloseMetaV0 {
            ledger_header: LedgerHeaderHistoryEntry::from_xdr_buffered(read_stream)?,
            tx_set: TransactionSet::from_xdr_buffered(read_stream)?,
            tx_processing: UnlimitedVarArray::<TransactionResultMeta>::from_xdr_buffered(read_stream)?,
            upgrades_processing: UnlimitedVarArray::<UpgradeEntryMeta>::from_xdr_buffered(read_stream)?,
            scp_info: UnlimitedVarArray::<ScpHistoryEntry>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type LedgerCloseMetaV1
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct LedgerCloseMetaV1 {
    pub ext: ExtensionPoint,
    pub ledger_header: LedgerHeaderHistoryEntry,
    pub tx_set: GeneralizedTransactionSet,
    pub tx_processing: UnlimitedVarArray<TransactionResultMeta>,
    pub upgrades_processing: UnlimitedVarArray<UpgradeEntryMeta>,
    pub scp_info: UnlimitedVarArray<ScpHistoryEntry>,
    pub total_byte_size_of_bucket_list: Uint64,
    pub evicted_temporary_ledger_keys: UnlimitedVarArray<LedgerKey>,
    pub evicted_persistent_ledger_entries: UnlimitedVarArray<LedgerEntry>,
}

#[cfg(feature = "all-types")]
impl XdrCodec for LedgerCloseMetaV1 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.ext.to_xdr_buffered(write_stream);
        self.ledger_header.to_xdr_buffered(write_stream);
        self.tx_set.to_xdr_buffered(write_stream);
        self.tx_processing.to_xdr_buffered(write_stream);
        self.upgrades_processing.to_xdr_buffered(write_stream);
        self.scp_info.to_xdr_buffered(write_stream);
        self.total_byte_size_of_bucket_list.to_xdr_buffered(write_stream);
        self.evicted_temporary_ledger_keys.to_xdr_buffered(write_stream);
        self.evicted_persistent_ledger_entries.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(LedgerCloseMetaV1 {
            ext: ExtensionPoint::from_xdr_buffered(read_stream)?,
            ledger_header: LedgerHeaderHistoryEntry::from_xdr_buffered(read_stream)?,
            tx_set: GeneralizedTransactionSet::from_xdr_buffered(read_stream)?,
            tx_processing: UnlimitedVarArray::<TransactionResultMeta>::from_xdr_buffered(read_stream)?,
            upgrades_processing: UnlimitedVarArray::<UpgradeEntryMeta>::from_xdr_buffered(read_stream)?,
            scp_info: UnlimitedVarArray::<ScpHistoryEntry>::from_xdr_buffered(read_stream)?,
            total_byte_size_of_bucket_list: Uint64::from_xdr_buffered(read_stream)?,
            evicted_temporary_ledger_keys: UnlimitedVarArray::<LedgerKey>::from_xdr_buffered(read_stream)?,
            evicted_persistent_ledger_entries: UnlimitedVarArray::<LedgerEntry>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ErrorCode
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ErrorCode {
    ErrMisc = 0,
    ErrData = 1,
    ErrConf = 2,
    ErrAuth = 3,
    ErrLoad = 4,
}

#[cfg(feature = "all-types")]
impl XdrCodec for ErrorCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ErrorCode::ErrMisc),
            1 => Ok(ErrorCode::ErrData),
            2 => Ok(ErrorCode::ErrConf),
            3 => Ok(ErrorCode::ErrAuth),
            4 => Ok(ErrorCode::ErrLoad),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type Error
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct Error {
    pub code: ErrorCode,
    pub msg: LimitedString<100>,
}

#[cfg(feature = "all-types")]
impl XdrCodec for Error {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.code.to_xdr_buffered(write_stream);
        self.msg.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(Error {
            code: ErrorCode::from_xdr_buffered(read_stream)?,
            msg: LimitedString::<100>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type SendMore
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct SendMore {
    pub num_messages: Uint32,
}

#[cfg(feature = "all-types")]
impl XdrCodec for SendMore {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.num_messages.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(SendMore { num_messages: Uint32::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type SendMoreExtended
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct SendMoreExtended {
    pub num_messages: Uint32,
    pub num_bytes: Uint32,
}

#[cfg(feature = "all-types")]
impl XdrCodec for SendMoreExtended {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.num_messages.to_xdr_buffered(write_stream);
        self.num_bytes.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(SendMoreExtended {
            num_messages: Uint32::from_xdr_buffered(read_stream)?,
            num_bytes: Uint32::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type AuthCert
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct AuthCert {
    pub pubkey: Curve25519Public,
    pub expiration: Uint64,
    pub sig: Signature,
}

#[cfg(feature = "all-types")]
impl XdrCodec for AuthCert {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.pubkey.to_xdr_buffered(write_stream);
        self.expiration.to_xdr_buffered(write_stream);
        self.sig.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(AuthCert {
            pubkey: Curve25519Public::from_xdr_buffered(read_stream)?,
            expiration: Uint64::from_xdr_buffered(read_stream)?,
            sig: Signature::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type Hello
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct Hello {
    pub ledger_version: Uint32,
    pub overlay_version: Uint32,
    pub overlay_min_version: Uint32,
    pub network_id: Hash,
    pub version_str: LimitedString<100>,
    pub listening_port: i32,
    pub peer_id: NodeId,
    pub cert: AuthCert,
    pub nonce: Uint256,
}

#[cfg(feature = "all-types")]
impl XdrCodec for Hello {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.ledger_version.to_xdr_buffered(write_stream);
        self.overlay_version.to_xdr_buffered(write_stream);
        self.overlay_min_version.to_xdr_buffered(write_stream);
        self.network_id.to_xdr_buffered(write_stream);
        self.version_str.to_xdr_buffered(write_stream);
        self.listening_port.to_xdr_buffered(write_stream);
        self.peer_id.to_xdr_buffered(write_stream);
        self.cert.to_xdr_buffered(write_stream);
        self.nonce.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(Hello {
            ledger_version: Uint32::from_xdr_buffered(read_stream)?,
            overlay_version: Uint32::from_xdr_buffered(read_stream)?,
            overlay_min_version: Uint32::from_xdr_buffered(read_stream)?,
            network_id: Hash::from_xdr_buffered(read_stream)?,
            version_str: LimitedString::<100>::from_xdr_buffered(read_stream)?,
            listening_port: i32::from_xdr_buffered(read_stream)?,
            peer_id: NodeId::from_xdr_buffered(read_stream)?,
            cert: AuthCert::from_xdr_buffered(read_stream)?,
            nonce: Uint256::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type Auth
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct Auth {
    pub flags: i32,
}

#[cfg(feature = "all-types")]
impl XdrCodec for Auth {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.flags.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(Auth { flags: i32::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type IpAddrType
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum IpAddrType {
    IPv4 = 0,
    IPv6 = 1,
}

#[cfg(feature = "all-types")]
impl XdrCodec for IpAddrType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(IpAddrType::IPv4),
            1 => Ok(IpAddrType::IPv6),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type PeerAddress
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct PeerAddress {
    pub ip: PeerAddressIp,
    pub port: Uint32,
    pub num_failures: Uint32,
}

#[cfg(feature = "all-types")]
impl XdrCodec for PeerAddress {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.ip.to_xdr_buffered(write_stream);
        self.port.to_xdr_buffered(write_stream);
        self.num_failures.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(PeerAddress {
            ip: PeerAddressIp::from_xdr_buffered(read_stream)?,
            port: Uint32::from_xdr_buffered(read_stream)?,
            num_failures: Uint32::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type MessageType
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum MessageType {
    ErrorMsg = 0,
    Auth = 2,
    DontHave = 3,
    GetPeers = 4,
    Peers = 5,
    GetTxSet = 6,
    TxSet = 7,
    GeneralizedTxSet = 17,
    Transaction = 8,
    GetScpQuorumset = 9,
    ScpQuorumset = 10,
    ScpMessage = 11,
    GetScpState = 12,
    Hello = 13,
    SurveyRequest = 14,
    SurveyResponse = 15,
    SendMore = 16,
    SendMoreExtended = 20,
    FloodAdvert = 18,
    FloodDemand = 19,
}

#[cfg(feature = "all-types")]
impl XdrCodec for MessageType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(MessageType::ErrorMsg),
            2 => Ok(MessageType::Auth),
            3 => Ok(MessageType::DontHave),
            4 => Ok(MessageType::GetPeers),
            5 => Ok(MessageType::Peers),
            6 => Ok(MessageType::GetTxSet),
            7 => Ok(MessageType::TxSet),
            17 => Ok(MessageType::GeneralizedTxSet),
            8 => Ok(MessageType::Transaction),
            9 => Ok(MessageType::GetScpQuorumset),
            10 => Ok(MessageType::ScpQuorumset),
            11 => Ok(MessageType::ScpMessage),
            12 => Ok(MessageType::GetScpState),
            13 => Ok(MessageType::Hello),
            14 => Ok(MessageType::SurveyRequest),
            15 => Ok(MessageType::SurveyResponse),
            16 => Ok(MessageType::SendMore),
            20 => Ok(MessageType::SendMoreExtended),
            18 => Ok(MessageType::FloodAdvert),
            19 => Ok(MessageType::FloodDemand),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type DontHave
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct DontHave {
    pub type_: MessageType,
    pub req_hash: Uint256,
}

#[cfg(feature = "all-types")]
impl XdrCodec for DontHave {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.type_.to_xdr_buffered(write_stream);
        self.req_hash.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(DontHave {
            type_: MessageType::from_xdr_buffered(read_stream)?,
            req_hash: Uint256::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type SurveyMessageCommandType
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum SurveyMessageCommandType {
    SurveyTopology = 0,
}

#[cfg(feature = "all-types")]
impl XdrCodec for SurveyMessageCommandType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(SurveyMessageCommandType::SurveyTopology),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type SurveyMessageResponseType
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum SurveyMessageResponseType {
    SurveyTopologyResponseV0 = 0,
    SurveyTopologyResponseV1 = 1,
}

#[cfg(feature = "all-types")]
impl XdrCodec for SurveyMessageResponseType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(SurveyMessageResponseType::SurveyTopologyResponseV0),
            1 => Ok(SurveyMessageResponseType::SurveyTopologyResponseV1),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type SurveyRequestMessage
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct SurveyRequestMessage {
    pub surveyor_peer_id: NodeId,
    pub surveyed_peer_id: NodeId,
    pub ledger_num: Uint32,
    pub encryption_key: Curve25519Public,
    pub command_type: SurveyMessageCommandType,
}

#[cfg(feature = "all-types")]
impl XdrCodec for SurveyRequestMessage {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.surveyor_peer_id.to_xdr_buffered(write_stream);
        self.surveyed_peer_id.to_xdr_buffered(write_stream);
        self.ledger_num.to_xdr_buffered(write_stream);
        self.encryption_key.to_xdr_buffered(write_stream);
        self.command_type.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(SurveyRequestMessage {
            surveyor_peer_id: NodeId::from_xdr_buffered(read_stream)?,
            surveyed_peer_id: NodeId::from_xdr_buffered(read_stream)?,
            ledger_num: Uint32::from_xdr_buffered(read_stream)?,
            encryption_key: Curve25519Public::from_xdr_buffered(read_stream)?,
            command_type: SurveyMessageCommandType::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type SignedSurveyRequestMessage
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct SignedSurveyRequestMessage {
    pub request_signature: Signature,
    pub request: SurveyRequestMessage,
}

#[cfg(feature = "all-types")]
impl XdrCodec for SignedSurveyRequestMessage {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.request_signature.to_xdr_buffered(write_stream);
        self.request.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(SignedSurveyRequestMessage {
            request_signature: Signature::from_xdr_buffered(read_stream)?,
            request: SurveyRequestMessage::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type EncryptedBody
#[allow(dead_code)]
#[cfg(feature = "all-types")]
pub type EncryptedBody = LimitedVarOpaque<64000>;

/// Autogenerated definition for type SurveyResponseMessage
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct SurveyResponseMessage {
    pub surveyor_peer_id: NodeId,
    pub surveyed_peer_id: NodeId,
    pub ledger_num: Uint32,
    pub command_type: SurveyMessageCommandType,
    pub encrypted_body: EncryptedBody,
}

#[cfg(feature = "all-types")]
impl XdrCodec for SurveyResponseMessage {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.surveyor_peer_id.to_xdr_buffered(write_stream);
        self.surveyed_peer_id.to_xdr_buffered(write_stream);
        self.ledger_num.to_xdr_buffered(write_stream);
        self.command_type.to_xdr_buffered(write_stream);
        self.encrypted_body.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(SurveyResponseMessage {
            surveyor_peer_id: NodeId::from_xdr_buffered(read_stream)?,
            surveyed_peer_id: NodeId::from_xdr_buffered(read_stream)?,
            ledger_num: Uint32::from_xdr_buffered(read_stream)?,
            command_type: SurveyMessageCommandType::from_xdr_buffered(read_stream)?,
            encrypted_body: EncryptedBody::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type SignedSurveyResponseMessage
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct SignedSurveyResponseMessage {
    pub response_signature: Signature,
    pub response: SurveyResponseMessage,
}

#[cfg(feature = "all-types")]
impl XdrCodec for SignedSurveyResponseMessage {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.response_signature.to_xdr_buffered(write_stream);
        self.response.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(SignedSurveyResponseMessage {
            response_signature: Signature::from_xdr_buffered(read_stream)?,
            response: SurveyResponseMessage::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type PeerStats
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct PeerStats {
    pub id: NodeId,
    pub version_str: LimitedString<100>,
    pub messages_read: Uint64,
    pub messages_written: Uint64,
    pub bytes_read: Uint64,
    pub bytes_written: Uint64,
    pub seconds_connected: Uint64,
    pub unique_flood_bytes_recv: Uint64,
    pub duplicate_flood_bytes_recv: Uint64,
    pub unique_fetch_bytes_recv: Uint64,
    pub duplicate_fetch_bytes_recv: Uint64,
    pub unique_flood_message_recv: Uint64,
    pub duplicate_flood_message_recv: Uint64,
    pub unique_fetch_message_recv: Uint64,
    pub duplicate_fetch_message_recv: Uint64,
}

#[cfg(feature = "all-types")]
impl XdrCodec for PeerStats {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.id.to_xdr_buffered(write_stream);
        self.version_str.to_xdr_buffered(write_stream);
        self.messages_read.to_xdr_buffered(write_stream);
        self.messages_written.to_xdr_buffered(write_stream);
        self.bytes_read.to_xdr_buffered(write_stream);
        self.bytes_written.to_xdr_buffered(write_stream);
        self.seconds_connected.to_xdr_buffered(write_stream);
        self.unique_flood_bytes_recv.to_xdr_buffered(write_stream);
        self.duplicate_flood_bytes_recv.to_xdr_buffered(write_stream);
        self.unique_fetch_bytes_recv.to_xdr_buffered(write_stream);
        self.duplicate_fetch_bytes_recv.to_xdr_buffered(write_stream);
        self.unique_flood_message_recv.to_xdr_buffered(write_stream);
        self.duplicate_flood_message_recv.to_xdr_buffered(write_stream);
        self.unique_fetch_message_recv.to_xdr_buffered(write_stream);
        self.duplicate_fetch_message_recv.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(PeerStats {
            id: NodeId::from_xdr_buffered(read_stream)?,
            version_str: LimitedString::<100>::from_xdr_buffered(read_stream)?,
            messages_read: Uint64::from_xdr_buffered(read_stream)?,
            messages_written: Uint64::from_xdr_buffered(read_stream)?,
            bytes_read: Uint64::from_xdr_buffered(read_stream)?,
            bytes_written: Uint64::from_xdr_buffered(read_stream)?,
            seconds_connected: Uint64::from_xdr_buffered(read_stream)?,
            unique_flood_bytes_recv: Uint64::from_xdr_buffered(read_stream)?,
            duplicate_flood_bytes_recv: Uint64::from_xdr_buffered(read_stream)?,
            unique_fetch_bytes_recv: Uint64::from_xdr_buffered(read_stream)?,
            duplicate_fetch_bytes_recv: Uint64::from_xdr_buffered(read_stream)?,
            unique_flood_message_recv: Uint64::from_xdr_buffered(read_stream)?,
            duplicate_flood_message_recv: Uint64::from_xdr_buffered(read_stream)?,
            unique_fetch_message_recv: Uint64::from_xdr_buffered(read_stream)?,
            duplicate_fetch_message_recv: Uint64::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type PeerStatList
#[allow(dead_code)]
#[cfg(feature = "all-types")]
pub type PeerStatList = LimitedVarArray<PeerStats, 25>;

/// Autogenerated definition for type TopologyResponseBodyV0
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct TopologyResponseBodyV0 {
    pub inbound_peers: PeerStatList,
    pub outbound_peers: PeerStatList,
    pub total_inbound_peer_count: Uint32,
    pub total_outbound_peer_count: Uint32,
}

#[cfg(feature = "all-types")]
impl XdrCodec for TopologyResponseBodyV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.inbound_peers.to_xdr_buffered(write_stream);
        self.outbound_peers.to_xdr_buffered(write_stream);
        self.total_inbound_peer_count.to_xdr_buffered(write_stream);
        self.total_outbound_peer_count.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(TopologyResponseBodyV0 {
            inbound_peers: PeerStatList::from_xdr_buffered(read_stream)?,
            outbound_peers: PeerStatList::from_xdr_buffered(read_stream)?,
            total_inbound_peer_count: Uint32::from_xdr_buffered(read_stream)?,
            total_outbound_peer_count: Uint32::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type TopologyResponseBodyV1
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct TopologyResponseBodyV1 {
    pub inbound_peers: PeerStatList,
    pub outbound_peers: PeerStatList,
    pub total_inbound_peer_count: Uint32,
    pub total_outbound_peer_count: Uint32,
    pub max_inbound_peer_count: Uint32,
    pub max_outbound_peer_count: Uint32,
}

#[cfg(feature = "all-types")]
impl XdrCodec for TopologyResponseBodyV1 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.inbound_peers.to_xdr_buffered(write_stream);
        self.outbound_peers.to_xdr_buffered(write_stream);
        self.total_inbound_peer_count.to_xdr_buffered(write_stream);
        self.total_outbound_peer_count.to_xdr_buffered(write_stream);
        self.max_inbound_peer_count.to_xdr_buffered(write_stream);
        self.max_outbound_peer_count.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(TopologyResponseBodyV1 {
            inbound_peers: PeerStatList::from_xdr_buffered(read_stream)?,
            outbound_peers: PeerStatList::from_xdr_buffered(read_stream)?,
            total_inbound_peer_count: Uint32::from_xdr_buffered(read_stream)?,
            total_outbound_peer_count: Uint32::from_xdr_buffered(read_stream)?,
            max_inbound_peer_count: Uint32::from_xdr_buffered(read_stream)?,
            max_outbound_peer_count: Uint32::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type TxAdvertVector
#[allow(dead_code)]
#[cfg(feature = "all-types")]
pub type TxAdvertVector = LimitedVarArray<Hash, TX_ADVERT_VECTOR_MAX_SIZE>;

/// Autogenerated definition for type FloodAdvert
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct FloodAdvert {
    pub tx_hashes: TxAdvertVector,
}

#[cfg(feature = "all-types")]
impl XdrCodec for FloodAdvert {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.tx_hashes.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(FloodAdvert { tx_hashes: TxAdvertVector::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type TxDemandVector
#[allow(dead_code)]
#[cfg(feature = "all-types")]
pub type TxDemandVector = LimitedVarArray<Hash, TX_DEMAND_VECTOR_MAX_SIZE>;

/// Autogenerated definition for type FloodDemand
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct FloodDemand {
    pub tx_hashes: TxDemandVector,
}

#[cfg(feature = "all-types")]
impl XdrCodec for FloodDemand {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.tx_hashes.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(FloodDemand { tx_hashes: TxDemandVector::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type AuthenticatedMessageV0
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct AuthenticatedMessageV0 {
    pub sequence: Uint64,
    pub message: StellarMessage,
    pub mac: HmacSha256Mac,
}

#[cfg(feature = "all-types")]
impl XdrCodec for AuthenticatedMessageV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.sequence.to_xdr_buffered(write_stream);
        self.message.to_xdr_buffered(write_stream);
        self.mac.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(AuthenticatedMessageV0 {
            sequence: Uint64::from_xdr_buffered(read_stream)?,
            message: StellarMessage::from_xdr_buffered(read_stream)?,
            mac: HmacSha256Mac::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type MuxedAccountMed25519
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct MuxedAccountMed25519 {
    pub id: Uint64,
    pub ed25519: Uint256,
}

impl XdrCodec for MuxedAccountMed25519 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.id.to_xdr_buffered(write_stream);
        self.ed25519.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(MuxedAccountMed25519 {
            id: Uint64::from_xdr_buffered(read_stream)?,
            ed25519: Uint256::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type DecoratedSignature
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct DecoratedSignature {
    pub hint: SignatureHint,
    pub signature: Signature,
}

impl XdrCodec for DecoratedSignature {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.hint.to_xdr_buffered(write_stream);
        self.signature.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(DecoratedSignature {
            hint: SignatureHint::from_xdr_buffered(read_stream)?,
            signature: Signature::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type OperationType
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum OperationType {
    CreateAccount = 0,
    Payment = 1,
    PathPaymentStrictReceive = 2,
    ManageSellOffer = 3,
    CreatePassiveSellOffer = 4,
    SetOptions = 5,
    ChangeTrust = 6,
    AllowTrust = 7,
    AccountMerge = 8,
    Inflation = 9,
    ManageData = 10,
    BumpSequence = 11,
    ManageBuyOffer = 12,
    PathPaymentStrictSend = 13,
    CreateClaimableBalance = 14,
    ClaimClaimableBalance = 15,
    BeginSponsoringFutureReserves = 16,
    EndSponsoringFutureReserves = 17,
    RevokeSponsorship = 18,
    Clawback = 19,
    ClawbackClaimableBalance = 20,
    SetTrustLineFlags = 21,
    LiquidityPoolDeposit = 22,
    LiquidityPoolWithdraw = 23,
    InvokeHostFunction = 24,
    ExtendFootprintTtl = 25,
    RestoreFootprint = 26,
}

impl XdrCodec for OperationType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(OperationType::CreateAccount),
            1 => Ok(OperationType::Payment),
            2 => Ok(OperationType::PathPaymentStrictReceive),
            3 => Ok(OperationType::ManageSellOffer),
            4 => Ok(OperationType::CreatePassiveSellOffer),
            5 => Ok(OperationType::SetOptions),
            6 => Ok(OperationType::ChangeTrust),
            7 => Ok(OperationType::AllowTrust),
            8 => Ok(OperationType::AccountMerge),
            9 => Ok(OperationType::Inflation),
            10 => Ok(OperationType::ManageData),
            11 => Ok(OperationType::BumpSequence),
            12 => Ok(OperationType::ManageBuyOffer),
            13 => Ok(OperationType::PathPaymentStrictSend),
            14 => Ok(OperationType::CreateClaimableBalance),
            15 => Ok(OperationType::ClaimClaimableBalance),
            16 => Ok(OperationType::BeginSponsoringFutureReserves),
            17 => Ok(OperationType::EndSponsoringFutureReserves),
            18 => Ok(OperationType::RevokeSponsorship),
            19 => Ok(OperationType::Clawback),
            20 => Ok(OperationType::ClawbackClaimableBalance),
            21 => Ok(OperationType::SetTrustLineFlags),
            22 => Ok(OperationType::LiquidityPoolDeposit),
            23 => Ok(OperationType::LiquidityPoolWithdraw),
            24 => Ok(OperationType::InvokeHostFunction),
            25 => Ok(OperationType::ExtendFootprintTtl),
            26 => Ok(OperationType::RestoreFootprint),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type CreateAccountOp
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct CreateAccountOp {
    pub destination: AccountId,
    pub starting_balance: Int64,
}

impl XdrCodec for CreateAccountOp {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.destination.to_xdr_buffered(write_stream);
        self.starting_balance.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(CreateAccountOp {
            destination: AccountId::from_xdr_buffered(read_stream)?,
            starting_balance: Int64::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type PaymentOp
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct PaymentOp {
    pub destination: MuxedAccount,
    pub asset: Asset,
    pub amount: Int64,
}

impl XdrCodec for PaymentOp {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.destination.to_xdr_buffered(write_stream);
        self.asset.to_xdr_buffered(write_stream);
        self.amount.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(PaymentOp {
            destination: MuxedAccount::from_xdr_buffered(read_stream)?,
            asset: Asset::from_xdr_buffered(read_stream)?,
            amount: Int64::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type PathPaymentStrictReceiveOp
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct PathPaymentStrictReceiveOp {
    pub send_asset: Asset,
    pub send_max: Int64,
    pub destination: MuxedAccount,
    pub dest_asset: Asset,
    pub dest_amount: Int64,
    pub path: LimitedVarArray<Asset, 5>,
}

impl XdrCodec for PathPaymentStrictReceiveOp {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.send_asset.to_xdr_buffered(write_stream);
        self.send_max.to_xdr_buffered(write_stream);
        self.destination.to_xdr_buffered(write_stream);
        self.dest_asset.to_xdr_buffered(write_stream);
        self.dest_amount.to_xdr_buffered(write_stream);
        self.path.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(PathPaymentStrictReceiveOp {
            send_asset: Asset::from_xdr_buffered(read_stream)?,
            send_max: Int64::from_xdr_buffered(read_stream)?,
            destination: MuxedAccount::from_xdr_buffered(read_stream)?,
            dest_asset: Asset::from_xdr_buffered(read_stream)?,
            dest_amount: Int64::from_xdr_buffered(read_stream)?,
            path: LimitedVarArray::<Asset, 5>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type PathPaymentStrictSendOp
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct PathPaymentStrictSendOp {
    pub send_asset: Asset,
    pub send_amount: Int64,
    pub destination: MuxedAccount,
    pub dest_asset: Asset,
    pub dest_min: Int64,
    pub path: LimitedVarArray<Asset, 5>,
}

impl XdrCodec for PathPaymentStrictSendOp {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.send_asset.to_xdr_buffered(write_stream);
        self.send_amount.to_xdr_buffered(write_stream);
        self.destination.to_xdr_buffered(write_stream);
        self.dest_asset.to_xdr_buffered(write_stream);
        self.dest_min.to_xdr_buffered(write_stream);
        self.path.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(PathPaymentStrictSendOp {
            send_asset: Asset::from_xdr_buffered(read_stream)?,
            send_amount: Int64::from_xdr_buffered(read_stream)?,
            destination: MuxedAccount::from_xdr_buffered(read_stream)?,
            dest_asset: Asset::from_xdr_buffered(read_stream)?,
            dest_min: Int64::from_xdr_buffered(read_stream)?,
            path: LimitedVarArray::<Asset, 5>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ManageSellOfferOp
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ManageSellOfferOp {
    pub selling: Asset,
    pub buying: Asset,
    pub amount: Int64,
    pub price: Price,
    pub offer_id: Int64,
}

impl XdrCodec for ManageSellOfferOp {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.selling.to_xdr_buffered(write_stream);
        self.buying.to_xdr_buffered(write_stream);
        self.amount.to_xdr_buffered(write_stream);
        self.price.to_xdr_buffered(write_stream);
        self.offer_id.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ManageSellOfferOp {
            selling: Asset::from_xdr_buffered(read_stream)?,
            buying: Asset::from_xdr_buffered(read_stream)?,
            amount: Int64::from_xdr_buffered(read_stream)?,
            price: Price::from_xdr_buffered(read_stream)?,
            offer_id: Int64::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ManageBuyOfferOp
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ManageBuyOfferOp {
    pub selling: Asset,
    pub buying: Asset,
    pub buy_amount: Int64,
    pub price: Price,
    pub offer_id: Int64,
}

impl XdrCodec for ManageBuyOfferOp {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.selling.to_xdr_buffered(write_stream);
        self.buying.to_xdr_buffered(write_stream);
        self.buy_amount.to_xdr_buffered(write_stream);
        self.price.to_xdr_buffered(write_stream);
        self.offer_id.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ManageBuyOfferOp {
            selling: Asset::from_xdr_buffered(read_stream)?,
            buying: Asset::from_xdr_buffered(read_stream)?,
            buy_amount: Int64::from_xdr_buffered(read_stream)?,
            price: Price::from_xdr_buffered(read_stream)?,
            offer_id: Int64::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type CreatePassiveSellOfferOp
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct CreatePassiveSellOfferOp {
    pub selling: Asset,
    pub buying: Asset,
    pub amount: Int64,
    pub price: Price,
}

impl XdrCodec for CreatePassiveSellOfferOp {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.selling.to_xdr_buffered(write_stream);
        self.buying.to_xdr_buffered(write_stream);
        self.amount.to_xdr_buffered(write_stream);
        self.price.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(CreatePassiveSellOfferOp {
            selling: Asset::from_xdr_buffered(read_stream)?,
            buying: Asset::from_xdr_buffered(read_stream)?,
            amount: Int64::from_xdr_buffered(read_stream)?,
            price: Price::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type SetOptionsOp
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct SetOptionsOp {
    pub inflation_dest: Option<AccountId>,
    pub clear_flags: Option<Uint32>,
    pub set_flags: Option<Uint32>,
    pub master_weight: Option<Uint32>,
    pub low_threshold: Option<Uint32>,
    pub med_threshold: Option<Uint32>,
    pub high_threshold: Option<Uint32>,
    pub home_domain: Option<String32>,
    pub signer: Option<Signer>,
}

impl XdrCodec for SetOptionsOp {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.inflation_dest.to_xdr_buffered(write_stream);
        self.clear_flags.to_xdr_buffered(write_stream);
        self.set_flags.to_xdr_buffered(write_stream);
        self.master_weight.to_xdr_buffered(write_stream);
        self.low_threshold.to_xdr_buffered(write_stream);
        self.med_threshold.to_xdr_buffered(write_stream);
        self.high_threshold.to_xdr_buffered(write_stream);
        self.home_domain.to_xdr_buffered(write_stream);
        self.signer.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(SetOptionsOp {
            inflation_dest: Option::<AccountId>::from_xdr_buffered(read_stream)?,
            clear_flags: Option::<Uint32>::from_xdr_buffered(read_stream)?,
            set_flags: Option::<Uint32>::from_xdr_buffered(read_stream)?,
            master_weight: Option::<Uint32>::from_xdr_buffered(read_stream)?,
            low_threshold: Option::<Uint32>::from_xdr_buffered(read_stream)?,
            med_threshold: Option::<Uint32>::from_xdr_buffered(read_stream)?,
            high_threshold: Option::<Uint32>::from_xdr_buffered(read_stream)?,
            home_domain: Option::<String32>::from_xdr_buffered(read_stream)?,
            signer: Option::<Signer>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ChangeTrustOp
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ChangeTrustOp {
    pub line: ChangeTrustAsset,
    pub limit: Int64,
}

impl XdrCodec for ChangeTrustOp {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.line.to_xdr_buffered(write_stream);
        self.limit.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ChangeTrustOp {
            line: ChangeTrustAsset::from_xdr_buffered(read_stream)?,
            limit: Int64::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type AllowTrustOp
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct AllowTrustOp {
    pub trustor: AccountId,
    pub asset: AssetCode,
    pub authorize: Uint32,
}

impl XdrCodec for AllowTrustOp {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.trustor.to_xdr_buffered(write_stream);
        self.asset.to_xdr_buffered(write_stream);
        self.authorize.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(AllowTrustOp {
            trustor: AccountId::from_xdr_buffered(read_stream)?,
            asset: AssetCode::from_xdr_buffered(read_stream)?,
            authorize: Uint32::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ManageDataOp
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ManageDataOp {
    pub data_name: String64,
    pub data_value: Option<DataValue>,
}

impl XdrCodec for ManageDataOp {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.data_name.to_xdr_buffered(write_stream);
        self.data_value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ManageDataOp {
            data_name: String64::from_xdr_buffered(read_stream)?,
            data_value: Option::<DataValue>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type BumpSequenceOp
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct BumpSequenceOp {
    pub bump_to: SequenceNumber,
}

impl XdrCodec for BumpSequenceOp {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.bump_to.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(BumpSequenceOp { bump_to: SequenceNumber::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type CreateClaimableBalanceOp
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct CreateClaimableBalanceOp {
    pub asset: Asset,
    pub amount: Int64,
    pub claimants: LimitedVarArray<Claimant, 10>,
}

impl XdrCodec for CreateClaimableBalanceOp {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.asset.to_xdr_buffered(write_stream);
        self.amount.to_xdr_buffered(write_stream);
        self.claimants.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(CreateClaimableBalanceOp {
            asset: Asset::from_xdr_buffered(read_stream)?,
            amount: Int64::from_xdr_buffered(read_stream)?,
            claimants: LimitedVarArray::<Claimant, 10>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ClaimClaimableBalanceOp
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ClaimClaimableBalanceOp {
    pub balance_id: ClaimableBalanceId,
}

impl XdrCodec for ClaimClaimableBalanceOp {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.balance_id.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ClaimClaimableBalanceOp { balance_id: ClaimableBalanceId::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type BeginSponsoringFutureReservesOp
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct BeginSponsoringFutureReservesOp {
    pub sponsored_id: AccountId,
}

impl XdrCodec for BeginSponsoringFutureReservesOp {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.sponsored_id.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(BeginSponsoringFutureReservesOp { sponsored_id: AccountId::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type RevokeSponsorshipType
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum RevokeSponsorshipType {
    RevokeSponsorshipLedgerEntry = 0,
    RevokeSponsorshipSigner = 1,
}

impl XdrCodec for RevokeSponsorshipType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(RevokeSponsorshipType::RevokeSponsorshipLedgerEntry),
            1 => Ok(RevokeSponsorshipType::RevokeSponsorshipSigner),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type RevokeSponsorshipOpSigner
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct RevokeSponsorshipOpSigner {
    pub account_id: AccountId,
    pub signer_key: SignerKey,
}

impl XdrCodec for RevokeSponsorshipOpSigner {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.account_id.to_xdr_buffered(write_stream);
        self.signer_key.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(RevokeSponsorshipOpSigner {
            account_id: AccountId::from_xdr_buffered(read_stream)?,
            signer_key: SignerKey::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ClawbackOp
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ClawbackOp {
    pub asset: Asset,
    pub from: MuxedAccount,
    pub amount: Int64,
}

impl XdrCodec for ClawbackOp {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.asset.to_xdr_buffered(write_stream);
        self.from.to_xdr_buffered(write_stream);
        self.amount.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ClawbackOp {
            asset: Asset::from_xdr_buffered(read_stream)?,
            from: MuxedAccount::from_xdr_buffered(read_stream)?,
            amount: Int64::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ClawbackClaimableBalanceOp
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ClawbackClaimableBalanceOp {
    pub balance_id: ClaimableBalanceId,
}

impl XdrCodec for ClawbackClaimableBalanceOp {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.balance_id.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ClawbackClaimableBalanceOp { balance_id: ClaimableBalanceId::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type SetTrustLineFlagsOp
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct SetTrustLineFlagsOp {
    pub trustor: AccountId,
    pub asset: Asset,
    pub clear_flags: Uint32,
    pub set_flags: Uint32,
}

impl XdrCodec for SetTrustLineFlagsOp {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.trustor.to_xdr_buffered(write_stream);
        self.asset.to_xdr_buffered(write_stream);
        self.clear_flags.to_xdr_buffered(write_stream);
        self.set_flags.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(SetTrustLineFlagsOp {
            trustor: AccountId::from_xdr_buffered(read_stream)?,
            asset: Asset::from_xdr_buffered(read_stream)?,
            clear_flags: Uint32::from_xdr_buffered(read_stream)?,
            set_flags: Uint32::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type LiquidityPoolDepositOp
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct LiquidityPoolDepositOp {
    pub liquidity_pool_id: PoolId,
    pub max_amount_a: Int64,
    pub max_amount_b: Int64,
    pub min_price: Price,
    pub max_price: Price,
}

impl XdrCodec for LiquidityPoolDepositOp {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.liquidity_pool_id.to_xdr_buffered(write_stream);
        self.max_amount_a.to_xdr_buffered(write_stream);
        self.max_amount_b.to_xdr_buffered(write_stream);
        self.min_price.to_xdr_buffered(write_stream);
        self.max_price.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(LiquidityPoolDepositOp {
            liquidity_pool_id: PoolId::from_xdr_buffered(read_stream)?,
            max_amount_a: Int64::from_xdr_buffered(read_stream)?,
            max_amount_b: Int64::from_xdr_buffered(read_stream)?,
            min_price: Price::from_xdr_buffered(read_stream)?,
            max_price: Price::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type LiquidityPoolWithdrawOp
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct LiquidityPoolWithdrawOp {
    pub liquidity_pool_id: PoolId,
    pub amount: Int64,
    pub min_amount_a: Int64,
    pub min_amount_b: Int64,
}

impl XdrCodec for LiquidityPoolWithdrawOp {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.liquidity_pool_id.to_xdr_buffered(write_stream);
        self.amount.to_xdr_buffered(write_stream);
        self.min_amount_a.to_xdr_buffered(write_stream);
        self.min_amount_b.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(LiquidityPoolWithdrawOp {
            liquidity_pool_id: PoolId::from_xdr_buffered(read_stream)?,
            amount: Int64::from_xdr_buffered(read_stream)?,
            min_amount_a: Int64::from_xdr_buffered(read_stream)?,
            min_amount_b: Int64::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type HostFunctionType
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum HostFunctionType {
    HostFunctionTypeInvokeContract = 0,
    HostFunctionTypeCreateContract = 1,
    HostFunctionTypeUploadContractWasm = 2,
}

impl XdrCodec for HostFunctionType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(HostFunctionType::HostFunctionTypeInvokeContract),
            1 => Ok(HostFunctionType::HostFunctionTypeCreateContract),
            2 => Ok(HostFunctionType::HostFunctionTypeUploadContractWasm),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ContractIdPreimageType
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ContractIdPreimageType {
    ContractIdPreimageFromAddress = 0,
    ContractIdPreimageFromAsset = 1,
}

impl XdrCodec for ContractIdPreimageType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ContractIdPreimageType::ContractIdPreimageFromAddress),
            1 => Ok(ContractIdPreimageType::ContractIdPreimageFromAsset),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ContractIdPreimageFromAddress
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ContractIdPreimageFromAddress {
    pub address: ScAddress,
    pub salt: Uint256,
}

impl XdrCodec for ContractIdPreimageFromAddress {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.address.to_xdr_buffered(write_stream);
        self.salt.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ContractIdPreimageFromAddress {
            address: ScAddress::from_xdr_buffered(read_stream)?,
            salt: Uint256::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type CreateContractArgs
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct CreateContractArgs {
    pub contract_id_preimage: ContractIdPreimage,
    pub executable: ContractExecutable,
}

impl XdrCodec for CreateContractArgs {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.contract_id_preimage.to_xdr_buffered(write_stream);
        self.executable.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(CreateContractArgs {
            contract_id_preimage: ContractIdPreimage::from_xdr_buffered(read_stream)?,
            executable: ContractExecutable::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type InvokeContractArgs
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct InvokeContractArgs {
    pub contract_address: ScAddress,
    pub function_name: ScSymbol,
    pub args: UnlimitedVarArray<ScVal>,
}

impl XdrCodec for InvokeContractArgs {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.contract_address.to_xdr_buffered(write_stream);
        self.function_name.to_xdr_buffered(write_stream);
        self.args.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(InvokeContractArgs {
            contract_address: ScAddress::from_xdr_buffered(read_stream)?,
            function_name: ScSymbol::from_xdr_buffered(read_stream)?,
            args: UnlimitedVarArray::<ScVal>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type SorobanAuthorizedFunctionType
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum SorobanAuthorizedFunctionType {
    SorobanAuthorizedFunctionTypeContractFn = 0,
    SorobanAuthorizedFunctionTypeCreateContractHostFn = 1,
}

impl XdrCodec for SorobanAuthorizedFunctionType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(SorobanAuthorizedFunctionType::SorobanAuthorizedFunctionTypeContractFn),
            1 => Ok(SorobanAuthorizedFunctionType::SorobanAuthorizedFunctionTypeCreateContractHostFn),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type SorobanAuthorizedInvocation
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct SorobanAuthorizedInvocation {
    pub function: SorobanAuthorizedFunction,
    pub sub_invocations: UnlimitedVarArray<SorobanAuthorizedInvocation>,
}

impl XdrCodec for SorobanAuthorizedInvocation {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.function.to_xdr_buffered(write_stream);
        self.sub_invocations.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(SorobanAuthorizedInvocation {
            function: SorobanAuthorizedFunction::from_xdr_buffered(read_stream)?,
            sub_invocations: UnlimitedVarArray::<SorobanAuthorizedInvocation>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type SorobanAddressCredentials
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct SorobanAddressCredentials {
    pub address: ScAddress,
    pub nonce: Int64,
    pub signature_expiration_ledger: Uint32,
    pub signature: ScVal,
}

impl XdrCodec for SorobanAddressCredentials {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.address.to_xdr_buffered(write_stream);
        self.nonce.to_xdr_buffered(write_stream);
        self.signature_expiration_ledger.to_xdr_buffered(write_stream);
        self.signature.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(SorobanAddressCredentials {
            address: ScAddress::from_xdr_buffered(read_stream)?,
            nonce: Int64::from_xdr_buffered(read_stream)?,
            signature_expiration_ledger: Uint32::from_xdr_buffered(read_stream)?,
            signature: ScVal::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type SorobanCredentialsType
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum SorobanCredentialsType {
    SorobanCredentialsSourceAccount = 0,
    SorobanCredentialsAddress = 1,
}

impl XdrCodec for SorobanCredentialsType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(SorobanCredentialsType::SorobanCredentialsSourceAccount),
            1 => Ok(SorobanCredentialsType::SorobanCredentialsAddress),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type SorobanAuthorizationEntry
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct SorobanAuthorizationEntry {
    pub credentials: SorobanCredentials,
    pub root_invocation: SorobanAuthorizedInvocation,
}

impl XdrCodec for SorobanAuthorizationEntry {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.credentials.to_xdr_buffered(write_stream);
        self.root_invocation.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(SorobanAuthorizationEntry {
            credentials: SorobanCredentials::from_xdr_buffered(read_stream)?,
            root_invocation: SorobanAuthorizedInvocation::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type InvokeHostFunctionOp
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct InvokeHostFunctionOp {
    pub host_function: HostFunction,
    pub auth: UnlimitedVarArray<SorobanAuthorizationEntry>,
}

impl XdrCodec for InvokeHostFunctionOp {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.host_function.to_xdr_buffered(write_stream);
        self.auth.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(InvokeHostFunctionOp {
            host_function: HostFunction::from_xdr_buffered(read_stream)?,
            auth: UnlimitedVarArray::<SorobanAuthorizationEntry>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ExtendFootprintTtlOp
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ExtendFootprintTtlOp {
    pub ext: ExtensionPoint,
    pub extend_to: Uint32,
}

impl XdrCodec for ExtendFootprintTtlOp {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.ext.to_xdr_buffered(write_stream);
        self.extend_to.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ExtendFootprintTtlOp {
            ext: ExtensionPoint::from_xdr_buffered(read_stream)?,
            extend_to: Uint32::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type RestoreFootprintOp
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct RestoreFootprintOp {
    pub ext: ExtensionPoint,
}

impl XdrCodec for RestoreFootprintOp {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.ext.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(RestoreFootprintOp { ext: ExtensionPoint::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type Operation
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct Operation {
    pub source_account: Option<MuxedAccount>,
    pub body: OperationBody,
}

impl XdrCodec for Operation {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.source_account.to_xdr_buffered(write_stream);
        self.body.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(Operation {
            source_account: Option::<MuxedAccount>::from_xdr_buffered(read_stream)?,
            body: OperationBody::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type HashIdPreimageOperationId
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct HashIdPreimageOperationId {
    pub source_account: AccountId,
    pub seq_num: SequenceNumber,
    pub op_num: Uint32,
}

#[cfg(feature = "all-types")]
impl XdrCodec for HashIdPreimageOperationId {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.source_account.to_xdr_buffered(write_stream);
        self.seq_num.to_xdr_buffered(write_stream);
        self.op_num.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(HashIdPreimageOperationId {
            source_account: AccountId::from_xdr_buffered(read_stream)?,
            seq_num: SequenceNumber::from_xdr_buffered(read_stream)?,
            op_num: Uint32::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type HashIdPreimageRevokeId
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct HashIdPreimageRevokeId {
    pub source_account: AccountId,
    pub seq_num: SequenceNumber,
    pub op_num: Uint32,
    pub liquidity_pool_id: PoolId,
    pub asset: Asset,
}

#[cfg(feature = "all-types")]
impl XdrCodec for HashIdPreimageRevokeId {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.source_account.to_xdr_buffered(write_stream);
        self.seq_num.to_xdr_buffered(write_stream);
        self.op_num.to_xdr_buffered(write_stream);
        self.liquidity_pool_id.to_xdr_buffered(write_stream);
        self.asset.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(HashIdPreimageRevokeId {
            source_account: AccountId::from_xdr_buffered(read_stream)?,
            seq_num: SequenceNumber::from_xdr_buffered(read_stream)?,
            op_num: Uint32::from_xdr_buffered(read_stream)?,
            liquidity_pool_id: PoolId::from_xdr_buffered(read_stream)?,
            asset: Asset::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type HashIdPreimageContractId
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct HashIdPreimageContractId {
    pub network_id: Hash,
    pub contract_id_preimage: ContractIdPreimage,
}

#[cfg(feature = "all-types")]
impl XdrCodec for HashIdPreimageContractId {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.network_id.to_xdr_buffered(write_stream);
        self.contract_id_preimage.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(HashIdPreimageContractId {
            network_id: Hash::from_xdr_buffered(read_stream)?,
            contract_id_preimage: ContractIdPreimage::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type HashIdPreimageSorobanAuthorization
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct HashIdPreimageSorobanAuthorization {
    pub network_id: Hash,
    pub nonce: Int64,
    pub signature_expiration_ledger: Uint32,
    pub invocation: SorobanAuthorizedInvocation,
}

#[cfg(feature = "all-types")]
impl XdrCodec for HashIdPreimageSorobanAuthorization {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.network_id.to_xdr_buffered(write_stream);
        self.nonce.to_xdr_buffered(write_stream);
        self.signature_expiration_ledger.to_xdr_buffered(write_stream);
        self.invocation.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(HashIdPreimageSorobanAuthorization {
            network_id: Hash::from_xdr_buffered(read_stream)?,
            nonce: Int64::from_xdr_buffered(read_stream)?,
            signature_expiration_ledger: Uint32::from_xdr_buffered(read_stream)?,
            invocation: SorobanAuthorizedInvocation::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type MemoType
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum MemoType {
    MemoNone = 0,
    MemoText = 1,
    MemoId = 2,
    MemoHash = 3,
    MemoReturn = 4,
}

impl XdrCodec for MemoType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(MemoType::MemoNone),
            1 => Ok(MemoType::MemoText),
            2 => Ok(MemoType::MemoId),
            3 => Ok(MemoType::MemoHash),
            4 => Ok(MemoType::MemoReturn),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type TimeBounds
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct TimeBounds {
    pub min_time: TimePoint,
    pub max_time: TimePoint,
}

impl XdrCodec for TimeBounds {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.min_time.to_xdr_buffered(write_stream);
        self.max_time.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(TimeBounds {
            min_time: TimePoint::from_xdr_buffered(read_stream)?,
            max_time: TimePoint::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type LedgerBounds
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct LedgerBounds {
    pub min_ledger: Uint32,
    pub max_ledger: Uint32,
}

impl XdrCodec for LedgerBounds {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.min_ledger.to_xdr_buffered(write_stream);
        self.max_ledger.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(LedgerBounds {
            min_ledger: Uint32::from_xdr_buffered(read_stream)?,
            max_ledger: Uint32::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type PreconditionsV2
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct PreconditionsV2 {
    pub time_bounds: Option<TimeBounds>,
    pub ledger_bounds: Option<LedgerBounds>,
    pub min_seq_num: Option<SequenceNumber>,
    pub min_seq_age: Duration,
    pub min_seq_ledger_gap: Uint32,
    pub extra_signers: LimitedVarArray<SignerKey, 2>,
}

impl XdrCodec for PreconditionsV2 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.time_bounds.to_xdr_buffered(write_stream);
        self.ledger_bounds.to_xdr_buffered(write_stream);
        self.min_seq_num.to_xdr_buffered(write_stream);
        self.min_seq_age.to_xdr_buffered(write_stream);
        self.min_seq_ledger_gap.to_xdr_buffered(write_stream);
        self.extra_signers.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(PreconditionsV2 {
            time_bounds: Option::<TimeBounds>::from_xdr_buffered(read_stream)?,
            ledger_bounds: Option::<LedgerBounds>::from_xdr_buffered(read_stream)?,
            min_seq_num: Option::<SequenceNumber>::from_xdr_buffered(read_stream)?,
            min_seq_age: Duration::from_xdr_buffered(read_stream)?,
            min_seq_ledger_gap: Uint32::from_xdr_buffered(read_stream)?,
            extra_signers: LimitedVarArray::<SignerKey, 2>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type PreconditionType
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum PreconditionType {
    PrecondNone = 0,
    PrecondTime = 1,
    PrecondV2 = 2,
}

impl XdrCodec for PreconditionType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(PreconditionType::PrecondNone),
            1 => Ok(PreconditionType::PrecondTime),
            2 => Ok(PreconditionType::PrecondV2),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type LedgerFootprint
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct LedgerFootprint {
    pub read_only: UnlimitedVarArray<LedgerKey>,
    pub read_write: UnlimitedVarArray<LedgerKey>,
}

impl XdrCodec for LedgerFootprint {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.read_only.to_xdr_buffered(write_stream);
        self.read_write.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(LedgerFootprint {
            read_only: UnlimitedVarArray::<LedgerKey>::from_xdr_buffered(read_stream)?,
            read_write: UnlimitedVarArray::<LedgerKey>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type SorobanResources
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct SorobanResources {
    pub footprint: LedgerFootprint,
    pub instructions: Uint32,
    pub read_bytes: Uint32,
    pub write_bytes: Uint32,
}

impl XdrCodec for SorobanResources {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.footprint.to_xdr_buffered(write_stream);
        self.instructions.to_xdr_buffered(write_stream);
        self.read_bytes.to_xdr_buffered(write_stream);
        self.write_bytes.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(SorobanResources {
            footprint: LedgerFootprint::from_xdr_buffered(read_stream)?,
            instructions: Uint32::from_xdr_buffered(read_stream)?,
            read_bytes: Uint32::from_xdr_buffered(read_stream)?,
            write_bytes: Uint32::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type SorobanTransactionData
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct SorobanTransactionData {
    pub ext: ExtensionPoint,
    pub resources: SorobanResources,
    pub resource_fee: Int64,
}

impl XdrCodec for SorobanTransactionData {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.ext.to_xdr_buffered(write_stream);
        self.resources.to_xdr_buffered(write_stream);
        self.resource_fee.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(SorobanTransactionData {
            ext: ExtensionPoint::from_xdr_buffered(read_stream)?,
            resources: SorobanResources::from_xdr_buffered(read_stream)?,
            resource_fee: Int64::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type TransactionV0
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct TransactionV0 {
    pub source_account_ed25519: Uint256,
    pub fee: Uint32,
    pub seq_num: SequenceNumber,
    pub time_bounds: Option<TimeBounds>,
    pub memo: Memo,
    pub operations: LimitedVarArray<Operation, MAX_OPS_PER_TX>,
    pub ext: TransactionV0Ext,
}

impl XdrCodec for TransactionV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.source_account_ed25519.to_xdr_buffered(write_stream);
        self.fee.to_xdr_buffered(write_stream);
        self.seq_num.to_xdr_buffered(write_stream);
        self.time_bounds.to_xdr_buffered(write_stream);
        self.memo.to_xdr_buffered(write_stream);
        self.operations.to_xdr_buffered(write_stream);
        self.ext.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(TransactionV0 {
            source_account_ed25519: Uint256::from_xdr_buffered(read_stream)?,
            fee: Uint32::from_xdr_buffered(read_stream)?,
            seq_num: SequenceNumber::from_xdr_buffered(read_stream)?,
            time_bounds: Option::<TimeBounds>::from_xdr_buffered(read_stream)?,
            memo: Memo::from_xdr_buffered(read_stream)?,
            operations: LimitedVarArray::<Operation, MAX_OPS_PER_TX>::from_xdr_buffered(read_stream)?,
            ext: TransactionV0Ext::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type TransactionV0Envelope
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct TransactionV0Envelope {
    pub tx: TransactionV0,
    pub signatures: LimitedVarArray<DecoratedSignature, 20>,
}

impl XdrCodec for TransactionV0Envelope {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.tx.to_xdr_buffered(write_stream);
        self.signatures.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(TransactionV0Envelope {
            tx: TransactionV0::from_xdr_buffered(read_stream)?,
            signatures: LimitedVarArray::<DecoratedSignature, 20>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type Transaction
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct Transaction {
    pub source_account: MuxedAccount,
    pub fee: Uint32,
    pub seq_num: SequenceNumber,
    pub cond: Preconditions,
    pub memo: Memo,
    pub operations: LimitedVarArray<Operation, MAX_OPS_PER_TX>,
    pub ext: TransactionExt,
}

impl XdrCodec for Transaction {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.source_account.to_xdr_buffered(write_stream);
        self.fee.to_xdr_buffered(write_stream);
        self.seq_num.to_xdr_buffered(write_stream);
        self.cond.to_xdr_buffered(write_stream);
        self.memo.to_xdr_buffered(write_stream);
        self.operations.to_xdr_buffered(write_stream);
        self.ext.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(Transaction {
            source_account: MuxedAccount::from_xdr_buffered(read_stream)?,
            fee: Uint32::from_xdr_buffered(read_stream)?,
            seq_num: SequenceNumber::from_xdr_buffered(read_stream)?,
            cond: Preconditions::from_xdr_buffered(read_stream)?,
            memo: Memo::from_xdr_buffered(read_stream)?,
            operations: LimitedVarArray::<Operation, MAX_OPS_PER_TX>::from_xdr_buffered(read_stream)?,
            ext: TransactionExt::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type TransactionV1Envelope
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct TransactionV1Envelope {
    pub tx: Transaction,
    pub signatures: LimitedVarArray<DecoratedSignature, 20>,
}

impl XdrCodec for TransactionV1Envelope {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.tx.to_xdr_buffered(write_stream);
        self.signatures.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(TransactionV1Envelope {
            tx: Transaction::from_xdr_buffered(read_stream)?,
            signatures: LimitedVarArray::<DecoratedSignature, 20>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type FeeBumpTransaction
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct FeeBumpTransaction {
    pub fee_source: MuxedAccount,
    pub fee: Int64,
    pub inner_tx: FeeBumpTransactionInnerTx,
    pub ext: FeeBumpTransactionExt,
}

impl XdrCodec for FeeBumpTransaction {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.fee_source.to_xdr_buffered(write_stream);
        self.fee.to_xdr_buffered(write_stream);
        self.inner_tx.to_xdr_buffered(write_stream);
        self.ext.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(FeeBumpTransaction {
            fee_source: MuxedAccount::from_xdr_buffered(read_stream)?,
            fee: Int64::from_xdr_buffered(read_stream)?,
            inner_tx: FeeBumpTransactionInnerTx::from_xdr_buffered(read_stream)?,
            ext: FeeBumpTransactionExt::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type FeeBumpTransactionEnvelope
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct FeeBumpTransactionEnvelope {
    pub tx: FeeBumpTransaction,
    pub signatures: LimitedVarArray<DecoratedSignature, 20>,
}

impl XdrCodec for FeeBumpTransactionEnvelope {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.tx.to_xdr_buffered(write_stream);
        self.signatures.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(FeeBumpTransactionEnvelope {
            tx: FeeBumpTransaction::from_xdr_buffered(read_stream)?,
            signatures: LimitedVarArray::<DecoratedSignature, 20>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type TransactionSignaturePayload
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct TransactionSignaturePayload {
    pub network_id: Hash,
    pub tagged_transaction: TransactionSignaturePayloadTaggedTransaction,
}

impl XdrCodec for TransactionSignaturePayload {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.network_id.to_xdr_buffered(write_stream);
        self.tagged_transaction.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(TransactionSignaturePayload {
            network_id: Hash::from_xdr_buffered(read_stream)?,
            tagged_transaction: TransactionSignaturePayloadTaggedTransaction::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ClaimAtomType
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ClaimAtomType {
    ClaimAtomTypeV0 = 0,
    ClaimAtomTypeOrderBook = 1,
    ClaimAtomTypeLiquidityPool = 2,
}

impl XdrCodec for ClaimAtomType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ClaimAtomType::ClaimAtomTypeV0),
            1 => Ok(ClaimAtomType::ClaimAtomTypeOrderBook),
            2 => Ok(ClaimAtomType::ClaimAtomTypeLiquidityPool),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ClaimOfferAtomV0
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ClaimOfferAtomV0 {
    pub seller_ed25519: Uint256,
    pub offer_id: Int64,
    pub asset_sold: Asset,
    pub amount_sold: Int64,
    pub asset_bought: Asset,
    pub amount_bought: Int64,
}

impl XdrCodec for ClaimOfferAtomV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.seller_ed25519.to_xdr_buffered(write_stream);
        self.offer_id.to_xdr_buffered(write_stream);
        self.asset_sold.to_xdr_buffered(write_stream);
        self.amount_sold.to_xdr_buffered(write_stream);
        self.asset_bought.to_xdr_buffered(write_stream);
        self.amount_bought.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ClaimOfferAtomV0 {
            seller_ed25519: Uint256::from_xdr_buffered(read_stream)?,
            offer_id: Int64::from_xdr_buffered(read_stream)?,
            asset_sold: Asset::from_xdr_buffered(read_stream)?,
            amount_sold: Int64::from_xdr_buffered(read_stream)?,
            asset_bought: Asset::from_xdr_buffered(read_stream)?,
            amount_bought: Int64::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ClaimOfferAtom
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ClaimOfferAtom {
    pub seller_id: AccountId,
    pub offer_id: Int64,
    pub asset_sold: Asset,
    pub amount_sold: Int64,
    pub asset_bought: Asset,
    pub amount_bought: Int64,
}

impl XdrCodec for ClaimOfferAtom {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.seller_id.to_xdr_buffered(write_stream);
        self.offer_id.to_xdr_buffered(write_stream);
        self.asset_sold.to_xdr_buffered(write_stream);
        self.amount_sold.to_xdr_buffered(write_stream);
        self.asset_bought.to_xdr_buffered(write_stream);
        self.amount_bought.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ClaimOfferAtom {
            seller_id: AccountId::from_xdr_buffered(read_stream)?,
            offer_id: Int64::from_xdr_buffered(read_stream)?,
            asset_sold: Asset::from_xdr_buffered(read_stream)?,
            amount_sold: Int64::from_xdr_buffered(read_stream)?,
            asset_bought: Asset::from_xdr_buffered(read_stream)?,
            amount_bought: Int64::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ClaimLiquidityAtom
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ClaimLiquidityAtom {
    pub liquidity_pool_id: PoolId,
    pub asset_sold: Asset,
    pub amount_sold: Int64,
    pub asset_bought: Asset,
    pub amount_bought: Int64,
}

impl XdrCodec for ClaimLiquidityAtom {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.liquidity_pool_id.to_xdr_buffered(write_stream);
        self.asset_sold.to_xdr_buffered(write_stream);
        self.amount_sold.to_xdr_buffered(write_stream);
        self.asset_bought.to_xdr_buffered(write_stream);
        self.amount_bought.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ClaimLiquidityAtom {
            liquidity_pool_id: PoolId::from_xdr_buffered(read_stream)?,
            asset_sold: Asset::from_xdr_buffered(read_stream)?,
            amount_sold: Int64::from_xdr_buffered(read_stream)?,
            asset_bought: Asset::from_xdr_buffered(read_stream)?,
            amount_bought: Int64::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type CreateAccountResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum CreateAccountResultCode {
    CreateAccountSuccess = 0,
    CreateAccountMalformed = -1,
    CreateAccountUnderfunded = -2,
    CreateAccountLowReserve = -3,
    CreateAccountAlreadyExist = -4,
}

impl XdrCodec for CreateAccountResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(CreateAccountResultCode::CreateAccountSuccess),
            -1 => Ok(CreateAccountResultCode::CreateAccountMalformed),
            -2 => Ok(CreateAccountResultCode::CreateAccountUnderfunded),
            -3 => Ok(CreateAccountResultCode::CreateAccountLowReserve),
            -4 => Ok(CreateAccountResultCode::CreateAccountAlreadyExist),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type PaymentResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum PaymentResultCode {
    PaymentSuccess = 0,
    PaymentMalformed = -1,
    PaymentUnderfunded = -2,
    PaymentSrcNoTrust = -3,
    PaymentSrcNotAuthorized = -4,
    PaymentNoDestination = -5,
    PaymentNoTrust = -6,
    PaymentNotAuthorized = -7,
    PaymentLineFull = -8,
    PaymentNoIssuer = -9,
}

impl XdrCodec for PaymentResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(PaymentResultCode::PaymentSuccess),
            -1 => Ok(PaymentResultCode::PaymentMalformed),
            -2 => Ok(PaymentResultCode::PaymentUnderfunded),
            -3 => Ok(PaymentResultCode::PaymentSrcNoTrust),
            -4 => Ok(PaymentResultCode::PaymentSrcNotAuthorized),
            -5 => Ok(PaymentResultCode::PaymentNoDestination),
            -6 => Ok(PaymentResultCode::PaymentNoTrust),
            -7 => Ok(PaymentResultCode::PaymentNotAuthorized),
            -8 => Ok(PaymentResultCode::PaymentLineFull),
            -9 => Ok(PaymentResultCode::PaymentNoIssuer),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type PathPaymentStrictReceiveResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum PathPaymentStrictReceiveResultCode {
    PathPaymentStrictReceiveSuccess = 0,
    PathPaymentStrictReceiveMalformed = -1,
    PathPaymentStrictReceiveUnderfunded = -2,
    PathPaymentStrictReceiveSrcNoTrust = -3,
    PathPaymentStrictReceiveSrcNotAuthorized = -4,
    PathPaymentStrictReceiveNoDestination = -5,
    PathPaymentStrictReceiveNoTrust = -6,
    PathPaymentStrictReceiveNotAuthorized = -7,
    PathPaymentStrictReceiveLineFull = -8,
    PathPaymentStrictReceiveNoIssuer = -9,
    PathPaymentStrictReceiveTooFewOffers = -10,
    PathPaymentStrictReceiveOfferCrossSelf = -11,
    PathPaymentStrictReceiveOverSendmax = -12,
}

impl XdrCodec for PathPaymentStrictReceiveResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveSuccess),
            -1 => Ok(PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveMalformed),
            -2 => Ok(PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveUnderfunded),
            -3 => Ok(PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveSrcNoTrust),
            -4 => Ok(PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveSrcNotAuthorized),
            -5 => Ok(PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNoDestination),
            -6 => Ok(PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNoTrust),
            -7 => Ok(PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNotAuthorized),
            -8 => Ok(PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveLineFull),
            -9 => Ok(PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNoIssuer),
            -10 => Ok(PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveTooFewOffers),
            -11 => Ok(PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveOfferCrossSelf),
            -12 => Ok(PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveOverSendmax),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type SimplePaymentResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct SimplePaymentResult {
    pub destination: AccountId,
    pub asset: Asset,
    pub amount: Int64,
}

impl XdrCodec for SimplePaymentResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.destination.to_xdr_buffered(write_stream);
        self.asset.to_xdr_buffered(write_stream);
        self.amount.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(SimplePaymentResult {
            destination: AccountId::from_xdr_buffered(read_stream)?,
            asset: Asset::from_xdr_buffered(read_stream)?,
            amount: Int64::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type PathPaymentStrictReceiveResultSuccess
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct PathPaymentStrictReceiveResultSuccess {
    pub offers: UnlimitedVarArray<ClaimAtom>,
    pub last: SimplePaymentResult,
}

impl XdrCodec for PathPaymentStrictReceiveResultSuccess {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.offers.to_xdr_buffered(write_stream);
        self.last.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(PathPaymentStrictReceiveResultSuccess {
            offers: UnlimitedVarArray::<ClaimAtom>::from_xdr_buffered(read_stream)?,
            last: SimplePaymentResult::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type PathPaymentStrictSendResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum PathPaymentStrictSendResultCode {
    PathPaymentStrictSendSuccess = 0,
    PathPaymentStrictSendMalformed = -1,
    PathPaymentStrictSendUnderfunded = -2,
    PathPaymentStrictSendSrcNoTrust = -3,
    PathPaymentStrictSendSrcNotAuthorized = -4,
    PathPaymentStrictSendNoDestination = -5,
    PathPaymentStrictSendNoTrust = -6,
    PathPaymentStrictSendNotAuthorized = -7,
    PathPaymentStrictSendLineFull = -8,
    PathPaymentStrictSendNoIssuer = -9,
    PathPaymentStrictSendTooFewOffers = -10,
    PathPaymentStrictSendOfferCrossSelf = -11,
    PathPaymentStrictSendUnderDestmin = -12,
}

impl XdrCodec for PathPaymentStrictSendResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(PathPaymentStrictSendResultCode::PathPaymentStrictSendSuccess),
            -1 => Ok(PathPaymentStrictSendResultCode::PathPaymentStrictSendMalformed),
            -2 => Ok(PathPaymentStrictSendResultCode::PathPaymentStrictSendUnderfunded),
            -3 => Ok(PathPaymentStrictSendResultCode::PathPaymentStrictSendSrcNoTrust),
            -4 => Ok(PathPaymentStrictSendResultCode::PathPaymentStrictSendSrcNotAuthorized),
            -5 => Ok(PathPaymentStrictSendResultCode::PathPaymentStrictSendNoDestination),
            -6 => Ok(PathPaymentStrictSendResultCode::PathPaymentStrictSendNoTrust),
            -7 => Ok(PathPaymentStrictSendResultCode::PathPaymentStrictSendNotAuthorized),
            -8 => Ok(PathPaymentStrictSendResultCode::PathPaymentStrictSendLineFull),
            -9 => Ok(PathPaymentStrictSendResultCode::PathPaymentStrictSendNoIssuer),
            -10 => Ok(PathPaymentStrictSendResultCode::PathPaymentStrictSendTooFewOffers),
            -11 => Ok(PathPaymentStrictSendResultCode::PathPaymentStrictSendOfferCrossSelf),
            -12 => Ok(PathPaymentStrictSendResultCode::PathPaymentStrictSendUnderDestmin),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type PathPaymentStrictSendResultSuccess
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct PathPaymentStrictSendResultSuccess {
    pub offers: UnlimitedVarArray<ClaimAtom>,
    pub last: SimplePaymentResult,
}

impl XdrCodec for PathPaymentStrictSendResultSuccess {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.offers.to_xdr_buffered(write_stream);
        self.last.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(PathPaymentStrictSendResultSuccess {
            offers: UnlimitedVarArray::<ClaimAtom>::from_xdr_buffered(read_stream)?,
            last: SimplePaymentResult::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ManageSellOfferResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ManageSellOfferResultCode {
    ManageSellOfferSuccess = 0,
    ManageSellOfferMalformed = -1,
    ManageSellOfferSellNoTrust = -2,
    ManageSellOfferBuyNoTrust = -3,
    ManageSellOfferSellNotAuthorized = -4,
    ManageSellOfferBuyNotAuthorized = -5,
    ManageSellOfferLineFull = -6,
    ManageSellOfferUnderfunded = -7,
    ManageSellOfferCrossSelf = -8,
    ManageSellOfferSellNoIssuer = -9,
    ManageSellOfferBuyNoIssuer = -10,
    ManageSellOfferNotFound = -11,
    ManageSellOfferLowReserve = -12,
}

impl XdrCodec for ManageSellOfferResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ManageSellOfferResultCode::ManageSellOfferSuccess),
            -1 => Ok(ManageSellOfferResultCode::ManageSellOfferMalformed),
            -2 => Ok(ManageSellOfferResultCode::ManageSellOfferSellNoTrust),
            -3 => Ok(ManageSellOfferResultCode::ManageSellOfferBuyNoTrust),
            -4 => Ok(ManageSellOfferResultCode::ManageSellOfferSellNotAuthorized),
            -5 => Ok(ManageSellOfferResultCode::ManageSellOfferBuyNotAuthorized),
            -6 => Ok(ManageSellOfferResultCode::ManageSellOfferLineFull),
            -7 => Ok(ManageSellOfferResultCode::ManageSellOfferUnderfunded),
            -8 => Ok(ManageSellOfferResultCode::ManageSellOfferCrossSelf),
            -9 => Ok(ManageSellOfferResultCode::ManageSellOfferSellNoIssuer),
            -10 => Ok(ManageSellOfferResultCode::ManageSellOfferBuyNoIssuer),
            -11 => Ok(ManageSellOfferResultCode::ManageSellOfferNotFound),
            -12 => Ok(ManageSellOfferResultCode::ManageSellOfferLowReserve),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ManageOfferEffect
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ManageOfferEffect {
    ManageOfferCreated = 0,
    ManageOfferUpdated = 1,
    ManageOfferDeleted = 2,
}

impl XdrCodec for ManageOfferEffect {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ManageOfferEffect::ManageOfferCreated),
            1 => Ok(ManageOfferEffect::ManageOfferUpdated),
            2 => Ok(ManageOfferEffect::ManageOfferDeleted),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ManageOfferSuccessResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct ManageOfferSuccessResult {
    pub offers_claimed: UnlimitedVarArray<ClaimAtom>,
    pub offer: ManageOfferSuccessResultOffer,
}

impl XdrCodec for ManageOfferSuccessResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.offers_claimed.to_xdr_buffered(write_stream);
        self.offer.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(ManageOfferSuccessResult {
            offers_claimed: UnlimitedVarArray::<ClaimAtom>::from_xdr_buffered(read_stream)?,
            offer: ManageOfferSuccessResultOffer::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ManageBuyOfferResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ManageBuyOfferResultCode {
    ManageBuyOfferSuccess = 0,
    ManageBuyOfferMalformed = -1,
    ManageBuyOfferSellNoTrust = -2,
    ManageBuyOfferBuyNoTrust = -3,
    ManageBuyOfferSellNotAuthorized = -4,
    ManageBuyOfferBuyNotAuthorized = -5,
    ManageBuyOfferLineFull = -6,
    ManageBuyOfferUnderfunded = -7,
    ManageBuyOfferCrossSelf = -8,
    ManageBuyOfferSellNoIssuer = -9,
    ManageBuyOfferBuyNoIssuer = -10,
    ManageBuyOfferNotFound = -11,
    ManageBuyOfferLowReserve = -12,
}

impl XdrCodec for ManageBuyOfferResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ManageBuyOfferResultCode::ManageBuyOfferSuccess),
            -1 => Ok(ManageBuyOfferResultCode::ManageBuyOfferMalformed),
            -2 => Ok(ManageBuyOfferResultCode::ManageBuyOfferSellNoTrust),
            -3 => Ok(ManageBuyOfferResultCode::ManageBuyOfferBuyNoTrust),
            -4 => Ok(ManageBuyOfferResultCode::ManageBuyOfferSellNotAuthorized),
            -5 => Ok(ManageBuyOfferResultCode::ManageBuyOfferBuyNotAuthorized),
            -6 => Ok(ManageBuyOfferResultCode::ManageBuyOfferLineFull),
            -7 => Ok(ManageBuyOfferResultCode::ManageBuyOfferUnderfunded),
            -8 => Ok(ManageBuyOfferResultCode::ManageBuyOfferCrossSelf),
            -9 => Ok(ManageBuyOfferResultCode::ManageBuyOfferSellNoIssuer),
            -10 => Ok(ManageBuyOfferResultCode::ManageBuyOfferBuyNoIssuer),
            -11 => Ok(ManageBuyOfferResultCode::ManageBuyOfferNotFound),
            -12 => Ok(ManageBuyOfferResultCode::ManageBuyOfferLowReserve),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type SetOptionsResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum SetOptionsResultCode {
    SetOptionsSuccess = 0,
    SetOptionsLowReserve = -1,
    SetOptionsTooManySigners = -2,
    SetOptionsBadFlags = -3,
    SetOptionsInvalidInflation = -4,
    SetOptionsCantChange = -5,
    SetOptionsUnknownFlag = -6,
    SetOptionsThresholdOutOfRange = -7,
    SetOptionsBadSigner = -8,
    SetOptionsInvalidHomeDomain = -9,
    SetOptionsAuthRevocableRequired = -10,
}

impl XdrCodec for SetOptionsResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(SetOptionsResultCode::SetOptionsSuccess),
            -1 => Ok(SetOptionsResultCode::SetOptionsLowReserve),
            -2 => Ok(SetOptionsResultCode::SetOptionsTooManySigners),
            -3 => Ok(SetOptionsResultCode::SetOptionsBadFlags),
            -4 => Ok(SetOptionsResultCode::SetOptionsInvalidInflation),
            -5 => Ok(SetOptionsResultCode::SetOptionsCantChange),
            -6 => Ok(SetOptionsResultCode::SetOptionsUnknownFlag),
            -7 => Ok(SetOptionsResultCode::SetOptionsThresholdOutOfRange),
            -8 => Ok(SetOptionsResultCode::SetOptionsBadSigner),
            -9 => Ok(SetOptionsResultCode::SetOptionsInvalidHomeDomain),
            -10 => Ok(SetOptionsResultCode::SetOptionsAuthRevocableRequired),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ChangeTrustResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ChangeTrustResultCode {
    ChangeTrustSuccess = 0,
    ChangeTrustMalformed = -1,
    ChangeTrustNoIssuer = -2,
    ChangeTrustInvalidLimit = -3,
    ChangeTrustLowReserve = -4,
    ChangeTrustSelfNotAllowed = -5,
    ChangeTrustTrustLineMissing = -6,
    ChangeTrustCannotDelete = -7,
    ChangeTrustNotAuthMaintainLiabilities = -8,
}

impl XdrCodec for ChangeTrustResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ChangeTrustResultCode::ChangeTrustSuccess),
            -1 => Ok(ChangeTrustResultCode::ChangeTrustMalformed),
            -2 => Ok(ChangeTrustResultCode::ChangeTrustNoIssuer),
            -3 => Ok(ChangeTrustResultCode::ChangeTrustInvalidLimit),
            -4 => Ok(ChangeTrustResultCode::ChangeTrustLowReserve),
            -5 => Ok(ChangeTrustResultCode::ChangeTrustSelfNotAllowed),
            -6 => Ok(ChangeTrustResultCode::ChangeTrustTrustLineMissing),
            -7 => Ok(ChangeTrustResultCode::ChangeTrustCannotDelete),
            -8 => Ok(ChangeTrustResultCode::ChangeTrustNotAuthMaintainLiabilities),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type AllowTrustResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum AllowTrustResultCode {
    AllowTrustSuccess = 0,
    AllowTrustMalformed = -1,
    AllowTrustNoTrustLine = -2,
    AllowTrustTrustNotRequired = -3,
    AllowTrustCantRevoke = -4,
    AllowTrustSelfNotAllowed = -5,
    AllowTrustLowReserve = -6,
}

impl XdrCodec for AllowTrustResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(AllowTrustResultCode::AllowTrustSuccess),
            -1 => Ok(AllowTrustResultCode::AllowTrustMalformed),
            -2 => Ok(AllowTrustResultCode::AllowTrustNoTrustLine),
            -3 => Ok(AllowTrustResultCode::AllowTrustTrustNotRequired),
            -4 => Ok(AllowTrustResultCode::AllowTrustCantRevoke),
            -5 => Ok(AllowTrustResultCode::AllowTrustSelfNotAllowed),
            -6 => Ok(AllowTrustResultCode::AllowTrustLowReserve),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type AccountMergeResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum AccountMergeResultCode {
    AccountMergeSuccess = 0,
    AccountMergeMalformed = -1,
    AccountMergeNoAccount = -2,
    AccountMergeImmutableSet = -3,
    AccountMergeHasSubEntries = -4,
    AccountMergeSeqnumTooFar = -5,
    AccountMergeDestFull = -6,
    AccountMergeIsSponsor = -7,
}

impl XdrCodec for AccountMergeResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(AccountMergeResultCode::AccountMergeSuccess),
            -1 => Ok(AccountMergeResultCode::AccountMergeMalformed),
            -2 => Ok(AccountMergeResultCode::AccountMergeNoAccount),
            -3 => Ok(AccountMergeResultCode::AccountMergeImmutableSet),
            -4 => Ok(AccountMergeResultCode::AccountMergeHasSubEntries),
            -5 => Ok(AccountMergeResultCode::AccountMergeSeqnumTooFar),
            -6 => Ok(AccountMergeResultCode::AccountMergeDestFull),
            -7 => Ok(AccountMergeResultCode::AccountMergeIsSponsor),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type InflationResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum InflationResultCode {
    InflationSuccess = 0,
    InflationNotTime = -1,
}

impl XdrCodec for InflationResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(InflationResultCode::InflationSuccess),
            -1 => Ok(InflationResultCode::InflationNotTime),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type InflationPayout
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct InflationPayout {
    pub destination: AccountId,
    pub amount: Int64,
}

impl XdrCodec for InflationPayout {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.destination.to_xdr_buffered(write_stream);
        self.amount.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(InflationPayout {
            destination: AccountId::from_xdr_buffered(read_stream)?,
            amount: Int64::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type ManageDataResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ManageDataResultCode {
    ManageDataSuccess = 0,
    ManageDataNotSupportedYet = -1,
    ManageDataNameNotFound = -2,
    ManageDataLowReserve = -3,
    ManageDataInvalidName = -4,
}

impl XdrCodec for ManageDataResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ManageDataResultCode::ManageDataSuccess),
            -1 => Ok(ManageDataResultCode::ManageDataNotSupportedYet),
            -2 => Ok(ManageDataResultCode::ManageDataNameNotFound),
            -3 => Ok(ManageDataResultCode::ManageDataLowReserve),
            -4 => Ok(ManageDataResultCode::ManageDataInvalidName),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type BumpSequenceResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum BumpSequenceResultCode {
    BumpSequenceSuccess = 0,
    BumpSequenceBadSeq = -1,
}

impl XdrCodec for BumpSequenceResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(BumpSequenceResultCode::BumpSequenceSuccess),
            -1 => Ok(BumpSequenceResultCode::BumpSequenceBadSeq),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type CreateClaimableBalanceResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum CreateClaimableBalanceResultCode {
    CreateClaimableBalanceSuccess = 0,
    CreateClaimableBalanceMalformed = -1,
    CreateClaimableBalanceLowReserve = -2,
    CreateClaimableBalanceNoTrust = -3,
    CreateClaimableBalanceNotAuthorized = -4,
    CreateClaimableBalanceUnderfunded = -5,
}

impl XdrCodec for CreateClaimableBalanceResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(CreateClaimableBalanceResultCode::CreateClaimableBalanceSuccess),
            -1 => Ok(CreateClaimableBalanceResultCode::CreateClaimableBalanceMalformed),
            -2 => Ok(CreateClaimableBalanceResultCode::CreateClaimableBalanceLowReserve),
            -3 => Ok(CreateClaimableBalanceResultCode::CreateClaimableBalanceNoTrust),
            -4 => Ok(CreateClaimableBalanceResultCode::CreateClaimableBalanceNotAuthorized),
            -5 => Ok(CreateClaimableBalanceResultCode::CreateClaimableBalanceUnderfunded),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ClaimClaimableBalanceResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ClaimClaimableBalanceResultCode {
    ClaimClaimableBalanceSuccess = 0,
    ClaimClaimableBalanceDoesNotExist = -1,
    ClaimClaimableBalanceCannotClaim = -2,
    ClaimClaimableBalanceLineFull = -3,
    ClaimClaimableBalanceNoTrust = -4,
    ClaimClaimableBalanceNotAuthorized = -5,
}

impl XdrCodec for ClaimClaimableBalanceResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ClaimClaimableBalanceResultCode::ClaimClaimableBalanceSuccess),
            -1 => Ok(ClaimClaimableBalanceResultCode::ClaimClaimableBalanceDoesNotExist),
            -2 => Ok(ClaimClaimableBalanceResultCode::ClaimClaimableBalanceCannotClaim),
            -3 => Ok(ClaimClaimableBalanceResultCode::ClaimClaimableBalanceLineFull),
            -4 => Ok(ClaimClaimableBalanceResultCode::ClaimClaimableBalanceNoTrust),
            -5 => Ok(ClaimClaimableBalanceResultCode::ClaimClaimableBalanceNotAuthorized),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type BeginSponsoringFutureReservesResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum BeginSponsoringFutureReservesResultCode {
    BeginSponsoringFutureReservesSuccess = 0,
    BeginSponsoringFutureReservesMalformed = -1,
    BeginSponsoringFutureReservesAlreadySponsored = -2,
    BeginSponsoringFutureReservesRecursive = -3,
}

impl XdrCodec for BeginSponsoringFutureReservesResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesSuccess),
            -1 => Ok(BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesMalformed),
            -2 => Ok(BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesAlreadySponsored),
            -3 => Ok(BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesRecursive),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type EndSponsoringFutureReservesResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum EndSponsoringFutureReservesResultCode {
    EndSponsoringFutureReservesSuccess = 0,
    EndSponsoringFutureReservesNotSponsored = -1,
}

impl XdrCodec for EndSponsoringFutureReservesResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(EndSponsoringFutureReservesResultCode::EndSponsoringFutureReservesSuccess),
            -1 => Ok(EndSponsoringFutureReservesResultCode::EndSponsoringFutureReservesNotSponsored),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type RevokeSponsorshipResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum RevokeSponsorshipResultCode {
    RevokeSponsorshipSuccess = 0,
    RevokeSponsorshipDoesNotExist = -1,
    RevokeSponsorshipNotSponsor = -2,
    RevokeSponsorshipLowReserve = -3,
    RevokeSponsorshipOnlyTransferable = -4,
    RevokeSponsorshipMalformed = -5,
}

impl XdrCodec for RevokeSponsorshipResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(RevokeSponsorshipResultCode::RevokeSponsorshipSuccess),
            -1 => Ok(RevokeSponsorshipResultCode::RevokeSponsorshipDoesNotExist),
            -2 => Ok(RevokeSponsorshipResultCode::RevokeSponsorshipNotSponsor),
            -3 => Ok(RevokeSponsorshipResultCode::RevokeSponsorshipLowReserve),
            -4 => Ok(RevokeSponsorshipResultCode::RevokeSponsorshipOnlyTransferable),
            -5 => Ok(RevokeSponsorshipResultCode::RevokeSponsorshipMalformed),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ClawbackResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ClawbackResultCode {
    ClawbackSuccess = 0,
    ClawbackMalformed = -1,
    ClawbackNotClawbackEnabled = -2,
    ClawbackNoTrust = -3,
    ClawbackUnderfunded = -4,
}

impl XdrCodec for ClawbackResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ClawbackResultCode::ClawbackSuccess),
            -1 => Ok(ClawbackResultCode::ClawbackMalformed),
            -2 => Ok(ClawbackResultCode::ClawbackNotClawbackEnabled),
            -3 => Ok(ClawbackResultCode::ClawbackNoTrust),
            -4 => Ok(ClawbackResultCode::ClawbackUnderfunded),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ClawbackClaimableBalanceResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ClawbackClaimableBalanceResultCode {
    ClawbackClaimableBalanceSuccess = 0,
    ClawbackClaimableBalanceDoesNotExist = -1,
    ClawbackClaimableBalanceNotIssuer = -2,
    ClawbackClaimableBalanceNotClawbackEnabled = -3,
}

impl XdrCodec for ClawbackClaimableBalanceResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceSuccess),
            -1 => Ok(ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceDoesNotExist),
            -2 => Ok(ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceNotIssuer),
            -3 => Ok(ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceNotClawbackEnabled),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type SetTrustLineFlagsResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum SetTrustLineFlagsResultCode {
    SetTrustLineFlagsSuccess = 0,
    SetTrustLineFlagsMalformed = -1,
    SetTrustLineFlagsNoTrustLine = -2,
    SetTrustLineFlagsCantRevoke = -3,
    SetTrustLineFlagsInvalidState = -4,
    SetTrustLineFlagsLowReserve = -5,
}

impl XdrCodec for SetTrustLineFlagsResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(SetTrustLineFlagsResultCode::SetTrustLineFlagsSuccess),
            -1 => Ok(SetTrustLineFlagsResultCode::SetTrustLineFlagsMalformed),
            -2 => Ok(SetTrustLineFlagsResultCode::SetTrustLineFlagsNoTrustLine),
            -3 => Ok(SetTrustLineFlagsResultCode::SetTrustLineFlagsCantRevoke),
            -4 => Ok(SetTrustLineFlagsResultCode::SetTrustLineFlagsInvalidState),
            -5 => Ok(SetTrustLineFlagsResultCode::SetTrustLineFlagsLowReserve),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type LiquidityPoolDepositResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum LiquidityPoolDepositResultCode {
    LiquidityPoolDepositSuccess = 0,
    LiquidityPoolDepositMalformed = -1,
    LiquidityPoolDepositNoTrust = -2,
    LiquidityPoolDepositNotAuthorized = -3,
    LiquidityPoolDepositUnderfunded = -4,
    LiquidityPoolDepositLineFull = -5,
    LiquidityPoolDepositBadPrice = -6,
    LiquidityPoolDepositPoolFull = -7,
}

impl XdrCodec for LiquidityPoolDepositResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(LiquidityPoolDepositResultCode::LiquidityPoolDepositSuccess),
            -1 => Ok(LiquidityPoolDepositResultCode::LiquidityPoolDepositMalformed),
            -2 => Ok(LiquidityPoolDepositResultCode::LiquidityPoolDepositNoTrust),
            -3 => Ok(LiquidityPoolDepositResultCode::LiquidityPoolDepositNotAuthorized),
            -4 => Ok(LiquidityPoolDepositResultCode::LiquidityPoolDepositUnderfunded),
            -5 => Ok(LiquidityPoolDepositResultCode::LiquidityPoolDepositLineFull),
            -6 => Ok(LiquidityPoolDepositResultCode::LiquidityPoolDepositBadPrice),
            -7 => Ok(LiquidityPoolDepositResultCode::LiquidityPoolDepositPoolFull),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type LiquidityPoolWithdrawResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum LiquidityPoolWithdrawResultCode {
    LiquidityPoolWithdrawSuccess = 0,
    LiquidityPoolWithdrawMalformed = -1,
    LiquidityPoolWithdrawNoTrust = -2,
    LiquidityPoolWithdrawUnderfunded = -3,
    LiquidityPoolWithdrawLineFull = -4,
    LiquidityPoolWithdrawUnderMinimum = -5,
}

impl XdrCodec for LiquidityPoolWithdrawResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawSuccess),
            -1 => Ok(LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawMalformed),
            -2 => Ok(LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawNoTrust),
            -3 => Ok(LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawUnderfunded),
            -4 => Ok(LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawLineFull),
            -5 => Ok(LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawUnderMinimum),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type InvokeHostFunctionResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum InvokeHostFunctionResultCode {
    InvokeHostFunctionSuccess = 0,
    InvokeHostFunctionMalformed = -1,
    InvokeHostFunctionTrapped = -2,
    InvokeHostFunctionResourceLimitExceeded = -3,
    InvokeHostFunctionEntryArchived = -4,
    InvokeHostFunctionInsufficientRefundableFee = -5,
}

impl XdrCodec for InvokeHostFunctionResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(InvokeHostFunctionResultCode::InvokeHostFunctionSuccess),
            -1 => Ok(InvokeHostFunctionResultCode::InvokeHostFunctionMalformed),
            -2 => Ok(InvokeHostFunctionResultCode::InvokeHostFunctionTrapped),
            -3 => Ok(InvokeHostFunctionResultCode::InvokeHostFunctionResourceLimitExceeded),
            -4 => Ok(InvokeHostFunctionResultCode::InvokeHostFunctionEntryArchived),
            -5 => Ok(InvokeHostFunctionResultCode::InvokeHostFunctionInsufficientRefundableFee),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type ExtendFootprintTtlResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum ExtendFootprintTtlResultCode {
    ExtendFootprintTtlSuccess = 0,
    ExtendFootprintTtlMalformed = -1,
    ExtendFootprintTtlResourceLimitExceeded = -2,
    ExtendFootprintTtlInsufficientRefundableFee = -3,
}

impl XdrCodec for ExtendFootprintTtlResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(ExtendFootprintTtlResultCode::ExtendFootprintTtlSuccess),
            -1 => Ok(ExtendFootprintTtlResultCode::ExtendFootprintTtlMalformed),
            -2 => Ok(ExtendFootprintTtlResultCode::ExtendFootprintTtlResourceLimitExceeded),
            -3 => Ok(ExtendFootprintTtlResultCode::ExtendFootprintTtlInsufficientRefundableFee),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type RestoreFootprintResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum RestoreFootprintResultCode {
    RestoreFootprintSuccess = 0,
    RestoreFootprintMalformed = -1,
    RestoreFootprintResourceLimitExceeded = -2,
    RestoreFootprintInsufficientRefundableFee = -3,
}

impl XdrCodec for RestoreFootprintResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(RestoreFootprintResultCode::RestoreFootprintSuccess),
            -1 => Ok(RestoreFootprintResultCode::RestoreFootprintMalformed),
            -2 => Ok(RestoreFootprintResultCode::RestoreFootprintResourceLimitExceeded),
            -3 => Ok(RestoreFootprintResultCode::RestoreFootprintInsufficientRefundableFee),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type OperationResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum OperationResultCode {
    OpInner = 0,
    OpBadAuth = -1,
    OpNoAccount = -2,
    OpNotSupported = -3,
    OpTooManySubentries = -4,
    OpExceededWorkLimit = -5,
    OpTooManySponsoring = -6,
}

impl XdrCodec for OperationResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(OperationResultCode::OpInner),
            -1 => Ok(OperationResultCode::OpBadAuth),
            -2 => Ok(OperationResultCode::OpNoAccount),
            -3 => Ok(OperationResultCode::OpNotSupported),
            -4 => Ok(OperationResultCode::OpTooManySubentries),
            -5 => Ok(OperationResultCode::OpExceededWorkLimit),
            -6 => Ok(OperationResultCode::OpTooManySponsoring),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type TransactionResultCode
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum TransactionResultCode {
    TxFeeBumpInnerSuccess = 1,
    TxSuccess = 0,
    TxFailed = -1,
    TxTooEarly = -2,
    TxTooLate = -3,
    TxMissingOperation = -4,
    TxBadSeq = -5,
    TxBadAuth = -6,
    TxInsufficientBalance = -7,
    TxNoAccount = -8,
    TxInsufficientFee = -9,
    TxBadAuthExtra = -10,
    TxInternalError = -11,
    TxNotSupported = -12,
    TxFeeBumpInnerFailed = -13,
    TxBadSponsorship = -14,
    TxBadMinSeqAgeOrGap = -15,
    TxMalformed = -16,
    TxSorobanInvalid = -17,
}

impl XdrCodec for TransactionResultCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            1 => Ok(TransactionResultCode::TxFeeBumpInnerSuccess),
            0 => Ok(TransactionResultCode::TxSuccess),
            -1 => Ok(TransactionResultCode::TxFailed),
            -2 => Ok(TransactionResultCode::TxTooEarly),
            -3 => Ok(TransactionResultCode::TxTooLate),
            -4 => Ok(TransactionResultCode::TxMissingOperation),
            -5 => Ok(TransactionResultCode::TxBadSeq),
            -6 => Ok(TransactionResultCode::TxBadAuth),
            -7 => Ok(TransactionResultCode::TxInsufficientBalance),
            -8 => Ok(TransactionResultCode::TxNoAccount),
            -9 => Ok(TransactionResultCode::TxInsufficientFee),
            -10 => Ok(TransactionResultCode::TxBadAuthExtra),
            -11 => Ok(TransactionResultCode::TxInternalError),
            -12 => Ok(TransactionResultCode::TxNotSupported),
            -13 => Ok(TransactionResultCode::TxFeeBumpInnerFailed),
            -14 => Ok(TransactionResultCode::TxBadSponsorship),
            -15 => Ok(TransactionResultCode::TxBadMinSeqAgeOrGap),
            -16 => Ok(TransactionResultCode::TxMalformed),
            -17 => Ok(TransactionResultCode::TxSorobanInvalid),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type InnerTransactionResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct InnerTransactionResult {
    pub fee_charged: Int64,
    pub result: InnerTransactionResultResult,
    pub ext: InnerTransactionResultExt,
}

impl XdrCodec for InnerTransactionResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.fee_charged.to_xdr_buffered(write_stream);
        self.result.to_xdr_buffered(write_stream);
        self.ext.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(InnerTransactionResult {
            fee_charged: Int64::from_xdr_buffered(read_stream)?,
            result: InnerTransactionResultResult::from_xdr_buffered(read_stream)?,
            ext: InnerTransactionResultExt::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type InnerTransactionResultPair
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct InnerTransactionResultPair {
    pub transaction_hash: Hash,
    pub result: InnerTransactionResult,
}

impl XdrCodec for InnerTransactionResultPair {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.transaction_hash.to_xdr_buffered(write_stream);
        self.result.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(InnerTransactionResultPair {
            transaction_hash: Hash::from_xdr_buffered(read_stream)?,
            result: InnerTransactionResult::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type TransactionResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct TransactionResult {
    pub fee_charged: Int64,
    pub result: TransactionResultResult,
    pub ext: TransactionResultExt,
}

impl XdrCodec for TransactionResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.fee_charged.to_xdr_buffered(write_stream);
        self.result.to_xdr_buffered(write_stream);
        self.ext.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(TransactionResult {
            fee_charged: Int64::from_xdr_buffered(read_stream)?,
            result: TransactionResultResult::from_xdr_buffered(read_stream)?,
            ext: TransactionResultExt::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type Hash
#[allow(dead_code)]
pub type Hash = [u8; 32];

/// Autogenerated definition for type Uint256
#[allow(dead_code)]
pub type Uint256 = [u8; 32];

/// Autogenerated definition for type Uint32
#[allow(dead_code)]
pub type Uint32 = u32;

/// Autogenerated definition for type Int32
#[allow(dead_code)]
pub type Int32 = i32;

/// Autogenerated definition for type Uint64
#[allow(dead_code)]
pub type Uint64 = u64;

/// Autogenerated definition for type Int64
#[allow(dead_code)]
pub type Int64 = i64;

/// Autogenerated definition for type TimePoint
#[allow(dead_code)]
pub type TimePoint = Uint64;

/// Autogenerated definition for type Duration
#[allow(dead_code)]
pub type Duration = Uint64;

/// Autogenerated definition for type CryptoKeyType
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum CryptoKeyType {
    KeyTypeEd25519 = 0,
    KeyTypePreAuthTx = 1,
    KeyTypeHashX = 2,
    KeyTypeEd25519SignedPayload = 3,
    KeyTypeMuxedEd25519 = 256,
}

impl XdrCodec for CryptoKeyType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(CryptoKeyType::KeyTypeEd25519),
            1 => Ok(CryptoKeyType::KeyTypePreAuthTx),
            2 => Ok(CryptoKeyType::KeyTypeHashX),
            3 => Ok(CryptoKeyType::KeyTypeEd25519SignedPayload),
            256 => Ok(CryptoKeyType::KeyTypeMuxedEd25519),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type PublicKeyType
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum PublicKeyType {
    PublicKeyTypeEd25519 = 0,
}

impl XdrCodec for PublicKeyType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(PublicKeyType::PublicKeyTypeEd25519),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type SignerKeyType
#[allow(dead_code)]
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum SignerKeyType {
    SignerKeyTypeEd25519 = 0,
    SignerKeyTypePreAuthTx = 1,
    SignerKeyTypeHashX = 2,
    SignerKeyTypeEd25519SignedPayload = 3,
}

impl XdrCodec for SignerKeyType {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        let value = *self as i32;
        value.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        let enum_value = i32::from_xdr_buffered(read_stream)?;
        match enum_value {
            0 => Ok(SignerKeyType::SignerKeyTypeEd25519),
            1 => Ok(SignerKeyType::SignerKeyTypePreAuthTx),
            2 => Ok(SignerKeyType::SignerKeyTypeHashX),
            3 => Ok(SignerKeyType::SignerKeyTypeEd25519SignedPayload),
            _ => Err(DecodeError::InvalidEnumDiscriminator { at_position: read_stream.get_position() }),
        }
    }
}

/// Autogenerated definition for type SignerKeyEd25519SignedPayload
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct SignerKeyEd25519SignedPayload {
    pub ed25519: Uint256,
    pub payload: LimitedVarOpaque<64>,
}

impl XdrCodec for SignerKeyEd25519SignedPayload {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.ed25519.to_xdr_buffered(write_stream);
        self.payload.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(SignerKeyEd25519SignedPayload {
            ed25519: Uint256::from_xdr_buffered(read_stream)?,
            payload: LimitedVarOpaque::<64>::from_xdr_buffered(read_stream)?,
        })
    }
}

/// Autogenerated definition for type Signature
#[allow(dead_code)]
pub type Signature = LimitedVarOpaque<64>;

/// Autogenerated definition for type SignatureHint
#[allow(dead_code)]
pub type SignatureHint = [u8; 4];

/// Autogenerated definition for type NodeId
#[allow(dead_code)]
#[cfg(feature = "all-types")]
pub type NodeId = PublicKey;

/// Autogenerated definition for type AccountId
#[allow(dead_code)]
pub type AccountId = PublicKey;

/// Autogenerated definition for type Curve25519Secret
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct Curve25519Secret {
    pub key: [u8; 32],
}

impl XdrCodec for Curve25519Secret {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.key.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(Curve25519Secret { key: <[u8; 32]>::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type Curve25519Public
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct Curve25519Public {
    pub key: [u8; 32],
}

#[cfg(feature = "all-types")]
impl XdrCodec for Curve25519Public {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.key.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(Curve25519Public { key: <[u8; 32]>::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type HmacSha256Key
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct HmacSha256Key {
    pub key: [u8; 32],
}

#[cfg(feature = "all-types")]
impl XdrCodec for HmacSha256Key {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.key.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(HmacSha256Key { key: <[u8; 32]>::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type HmacSha256Mac
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct HmacSha256Mac {
    pub mac: [u8; 32],
}

#[cfg(feature = "all-types")]
impl XdrCodec for HmacSha256Mac {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        self.mac.to_xdr_buffered(write_stream);
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        Ok(HmacSha256Mac { mac: <[u8; 32]>::from_xdr_buffered(read_stream)? })
    }
}

/// Autogenerated definition for type ScpStatementPledges
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ScpStatementPledges {
    ScpStPrepare(ScpStatementPrepare),
    ScpStConfirm(ScpStatementConfirm),
    ScpStExternalize(ScpStatementExternalize),
    ScpStNominate(ScpNomination),
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScpStatementPledges {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ScpStatementPledges::ScpStPrepare(value) => {
                ScpStatementType::ScpStPrepare.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScpStatementPledges::ScpStConfirm(value) => {
                ScpStatementType::ScpStConfirm.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScpStatementPledges::ScpStExternalize(value) => {
                ScpStatementType::ScpStExternalize.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScpStatementPledges::ScpStNominate(value) => {
                ScpStatementType::ScpStNominate.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match ScpStatementType::from_xdr_buffered(read_stream)? {
            ScpStatementType::ScpStPrepare =>
                Ok(ScpStatementPledges::ScpStPrepare(ScpStatementPrepare::from_xdr_buffered(read_stream)?)),
            ScpStatementType::ScpStConfirm =>
                Ok(ScpStatementPledges::ScpStConfirm(ScpStatementConfirm::from_xdr_buffered(read_stream)?)),
            ScpStatementType::ScpStExternalize =>
                Ok(ScpStatementPledges::ScpStExternalize(ScpStatementExternalize::from_xdr_buffered(read_stream)?)),
            ScpStatementType::ScpStNominate =>
                Ok(ScpStatementPledges::ScpStNominate(ScpNomination::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type ConfigSettingEntry
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ConfigSettingEntry {
    ConfigSettingContractMaxSizeBytes(Uint32),
    ConfigSettingContractComputeV0(ConfigSettingContractComputeV0),
    ConfigSettingContractLedgerCostV0(ConfigSettingContractLedgerCostV0),
    ConfigSettingContractHistoricalDataV0(ConfigSettingContractHistoricalDataV0),
    ConfigSettingContractEventsV0(ConfigSettingContractEventsV0),
    ConfigSettingContractBandwidthV0(ConfigSettingContractBandwidthV0),
    ConfigSettingContractCostParamsCpuInstructions(ContractCostParams),
    ConfigSettingContractCostParamsMemoryBytes(ContractCostParams),
    ConfigSettingContractDataKeySizeBytes(Uint32),
    ConfigSettingContractDataEntrySizeBytes(Uint32),
    ConfigSettingStateArchival(StateArchivalSettings),
    ConfigSettingContractExecutionLanes(ConfigSettingContractExecutionLanesV0),
    ConfigSettingBucketlistSizeWindow(UnlimitedVarArray<Uint64>),
    ConfigSettingEvictionIterator(EvictionIterator),
}

impl XdrCodec for ConfigSettingEntry {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ConfigSettingEntry::ConfigSettingContractMaxSizeBytes(value) => {
                ConfigSettingId::ConfigSettingContractMaxSizeBytes.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ConfigSettingEntry::ConfigSettingContractComputeV0(value) => {
                ConfigSettingId::ConfigSettingContractComputeV0.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ConfigSettingEntry::ConfigSettingContractLedgerCostV0(value) => {
                ConfigSettingId::ConfigSettingContractLedgerCostV0.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ConfigSettingEntry::ConfigSettingContractHistoricalDataV0(value) => {
                ConfigSettingId::ConfigSettingContractHistoricalDataV0.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ConfigSettingEntry::ConfigSettingContractEventsV0(value) => {
                ConfigSettingId::ConfigSettingContractEventsV0.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ConfigSettingEntry::ConfigSettingContractBandwidthV0(value) => {
                ConfigSettingId::ConfigSettingContractBandwidthV0.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ConfigSettingEntry::ConfigSettingContractCostParamsCpuInstructions(value) => {
                ConfigSettingId::ConfigSettingContractCostParamsCpuInstructions.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ConfigSettingEntry::ConfigSettingContractCostParamsMemoryBytes(value) => {
                ConfigSettingId::ConfigSettingContractCostParamsMemoryBytes.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ConfigSettingEntry::ConfigSettingContractDataKeySizeBytes(value) => {
                ConfigSettingId::ConfigSettingContractDataKeySizeBytes.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ConfigSettingEntry::ConfigSettingContractDataEntrySizeBytes(value) => {
                ConfigSettingId::ConfigSettingContractDataEntrySizeBytes.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ConfigSettingEntry::ConfigSettingStateArchival(value) => {
                ConfigSettingId::ConfigSettingStateArchival.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ConfigSettingEntry::ConfigSettingContractExecutionLanes(value) => {
                ConfigSettingId::ConfigSettingContractExecutionLanes.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ConfigSettingEntry::ConfigSettingBucketlistSizeWindow(value) => {
                ConfigSettingId::ConfigSettingBucketlistSizeWindow.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ConfigSettingEntry::ConfigSettingEvictionIterator(value) => {
                ConfigSettingId::ConfigSettingEvictionIterator.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match ConfigSettingId::from_xdr_buffered(read_stream)? {
            ConfigSettingId::ConfigSettingContractMaxSizeBytes =>
                Ok(ConfigSettingEntry::ConfigSettingContractMaxSizeBytes(Uint32::from_xdr_buffered(read_stream)?)),
            ConfigSettingId::ConfigSettingContractComputeV0 => Ok(ConfigSettingEntry::ConfigSettingContractComputeV0(
                ConfigSettingContractComputeV0::from_xdr_buffered(read_stream)?,
            )),
            ConfigSettingId::ConfigSettingContractLedgerCostV0 =>
                Ok(ConfigSettingEntry::ConfigSettingContractLedgerCostV0(
                    ConfigSettingContractLedgerCostV0::from_xdr_buffered(read_stream)?,
                )),
            ConfigSettingId::ConfigSettingContractHistoricalDataV0 =>
                Ok(ConfigSettingEntry::ConfigSettingContractHistoricalDataV0(
                    ConfigSettingContractHistoricalDataV0::from_xdr_buffered(read_stream)?,
                )),
            ConfigSettingId::ConfigSettingContractEventsV0 => Ok(ConfigSettingEntry::ConfigSettingContractEventsV0(
                ConfigSettingContractEventsV0::from_xdr_buffered(read_stream)?,
            )),
            ConfigSettingId::ConfigSettingContractBandwidthV0 =>
                Ok(ConfigSettingEntry::ConfigSettingContractBandwidthV0(
                    ConfigSettingContractBandwidthV0::from_xdr_buffered(read_stream)?,
                )),
            ConfigSettingId::ConfigSettingContractCostParamsCpuInstructions =>
                Ok(ConfigSettingEntry::ConfigSettingContractCostParamsCpuInstructions(
                    ContractCostParams::from_xdr_buffered(read_stream)?,
                )),
            ConfigSettingId::ConfigSettingContractCostParamsMemoryBytes =>
                Ok(ConfigSettingEntry::ConfigSettingContractCostParamsMemoryBytes(
                    ContractCostParams::from_xdr_buffered(read_stream)?,
                )),
            ConfigSettingId::ConfigSettingContractDataKeySizeBytes =>
                Ok(ConfigSettingEntry::ConfigSettingContractDataKeySizeBytes(Uint32::from_xdr_buffered(read_stream)?)),
            ConfigSettingId::ConfigSettingContractDataEntrySizeBytes =>
                Ok(ConfigSettingEntry::ConfigSettingContractDataEntrySizeBytes(Uint32::from_xdr_buffered(read_stream)?)),
            ConfigSettingId::ConfigSettingStateArchival => Ok(ConfigSettingEntry::ConfigSettingStateArchival(
                StateArchivalSettings::from_xdr_buffered(read_stream)?,
            )),
            ConfigSettingId::ConfigSettingContractExecutionLanes =>
                Ok(ConfigSettingEntry::ConfigSettingContractExecutionLanes(
                    ConfigSettingContractExecutionLanesV0::from_xdr_buffered(read_stream)?,
                )),
            ConfigSettingId::ConfigSettingBucketlistSizeWindow =>
                Ok(ConfigSettingEntry::ConfigSettingBucketlistSizeWindow(
                    UnlimitedVarArray::<Uint64>::from_xdr_buffered(read_stream)?,
                )),
            ConfigSettingId::ConfigSettingEvictionIterator =>
                Ok(ConfigSettingEntry::ConfigSettingEvictionIterator(EvictionIterator::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type ScEnvMetaEntry
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ScEnvMetaEntry {
    ScEnvMetaKindInterfaceVersion(Uint64),
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScEnvMetaEntry {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ScEnvMetaEntry::ScEnvMetaKindInterfaceVersion(value) => {
                ScEnvMetaKind::ScEnvMetaKindInterfaceVersion.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match ScEnvMetaKind::from_xdr_buffered(read_stream)? {
            ScEnvMetaKind::ScEnvMetaKindInterfaceVersion =>
                Ok(ScEnvMetaEntry::ScEnvMetaKindInterfaceVersion(Uint64::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type ScMetaEntry
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ScMetaEntry {
    ScMetaV0(ScMetaV0),
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScMetaEntry {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ScMetaEntry::ScMetaV0(value) => {
                ScMetaKind::ScMetaV0.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match ScMetaKind::from_xdr_buffered(read_stream)? {
            ScMetaKind::ScMetaV0 => Ok(ScMetaEntry::ScMetaV0(ScMetaV0::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type ScSpecTypeDef
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ScSpecTypeDef {
    ScSpecTypeVal,
    ScSpecTypeBool,
    ScSpecTypeVoid,
    ScSpecTypeError,
    ScSpecTypeU32,
    ScSpecTypeI32,
    ScSpecTypeU64,
    ScSpecTypeI64,
    ScSpecTypeTimepoint,
    ScSpecTypeDuration,
    ScSpecTypeU128,
    ScSpecTypeI128,
    ScSpecTypeU256,
    ScSpecTypeI256,
    ScSpecTypeBytes,
    ScSpecTypeString,
    ScSpecTypeSymbol,
    ScSpecTypeAddress,
    ScSpecTypeOption(Box<ScSpecTypeOption>),
    ScSpecTypeResult(Box<ScSpecTypeResult>),
    ScSpecTypeVec(Box<ScSpecTypeVec>),
    ScSpecTypeMap(Box<ScSpecTypeMap>),
    ScSpecTypeTuple(Box<ScSpecTypeTuple>),
    ScSpecTypeBytesN(Box<ScSpecTypeBytesN>),
    ScSpecTypeUdt(Box<ScSpecTypeUdt>),
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScSpecTypeDef {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ScSpecTypeDef::ScSpecTypeVal => ScSpecType::ScSpecTypeVal.to_xdr_buffered(write_stream),
            ScSpecTypeDef::ScSpecTypeBool => ScSpecType::ScSpecTypeBool.to_xdr_buffered(write_stream),
            ScSpecTypeDef::ScSpecTypeVoid => ScSpecType::ScSpecTypeVoid.to_xdr_buffered(write_stream),
            ScSpecTypeDef::ScSpecTypeError => ScSpecType::ScSpecTypeError.to_xdr_buffered(write_stream),
            ScSpecTypeDef::ScSpecTypeU32 => ScSpecType::ScSpecTypeU32.to_xdr_buffered(write_stream),
            ScSpecTypeDef::ScSpecTypeI32 => ScSpecType::ScSpecTypeI32.to_xdr_buffered(write_stream),
            ScSpecTypeDef::ScSpecTypeU64 => ScSpecType::ScSpecTypeU64.to_xdr_buffered(write_stream),
            ScSpecTypeDef::ScSpecTypeI64 => ScSpecType::ScSpecTypeI64.to_xdr_buffered(write_stream),
            ScSpecTypeDef::ScSpecTypeTimepoint => ScSpecType::ScSpecTypeTimepoint.to_xdr_buffered(write_stream),
            ScSpecTypeDef::ScSpecTypeDuration => ScSpecType::ScSpecTypeDuration.to_xdr_buffered(write_stream),
            ScSpecTypeDef::ScSpecTypeU128 => ScSpecType::ScSpecTypeU128.to_xdr_buffered(write_stream),
            ScSpecTypeDef::ScSpecTypeI128 => ScSpecType::ScSpecTypeI128.to_xdr_buffered(write_stream),
            ScSpecTypeDef::ScSpecTypeU256 => ScSpecType::ScSpecTypeU256.to_xdr_buffered(write_stream),
            ScSpecTypeDef::ScSpecTypeI256 => ScSpecType::ScSpecTypeI256.to_xdr_buffered(write_stream),
            ScSpecTypeDef::ScSpecTypeBytes => ScSpecType::ScSpecTypeBytes.to_xdr_buffered(write_stream),
            ScSpecTypeDef::ScSpecTypeString => ScSpecType::ScSpecTypeString.to_xdr_buffered(write_stream),
            ScSpecTypeDef::ScSpecTypeSymbol => ScSpecType::ScSpecTypeSymbol.to_xdr_buffered(write_stream),
            ScSpecTypeDef::ScSpecTypeAddress => ScSpecType::ScSpecTypeAddress.to_xdr_buffered(write_stream),
            ScSpecTypeDef::ScSpecTypeOption(value) => {
                ScSpecType::ScSpecTypeOption.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScSpecTypeDef::ScSpecTypeResult(value) => {
                ScSpecType::ScSpecTypeResult.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScSpecTypeDef::ScSpecTypeVec(value) => {
                ScSpecType::ScSpecTypeVec.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScSpecTypeDef::ScSpecTypeMap(value) => {
                ScSpecType::ScSpecTypeMap.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScSpecTypeDef::ScSpecTypeTuple(value) => {
                ScSpecType::ScSpecTypeTuple.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScSpecTypeDef::ScSpecTypeBytesN(value) => {
                ScSpecType::ScSpecTypeBytesN.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScSpecTypeDef::ScSpecTypeUdt(value) => {
                ScSpecType::ScSpecTypeUdt.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match ScSpecType::from_xdr_buffered(read_stream)? {
            ScSpecType::ScSpecTypeVal => Ok(ScSpecTypeDef::ScSpecTypeVal),
            ScSpecType::ScSpecTypeBool => Ok(ScSpecTypeDef::ScSpecTypeBool),
            ScSpecType::ScSpecTypeVoid => Ok(ScSpecTypeDef::ScSpecTypeVoid),
            ScSpecType::ScSpecTypeError => Ok(ScSpecTypeDef::ScSpecTypeError),
            ScSpecType::ScSpecTypeU32 => Ok(ScSpecTypeDef::ScSpecTypeU32),
            ScSpecType::ScSpecTypeI32 => Ok(ScSpecTypeDef::ScSpecTypeI32),
            ScSpecType::ScSpecTypeU64 => Ok(ScSpecTypeDef::ScSpecTypeU64),
            ScSpecType::ScSpecTypeI64 => Ok(ScSpecTypeDef::ScSpecTypeI64),
            ScSpecType::ScSpecTypeTimepoint => Ok(ScSpecTypeDef::ScSpecTypeTimepoint),
            ScSpecType::ScSpecTypeDuration => Ok(ScSpecTypeDef::ScSpecTypeDuration),
            ScSpecType::ScSpecTypeU128 => Ok(ScSpecTypeDef::ScSpecTypeU128),
            ScSpecType::ScSpecTypeI128 => Ok(ScSpecTypeDef::ScSpecTypeI128),
            ScSpecType::ScSpecTypeU256 => Ok(ScSpecTypeDef::ScSpecTypeU256),
            ScSpecType::ScSpecTypeI256 => Ok(ScSpecTypeDef::ScSpecTypeI256),
            ScSpecType::ScSpecTypeBytes => Ok(ScSpecTypeDef::ScSpecTypeBytes),
            ScSpecType::ScSpecTypeString => Ok(ScSpecTypeDef::ScSpecTypeString),
            ScSpecType::ScSpecTypeSymbol => Ok(ScSpecTypeDef::ScSpecTypeSymbol),
            ScSpecType::ScSpecTypeAddress => Ok(ScSpecTypeDef::ScSpecTypeAddress),
            ScSpecType::ScSpecTypeOption =>
                Ok(ScSpecTypeDef::ScSpecTypeOption(Box::new(ScSpecTypeOption::from_xdr_buffered(read_stream)?))),
            ScSpecType::ScSpecTypeResult =>
                Ok(ScSpecTypeDef::ScSpecTypeResult(Box::new(ScSpecTypeResult::from_xdr_buffered(read_stream)?))),
            ScSpecType::ScSpecTypeVec =>
                Ok(ScSpecTypeDef::ScSpecTypeVec(Box::new(ScSpecTypeVec::from_xdr_buffered(read_stream)?))),
            ScSpecType::ScSpecTypeMap =>
                Ok(ScSpecTypeDef::ScSpecTypeMap(Box::new(ScSpecTypeMap::from_xdr_buffered(read_stream)?))),
            ScSpecType::ScSpecTypeTuple =>
                Ok(ScSpecTypeDef::ScSpecTypeTuple(Box::new(ScSpecTypeTuple::from_xdr_buffered(read_stream)?))),
            ScSpecType::ScSpecTypeBytesN =>
                Ok(ScSpecTypeDef::ScSpecTypeBytesN(Box::new(ScSpecTypeBytesN::from_xdr_buffered(read_stream)?))),
            ScSpecType::ScSpecTypeUdt =>
                Ok(ScSpecTypeDef::ScSpecTypeUdt(Box::new(ScSpecTypeUdt::from_xdr_buffered(read_stream)?))),
        }
    }
}

/// Autogenerated definition for type ScSpecUdtUnionCaseV0
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ScSpecUdtUnionCaseV0 {
    ScSpecUdtUnionCaseVoidV0(ScSpecUdtUnionCaseVoidV0),
    ScSpecUdtUnionCaseTupleV0(ScSpecUdtUnionCaseTupleV0),
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScSpecUdtUnionCaseV0 {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ScSpecUdtUnionCaseV0::ScSpecUdtUnionCaseVoidV0(value) => {
                ScSpecUdtUnionCaseV0Kind::ScSpecUdtUnionCaseVoidV0.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScSpecUdtUnionCaseV0::ScSpecUdtUnionCaseTupleV0(value) => {
                ScSpecUdtUnionCaseV0Kind::ScSpecUdtUnionCaseTupleV0.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match ScSpecUdtUnionCaseV0Kind::from_xdr_buffered(read_stream)? {
            ScSpecUdtUnionCaseV0Kind::ScSpecUdtUnionCaseVoidV0 => Ok(ScSpecUdtUnionCaseV0::ScSpecUdtUnionCaseVoidV0(
                ScSpecUdtUnionCaseVoidV0::from_xdr_buffered(read_stream)?,
            )),
            ScSpecUdtUnionCaseV0Kind::ScSpecUdtUnionCaseTupleV0 => Ok(ScSpecUdtUnionCaseV0::ScSpecUdtUnionCaseTupleV0(
                ScSpecUdtUnionCaseTupleV0::from_xdr_buffered(read_stream)?,
            )),
        }
    }
}

/// Autogenerated definition for type ScSpecEntry
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ScSpecEntry {
    ScSpecEntryFunctionV0(ScSpecFunctionV0),
    ScSpecEntryUdtStructV0(ScSpecUdtStructV0),
    ScSpecEntryUdtUnionV0(ScSpecUdtUnionV0),
    ScSpecEntryUdtEnumV0(ScSpecUdtEnumV0),
    ScSpecEntryUdtErrorEnumV0(ScSpecUdtErrorEnumV0),
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScSpecEntry {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ScSpecEntry::ScSpecEntryFunctionV0(value) => {
                ScSpecEntryKind::ScSpecEntryFunctionV0.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScSpecEntry::ScSpecEntryUdtStructV0(value) => {
                ScSpecEntryKind::ScSpecEntryUdtStructV0.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScSpecEntry::ScSpecEntryUdtUnionV0(value) => {
                ScSpecEntryKind::ScSpecEntryUdtUnionV0.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScSpecEntry::ScSpecEntryUdtEnumV0(value) => {
                ScSpecEntryKind::ScSpecEntryUdtEnumV0.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScSpecEntry::ScSpecEntryUdtErrorEnumV0(value) => {
                ScSpecEntryKind::ScSpecEntryUdtErrorEnumV0.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match ScSpecEntryKind::from_xdr_buffered(read_stream)? {
            ScSpecEntryKind::ScSpecEntryFunctionV0 =>
                Ok(ScSpecEntry::ScSpecEntryFunctionV0(ScSpecFunctionV0::from_xdr_buffered(read_stream)?)),
            ScSpecEntryKind::ScSpecEntryUdtStructV0 =>
                Ok(ScSpecEntry::ScSpecEntryUdtStructV0(ScSpecUdtStructV0::from_xdr_buffered(read_stream)?)),
            ScSpecEntryKind::ScSpecEntryUdtUnionV0 =>
                Ok(ScSpecEntry::ScSpecEntryUdtUnionV0(ScSpecUdtUnionV0::from_xdr_buffered(read_stream)?)),
            ScSpecEntryKind::ScSpecEntryUdtEnumV0 =>
                Ok(ScSpecEntry::ScSpecEntryUdtEnumV0(ScSpecUdtEnumV0::from_xdr_buffered(read_stream)?)),
            ScSpecEntryKind::ScSpecEntryUdtErrorEnumV0 =>
                Ok(ScSpecEntry::ScSpecEntryUdtErrorEnumV0(ScSpecUdtErrorEnumV0::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type ScError
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ScError {
    SceContract(Uint32),
    SceWasmVm(ScErrorCode),
    SceContext(ScErrorCode),
    SceStorage(ScErrorCode),
    SceObject(ScErrorCode),
    SceCrypto(ScErrorCode),
    SceEvents(ScErrorCode),
    SceBudget(ScErrorCode),
    SceValue(ScErrorCode),
    SceAuth(ScErrorCode),
}

impl XdrCodec for ScError {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ScError::SceContract(value) => {
                ScErrorType::SceContract.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScError::SceWasmVm(value) => {
                ScErrorType::SceWasmVm.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScError::SceContext(value) => {
                ScErrorType::SceContext.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScError::SceStorage(value) => {
                ScErrorType::SceStorage.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScError::SceObject(value) => {
                ScErrorType::SceObject.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScError::SceCrypto(value) => {
                ScErrorType::SceCrypto.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScError::SceEvents(value) => {
                ScErrorType::SceEvents.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScError::SceBudget(value) => {
                ScErrorType::SceBudget.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScError::SceValue(value) => {
                ScErrorType::SceValue.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScError::SceAuth(value) => {
                ScErrorType::SceAuth.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match ScErrorType::from_xdr_buffered(read_stream)? {
            ScErrorType::SceContract => Ok(ScError::SceContract(Uint32::from_xdr_buffered(read_stream)?)),
            ScErrorType::SceWasmVm => Ok(ScError::SceWasmVm(ScErrorCode::from_xdr_buffered(read_stream)?)),
            ScErrorType::SceContext => Ok(ScError::SceContext(ScErrorCode::from_xdr_buffered(read_stream)?)),
            ScErrorType::SceStorage => Ok(ScError::SceStorage(ScErrorCode::from_xdr_buffered(read_stream)?)),
            ScErrorType::SceObject => Ok(ScError::SceObject(ScErrorCode::from_xdr_buffered(read_stream)?)),
            ScErrorType::SceCrypto => Ok(ScError::SceCrypto(ScErrorCode::from_xdr_buffered(read_stream)?)),
            ScErrorType::SceEvents => Ok(ScError::SceEvents(ScErrorCode::from_xdr_buffered(read_stream)?)),
            ScErrorType::SceBudget => Ok(ScError::SceBudget(ScErrorCode::from_xdr_buffered(read_stream)?)),
            ScErrorType::SceValue => Ok(ScError::SceValue(ScErrorCode::from_xdr_buffered(read_stream)?)),
            ScErrorType::SceAuth => Ok(ScError::SceAuth(ScErrorCode::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type ContractExecutable
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ContractExecutable {
    ContractExecutableWasm(Hash),
    ContractExecutableStellarAsset,
}

impl XdrCodec for ContractExecutable {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ContractExecutable::ContractExecutableWasm(value) => {
                ContractExecutableType::ContractExecutableWasm.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ContractExecutable::ContractExecutableStellarAsset =>
                ContractExecutableType::ContractExecutableStellarAsset.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match ContractExecutableType::from_xdr_buffered(read_stream)? {
            ContractExecutableType::ContractExecutableWasm =>
                Ok(ContractExecutable::ContractExecutableWasm(Hash::from_xdr_buffered(read_stream)?)),
            ContractExecutableType::ContractExecutableStellarAsset =>
                Ok(ContractExecutable::ContractExecutableStellarAsset),
        }
    }
}

/// Autogenerated definition for type ScAddress
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ScAddress {
    ScAddressTypeAccount(AccountId),
    ScAddressTypeContract(Hash),
}

impl XdrCodec for ScAddress {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ScAddress::ScAddressTypeAccount(value) => {
                ScAddressType::ScAddressTypeAccount.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScAddress::ScAddressTypeContract(value) => {
                ScAddressType::ScAddressTypeContract.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match ScAddressType::from_xdr_buffered(read_stream)? {
            ScAddressType::ScAddressTypeAccount =>
                Ok(ScAddress::ScAddressTypeAccount(AccountId::from_xdr_buffered(read_stream)?)),
            ScAddressType::ScAddressTypeContract =>
                Ok(ScAddress::ScAddressTypeContract(Hash::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type ScVal
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ScVal {
    ScvBool(bool),
    ScvVoid,
    ScvError(ScError),
    ScvU32(Uint32),
    ScvI32(Int32),
    ScvU64(Uint64),
    ScvI64(Int64),
    ScvTimepoint(TimePoint),
    ScvDuration(Duration),
    ScvU128(UInt128Parts),
    ScvI128(Int128Parts),
    ScvU256(UInt256Parts),
    ScvI256(Int256Parts),
    ScvBytes(ScBytes),
    ScvString(ScString),
    ScvSymbol(ScSymbol),
    ScvVec(Option<ScVec>),
    ScvMap(Option<ScMap>),
    ScvAddress(ScAddress),
    ScvLedgerKeyContractInstance,
    ScvLedgerKeyNonce(ScNonceKey),
    ScvContractInstance(ScContractInstance),
}

impl XdrCodec for ScVal {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ScVal::ScvBool(value) => {
                ScValType::ScvBool.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScVal::ScvVoid => ScValType::ScvVoid.to_xdr_buffered(write_stream),
            ScVal::ScvError(value) => {
                ScValType::ScvError.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScVal::ScvU32(value) => {
                ScValType::ScvU32.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScVal::ScvI32(value) => {
                ScValType::ScvI32.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScVal::ScvU64(value) => {
                ScValType::ScvU64.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScVal::ScvI64(value) => {
                ScValType::ScvI64.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScVal::ScvTimepoint(value) => {
                ScValType::ScvTimepoint.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScVal::ScvDuration(value) => {
                ScValType::ScvDuration.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScVal::ScvU128(value) => {
                ScValType::ScvU128.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScVal::ScvI128(value) => {
                ScValType::ScvI128.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScVal::ScvU256(value) => {
                ScValType::ScvU256.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScVal::ScvI256(value) => {
                ScValType::ScvI256.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScVal::ScvBytes(value) => {
                ScValType::ScvBytes.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScVal::ScvString(value) => {
                ScValType::ScvString.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScVal::ScvSymbol(value) => {
                ScValType::ScvSymbol.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScVal::ScvVec(value) => {
                ScValType::ScvVec.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScVal::ScvMap(value) => {
                ScValType::ScvMap.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScVal::ScvAddress(value) => {
                ScValType::ScvAddress.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScVal::ScvLedgerKeyContractInstance =>
                ScValType::ScvLedgerKeyContractInstance.to_xdr_buffered(write_stream),
            ScVal::ScvLedgerKeyNonce(value) => {
                ScValType::ScvLedgerKeyNonce.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScVal::ScvContractInstance(value) => {
                ScValType::ScvContractInstance.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match ScValType::from_xdr_buffered(read_stream)? {
            ScValType::ScvBool => Ok(ScVal::ScvBool(bool::from_xdr_buffered(read_stream)?)),
            ScValType::ScvVoid => Ok(ScVal::ScvVoid),
            ScValType::ScvError => Ok(ScVal::ScvError(ScError::from_xdr_buffered(read_stream)?)),
            ScValType::ScvU32 => Ok(ScVal::ScvU32(Uint32::from_xdr_buffered(read_stream)?)),
            ScValType::ScvI32 => Ok(ScVal::ScvI32(Int32::from_xdr_buffered(read_stream)?)),
            ScValType::ScvU64 => Ok(ScVal::ScvU64(Uint64::from_xdr_buffered(read_stream)?)),
            ScValType::ScvI64 => Ok(ScVal::ScvI64(Int64::from_xdr_buffered(read_stream)?)),
            ScValType::ScvTimepoint => Ok(ScVal::ScvTimepoint(TimePoint::from_xdr_buffered(read_stream)?)),
            ScValType::ScvDuration => Ok(ScVal::ScvDuration(Duration::from_xdr_buffered(read_stream)?)),
            ScValType::ScvU128 => Ok(ScVal::ScvU128(UInt128Parts::from_xdr_buffered(read_stream)?)),
            ScValType::ScvI128 => Ok(ScVal::ScvI128(Int128Parts::from_xdr_buffered(read_stream)?)),
            ScValType::ScvU256 => Ok(ScVal::ScvU256(UInt256Parts::from_xdr_buffered(read_stream)?)),
            ScValType::ScvI256 => Ok(ScVal::ScvI256(Int256Parts::from_xdr_buffered(read_stream)?)),
            ScValType::ScvBytes => Ok(ScVal::ScvBytes(ScBytes::from_xdr_buffered(read_stream)?)),
            ScValType::ScvString => Ok(ScVal::ScvString(ScString::from_xdr_buffered(read_stream)?)),
            ScValType::ScvSymbol => Ok(ScVal::ScvSymbol(ScSymbol::from_xdr_buffered(read_stream)?)),
            ScValType::ScvVec => Ok(ScVal::ScvVec(Option::<ScVec>::from_xdr_buffered(read_stream)?)),
            ScValType::ScvMap => Ok(ScVal::ScvMap(Option::<ScMap>::from_xdr_buffered(read_stream)?)),
            ScValType::ScvAddress => Ok(ScVal::ScvAddress(ScAddress::from_xdr_buffered(read_stream)?)),
            ScValType::ScvLedgerKeyContractInstance => Ok(ScVal::ScvLedgerKeyContractInstance),
            ScValType::ScvLedgerKeyNonce => Ok(ScVal::ScvLedgerKeyNonce(ScNonceKey::from_xdr_buffered(read_stream)?)),
            ScValType::ScvContractInstance =>
                Ok(ScVal::ScvContractInstance(ScContractInstance::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type StoredTransactionSet
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum StoredTransactionSet {
    V0(TransactionSet),
    V1(GeneralizedTransactionSet),
    Default(i32),
}

#[cfg(feature = "all-types")]
impl XdrCodec for StoredTransactionSet {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            StoredTransactionSet::V0(value) => {
                (0 as i32).to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            StoredTransactionSet::V1(value) => {
                (1 as i32).to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            StoredTransactionSet::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(StoredTransactionSet::V0(TransactionSet::from_xdr_buffered(read_stream)?)),
            1 => Ok(StoredTransactionSet::V1(GeneralizedTransactionSet::from_xdr_buffered(read_stream)?)),
            code => Ok(StoredTransactionSet::Default(code)),
        }
    }
}

/// Autogenerated definition for type PersistedScpState
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum PersistedScpState {
    V0(PersistedScpStateV0),
    V1(PersistedScpStateV1),
    Default(i32),
}

#[cfg(feature = "all-types")]
impl XdrCodec for PersistedScpState {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            PersistedScpState::V0(value) => {
                (0 as i32).to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            PersistedScpState::V1(value) => {
                (1 as i32).to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            PersistedScpState::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(PersistedScpState::V0(PersistedScpStateV0::from_xdr_buffered(read_stream)?)),
            1 => Ok(PersistedScpState::V1(PersistedScpStateV1::from_xdr_buffered(read_stream)?)),
            code => Ok(PersistedScpState::Default(code)),
        }
    }
}

/// Autogenerated definition for type AssetCode
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum AssetCode {
    AssetTypeCreditAlphanum4(AssetCode4),
    AssetTypeCreditAlphanum12(AssetCode12),
    Default(AssetType),
}

impl XdrCodec for AssetCode {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            AssetCode::AssetTypeCreditAlphanum4(value) => {
                AssetType::AssetTypeCreditAlphanum4.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            AssetCode::AssetTypeCreditAlphanum12(value) => {
                AssetType::AssetTypeCreditAlphanum12.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            AssetCode::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match AssetType::from_xdr_buffered(read_stream)? {
            AssetType::AssetTypeCreditAlphanum4 =>
                Ok(AssetCode::AssetTypeCreditAlphanum4(AssetCode4::from_xdr_buffered(read_stream)?)),
            AssetType::AssetTypeCreditAlphanum12 =>
                Ok(AssetCode::AssetTypeCreditAlphanum12(AssetCode12::from_xdr_buffered(read_stream)?)),
            code => Ok(AssetCode::Default(code)),
        }
    }
}

/// Autogenerated definition for type Asset
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum Asset {
    AssetTypeNative,
    AssetTypeCreditAlphanum4(AlphaNum4),
    AssetTypeCreditAlphanum12(AlphaNum12),
    Default(AssetType),
}

impl XdrCodec for Asset {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            Asset::AssetTypeNative => AssetType::AssetTypeNative.to_xdr_buffered(write_stream),
            Asset::AssetTypeCreditAlphanum4(value) => {
                AssetType::AssetTypeCreditAlphanum4.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            Asset::AssetTypeCreditAlphanum12(value) => {
                AssetType::AssetTypeCreditAlphanum12.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            Asset::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match AssetType::from_xdr_buffered(read_stream)? {
            AssetType::AssetTypeNative => Ok(Asset::AssetTypeNative),
            AssetType::AssetTypeCreditAlphanum4 =>
                Ok(Asset::AssetTypeCreditAlphanum4(AlphaNum4::from_xdr_buffered(read_stream)?)),
            AssetType::AssetTypeCreditAlphanum12 =>
                Ok(Asset::AssetTypeCreditAlphanum12(AlphaNum12::from_xdr_buffered(read_stream)?)),
            code => Ok(Asset::Default(code)),
        }
    }
}

/// Autogenerated definition for type AccountEntryExtensionV2Ext
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum AccountEntryExtensionV2Ext {
    V0,
    V3(AccountEntryExtensionV3),
    Default(i32),
}

impl XdrCodec for AccountEntryExtensionV2Ext {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            AccountEntryExtensionV2Ext::V0 => (0 as i32).to_xdr_buffered(write_stream),
            AccountEntryExtensionV2Ext::V3(value) => {
                (3 as i32).to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            AccountEntryExtensionV2Ext::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(AccountEntryExtensionV2Ext::V0),
            3 => Ok(AccountEntryExtensionV2Ext::V3(AccountEntryExtensionV3::from_xdr_buffered(read_stream)?)),
            code => Ok(AccountEntryExtensionV2Ext::Default(code)),
        }
    }
}

/// Autogenerated definition for type AccountEntryExtensionV1Ext
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum AccountEntryExtensionV1Ext {
    V0,
    V2(AccountEntryExtensionV2),
    Default(i32),
}

impl XdrCodec for AccountEntryExtensionV1Ext {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            AccountEntryExtensionV1Ext::V0 => (0 as i32).to_xdr_buffered(write_stream),
            AccountEntryExtensionV1Ext::V2(value) => {
                (2 as i32).to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            AccountEntryExtensionV1Ext::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(AccountEntryExtensionV1Ext::V0),
            2 => Ok(AccountEntryExtensionV1Ext::V2(AccountEntryExtensionV2::from_xdr_buffered(read_stream)?)),
            code => Ok(AccountEntryExtensionV1Ext::Default(code)),
        }
    }
}

/// Autogenerated definition for type AccountEntryExt
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum AccountEntryExt {
    V0,
    V1(AccountEntryExtensionV1),
    Default(i32),
}

impl XdrCodec for AccountEntryExt {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            AccountEntryExt::V0 => (0 as i32).to_xdr_buffered(write_stream),
            AccountEntryExt::V1(value) => {
                (1 as i32).to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            AccountEntryExt::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(AccountEntryExt::V0),
            1 => Ok(AccountEntryExt::V1(AccountEntryExtensionV1::from_xdr_buffered(read_stream)?)),
            code => Ok(AccountEntryExt::Default(code)),
        }
    }
}

/// Autogenerated definition for type TrustLineAsset
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum TrustLineAsset {
    AssetTypeNative,
    AssetTypeCreditAlphanum4(AlphaNum4),
    AssetTypeCreditAlphanum12(AlphaNum12),
    AssetTypePoolShare(PoolId),
}

impl XdrCodec for TrustLineAsset {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            TrustLineAsset::AssetTypeNative => AssetType::AssetTypeNative.to_xdr_buffered(write_stream),
            TrustLineAsset::AssetTypeCreditAlphanum4(value) => {
                AssetType::AssetTypeCreditAlphanum4.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            TrustLineAsset::AssetTypeCreditAlphanum12(value) => {
                AssetType::AssetTypeCreditAlphanum12.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            TrustLineAsset::AssetTypePoolShare(value) => {
                AssetType::AssetTypePoolShare.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match AssetType::from_xdr_buffered(read_stream)? {
            AssetType::AssetTypeNative => Ok(TrustLineAsset::AssetTypeNative),
            AssetType::AssetTypeCreditAlphanum4 =>
                Ok(TrustLineAsset::AssetTypeCreditAlphanum4(AlphaNum4::from_xdr_buffered(read_stream)?)),
            AssetType::AssetTypeCreditAlphanum12 =>
                Ok(TrustLineAsset::AssetTypeCreditAlphanum12(AlphaNum12::from_xdr_buffered(read_stream)?)),
            AssetType::AssetTypePoolShare =>
                Ok(TrustLineAsset::AssetTypePoolShare(PoolId::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type TrustLineEntryExtensionV2Ext
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum TrustLineEntryExtensionV2Ext {
    V0,
    Default(i32),
}

impl XdrCodec for TrustLineEntryExtensionV2Ext {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            TrustLineEntryExtensionV2Ext::V0 => (0 as i32).to_xdr_buffered(write_stream),
            TrustLineEntryExtensionV2Ext::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(TrustLineEntryExtensionV2Ext::V0),
            code => Ok(TrustLineEntryExtensionV2Ext::Default(code)),
        }
    }
}

/// Autogenerated definition for type TrustLineEntryV1Ext
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum TrustLineEntryV1Ext {
    V0,
    V2(TrustLineEntryExtensionV2),
    Default(i32),
}

impl XdrCodec for TrustLineEntryV1Ext {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            TrustLineEntryV1Ext::V0 => (0 as i32).to_xdr_buffered(write_stream),
            TrustLineEntryV1Ext::V2(value) => {
                (2 as i32).to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            TrustLineEntryV1Ext::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(TrustLineEntryV1Ext::V0),
            2 => Ok(TrustLineEntryV1Ext::V2(TrustLineEntryExtensionV2::from_xdr_buffered(read_stream)?)),
            code => Ok(TrustLineEntryV1Ext::Default(code)),
        }
    }
}

/// Autogenerated definition for type TrustLineEntryExt
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum TrustLineEntryExt {
    V0,
    V1(TrustLineEntryV1),
    Default(i32),
}

impl XdrCodec for TrustLineEntryExt {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            TrustLineEntryExt::V0 => (0 as i32).to_xdr_buffered(write_stream),
            TrustLineEntryExt::V1(value) => {
                (1 as i32).to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            TrustLineEntryExt::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(TrustLineEntryExt::V0),
            1 => Ok(TrustLineEntryExt::V1(TrustLineEntryV1::from_xdr_buffered(read_stream)?)),
            code => Ok(TrustLineEntryExt::Default(code)),
        }
    }
}

/// Autogenerated definition for type OfferEntryExt
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum OfferEntryExt {
    V0,
    Default(i32),
}

impl XdrCodec for OfferEntryExt {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            OfferEntryExt::V0 => (0 as i32).to_xdr_buffered(write_stream),
            OfferEntryExt::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(OfferEntryExt::V0),
            code => Ok(OfferEntryExt::Default(code)),
        }
    }
}

/// Autogenerated definition for type DataEntryExt
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum DataEntryExt {
    V0,
    Default(i32),
}

impl XdrCodec for DataEntryExt {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            DataEntryExt::V0 => (0 as i32).to_xdr_buffered(write_stream),
            DataEntryExt::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(DataEntryExt::V0),
            code => Ok(DataEntryExt::Default(code)),
        }
    }
}

/// Autogenerated definition for type ClaimPredicate
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ClaimPredicate {
    ClaimPredicateUnconditional,
    ClaimPredicateAnd(LimitedVarArray<ClaimPredicate, 2>),
    ClaimPredicateOr(LimitedVarArray<ClaimPredicate, 2>),
    ClaimPredicateNot(Option<Box<ClaimPredicate>>),
    ClaimPredicateBeforeAbsoluteTime(Int64),
    ClaimPredicateBeforeRelativeTime(Int64),
}

impl XdrCodec for ClaimPredicate {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ClaimPredicate::ClaimPredicateUnconditional =>
                ClaimPredicateType::ClaimPredicateUnconditional.to_xdr_buffered(write_stream),
            ClaimPredicate::ClaimPredicateAnd(value) => {
                ClaimPredicateType::ClaimPredicateAnd.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ClaimPredicate::ClaimPredicateOr(value) => {
                ClaimPredicateType::ClaimPredicateOr.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ClaimPredicate::ClaimPredicateNot(value) => {
                ClaimPredicateType::ClaimPredicateNot.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ClaimPredicate::ClaimPredicateBeforeAbsoluteTime(value) => {
                ClaimPredicateType::ClaimPredicateBeforeAbsoluteTime.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ClaimPredicate::ClaimPredicateBeforeRelativeTime(value) => {
                ClaimPredicateType::ClaimPredicateBeforeRelativeTime.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match ClaimPredicateType::from_xdr_buffered(read_stream)? {
            ClaimPredicateType::ClaimPredicateUnconditional => Ok(ClaimPredicate::ClaimPredicateUnconditional),
            ClaimPredicateType::ClaimPredicateAnd =>
                Ok(ClaimPredicate::ClaimPredicateAnd(LimitedVarArray::<ClaimPredicate, 2>::from_xdr_buffered(
                    read_stream,
                )?)),
            ClaimPredicateType::ClaimPredicateOr =>
                Ok(ClaimPredicate::ClaimPredicateOr(LimitedVarArray::<ClaimPredicate, 2>::from_xdr_buffered(
                    read_stream,
                )?)),
            ClaimPredicateType::ClaimPredicateNot =>
                Ok(ClaimPredicate::ClaimPredicateNot(Option::<Box<ClaimPredicate>>::from_xdr_buffered(read_stream)?)),
            ClaimPredicateType::ClaimPredicateBeforeAbsoluteTime =>
                Ok(ClaimPredicate::ClaimPredicateBeforeAbsoluteTime(Int64::from_xdr_buffered(read_stream)?)),
            ClaimPredicateType::ClaimPredicateBeforeRelativeTime =>
                Ok(ClaimPredicate::ClaimPredicateBeforeRelativeTime(Int64::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type Claimant
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum Claimant {
    ClaimantTypeV0(ClaimantV0),
}

impl XdrCodec for Claimant {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            Claimant::ClaimantTypeV0(value) => {
                ClaimantType::ClaimantTypeV0.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match ClaimantType::from_xdr_buffered(read_stream)? {
            ClaimantType::ClaimantTypeV0 => Ok(Claimant::ClaimantTypeV0(ClaimantV0::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type ClaimableBalanceId
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ClaimableBalanceId {
    ClaimableBalanceIdTypeV0(Hash),
}

impl XdrCodec for ClaimableBalanceId {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ClaimableBalanceId::ClaimableBalanceIdTypeV0(value) => {
                ClaimableBalanceIdType::ClaimableBalanceIdTypeV0.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match ClaimableBalanceIdType::from_xdr_buffered(read_stream)? {
            ClaimableBalanceIdType::ClaimableBalanceIdTypeV0 =>
                Ok(ClaimableBalanceId::ClaimableBalanceIdTypeV0(Hash::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type ClaimableBalanceEntryExtensionV1Ext
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ClaimableBalanceEntryExtensionV1Ext {
    V0,
    Default(i32),
}

impl XdrCodec for ClaimableBalanceEntryExtensionV1Ext {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ClaimableBalanceEntryExtensionV1Ext::V0 => (0 as i32).to_xdr_buffered(write_stream),
            ClaimableBalanceEntryExtensionV1Ext::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(ClaimableBalanceEntryExtensionV1Ext::V0),
            code => Ok(ClaimableBalanceEntryExtensionV1Ext::Default(code)),
        }
    }
}

/// Autogenerated definition for type ClaimableBalanceEntryExt
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ClaimableBalanceEntryExt {
    V0,
    V1(ClaimableBalanceEntryExtensionV1),
    Default(i32),
}

impl XdrCodec for ClaimableBalanceEntryExt {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ClaimableBalanceEntryExt::V0 => (0 as i32).to_xdr_buffered(write_stream),
            ClaimableBalanceEntryExt::V1(value) => {
                (1 as i32).to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ClaimableBalanceEntryExt::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(ClaimableBalanceEntryExt::V0),
            1 => Ok(ClaimableBalanceEntryExt::V1(ClaimableBalanceEntryExtensionV1::from_xdr_buffered(read_stream)?)),
            code => Ok(ClaimableBalanceEntryExt::Default(code)),
        }
    }
}

/// Autogenerated definition for type LiquidityPoolEntryBody
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum LiquidityPoolEntryBody {
    LiquidityPoolConstantProduct(LiquidityPoolEntryConstantProduct),
}

impl XdrCodec for LiquidityPoolEntryBody {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            LiquidityPoolEntryBody::LiquidityPoolConstantProduct(value) => {
                LiquidityPoolType::LiquidityPoolConstantProduct.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match LiquidityPoolType::from_xdr_buffered(read_stream)? {
            LiquidityPoolType::LiquidityPoolConstantProduct =>
                Ok(LiquidityPoolEntryBody::LiquidityPoolConstantProduct(
                    LiquidityPoolEntryConstantProduct::from_xdr_buffered(read_stream)?,
                )),
        }
    }
}

/// Autogenerated definition for type LedgerEntryExtensionV1Ext
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum LedgerEntryExtensionV1Ext {
    V0,
    Default(i32),
}

impl XdrCodec for LedgerEntryExtensionV1Ext {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            LedgerEntryExtensionV1Ext::V0 => (0 as i32).to_xdr_buffered(write_stream),
            LedgerEntryExtensionV1Ext::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(LedgerEntryExtensionV1Ext::V0),
            code => Ok(LedgerEntryExtensionV1Ext::Default(code)),
        }
    }
}

/// Autogenerated definition for type LedgerEntryData
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum LedgerEntryData {
    Account(AccountEntry),
    Trustline(TrustLineEntry),
    Offer(OfferEntry),
    Data(DataEntry),
    ClaimableBalance(ClaimableBalanceEntry),
    LiquidityPool(LiquidityPoolEntry),
    ContractData(ContractDataEntry),
    ContractCode(ContractCodeEntry),
    ConfigSetting(ConfigSettingEntry),
    Ttl(TtlEntry),
}

impl XdrCodec for LedgerEntryData {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            LedgerEntryData::Account(value) => {
                LedgerEntryType::Account.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerEntryData::Trustline(value) => {
                LedgerEntryType::Trustline.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerEntryData::Offer(value) => {
                LedgerEntryType::Offer.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerEntryData::Data(value) => {
                LedgerEntryType::Data.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerEntryData::ClaimableBalance(value) => {
                LedgerEntryType::ClaimableBalance.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerEntryData::LiquidityPool(value) => {
                LedgerEntryType::LiquidityPool.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerEntryData::ContractData(value) => {
                LedgerEntryType::ContractData.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerEntryData::ContractCode(value) => {
                LedgerEntryType::ContractCode.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerEntryData::ConfigSetting(value) => {
                LedgerEntryType::ConfigSetting.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerEntryData::Ttl(value) => {
                LedgerEntryType::Ttl.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match LedgerEntryType::from_xdr_buffered(read_stream)? {
            LedgerEntryType::Account => Ok(LedgerEntryData::Account(AccountEntry::from_xdr_buffered(read_stream)?)),
            LedgerEntryType::Trustline =>
                Ok(LedgerEntryData::Trustline(TrustLineEntry::from_xdr_buffered(read_stream)?)),
            LedgerEntryType::Offer => Ok(LedgerEntryData::Offer(OfferEntry::from_xdr_buffered(read_stream)?)),
            LedgerEntryType::Data => Ok(LedgerEntryData::Data(DataEntry::from_xdr_buffered(read_stream)?)),
            LedgerEntryType::ClaimableBalance =>
                Ok(LedgerEntryData::ClaimableBalance(ClaimableBalanceEntry::from_xdr_buffered(read_stream)?)),
            LedgerEntryType::LiquidityPool =>
                Ok(LedgerEntryData::LiquidityPool(LiquidityPoolEntry::from_xdr_buffered(read_stream)?)),
            LedgerEntryType::ContractData =>
                Ok(LedgerEntryData::ContractData(ContractDataEntry::from_xdr_buffered(read_stream)?)),
            LedgerEntryType::ContractCode =>
                Ok(LedgerEntryData::ContractCode(ContractCodeEntry::from_xdr_buffered(read_stream)?)),
            LedgerEntryType::ConfigSetting =>
                Ok(LedgerEntryData::ConfigSetting(ConfigSettingEntry::from_xdr_buffered(read_stream)?)),
            LedgerEntryType::Ttl => Ok(LedgerEntryData::Ttl(TtlEntry::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type LedgerEntryExt
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum LedgerEntryExt {
    V0,
    V1(LedgerEntryExtensionV1),
    Default(i32),
}

impl XdrCodec for LedgerEntryExt {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            LedgerEntryExt::V0 => (0 as i32).to_xdr_buffered(write_stream),
            LedgerEntryExt::V1(value) => {
                (1 as i32).to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerEntryExt::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(LedgerEntryExt::V0),
            1 => Ok(LedgerEntryExt::V1(LedgerEntryExtensionV1::from_xdr_buffered(read_stream)?)),
            code => Ok(LedgerEntryExt::Default(code)),
        }
    }
}

/// Autogenerated definition for type LedgerKey
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum LedgerKey {
    Account(LedgerKeyAccount),
    Trustline(LedgerKeyTrustLine),
    Offer(LedgerKeyOffer),
    Data(LedgerKeyData),
    ClaimableBalance(LedgerKeyClaimableBalance),
    LiquidityPool(LedgerKeyLiquidityPool),
    ContractData(LedgerKeyContractData),
    ContractCode(LedgerKeyContractCode),
    ConfigSetting(LedgerKeyConfigSetting),
    Ttl(LedgerKeyTtl),
}

impl XdrCodec for LedgerKey {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            LedgerKey::Account(value) => {
                LedgerEntryType::Account.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerKey::Trustline(value) => {
                LedgerEntryType::Trustline.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerKey::Offer(value) => {
                LedgerEntryType::Offer.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerKey::Data(value) => {
                LedgerEntryType::Data.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerKey::ClaimableBalance(value) => {
                LedgerEntryType::ClaimableBalance.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerKey::LiquidityPool(value) => {
                LedgerEntryType::LiquidityPool.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerKey::ContractData(value) => {
                LedgerEntryType::ContractData.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerKey::ContractCode(value) => {
                LedgerEntryType::ContractCode.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerKey::ConfigSetting(value) => {
                LedgerEntryType::ConfigSetting.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerKey::Ttl(value) => {
                LedgerEntryType::Ttl.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match LedgerEntryType::from_xdr_buffered(read_stream)? {
            LedgerEntryType::Account => Ok(LedgerKey::Account(LedgerKeyAccount::from_xdr_buffered(read_stream)?)),
            LedgerEntryType::Trustline => Ok(LedgerKey::Trustline(LedgerKeyTrustLine::from_xdr_buffered(read_stream)?)),
            LedgerEntryType::Offer => Ok(LedgerKey::Offer(LedgerKeyOffer::from_xdr_buffered(read_stream)?)),
            LedgerEntryType::Data => Ok(LedgerKey::Data(LedgerKeyData::from_xdr_buffered(read_stream)?)),
            LedgerEntryType::ClaimableBalance =>
                Ok(LedgerKey::ClaimableBalance(LedgerKeyClaimableBalance::from_xdr_buffered(read_stream)?)),
            LedgerEntryType::LiquidityPool =>
                Ok(LedgerKey::LiquidityPool(LedgerKeyLiquidityPool::from_xdr_buffered(read_stream)?)),
            LedgerEntryType::ContractData =>
                Ok(LedgerKey::ContractData(LedgerKeyContractData::from_xdr_buffered(read_stream)?)),
            LedgerEntryType::ContractCode =>
                Ok(LedgerKey::ContractCode(LedgerKeyContractCode::from_xdr_buffered(read_stream)?)),
            LedgerEntryType::ConfigSetting =>
                Ok(LedgerKey::ConfigSetting(LedgerKeyConfigSetting::from_xdr_buffered(read_stream)?)),
            LedgerEntryType::Ttl => Ok(LedgerKey::Ttl(LedgerKeyTtl::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type StellarValueExt
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum StellarValueExt {
    StellarValueBasic,
    StellarValueSigned(LedgerCloseValueSignature),
}

#[cfg(feature = "all-types")]
impl XdrCodec for StellarValueExt {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            StellarValueExt::StellarValueBasic => StellarValueType::StellarValueBasic.to_xdr_buffered(write_stream),
            StellarValueExt::StellarValueSigned(value) => {
                StellarValueType::StellarValueSigned.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match StellarValueType::from_xdr_buffered(read_stream)? {
            StellarValueType::StellarValueBasic => Ok(StellarValueExt::StellarValueBasic),
            StellarValueType::StellarValueSigned =>
                Ok(StellarValueExt::StellarValueSigned(LedgerCloseValueSignature::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type LedgerHeaderExtensionV1Ext
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum LedgerHeaderExtensionV1Ext {
    V0,
    Default(i32),
}

#[cfg(feature = "all-types")]
impl XdrCodec for LedgerHeaderExtensionV1Ext {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            LedgerHeaderExtensionV1Ext::V0 => (0 as i32).to_xdr_buffered(write_stream),
            LedgerHeaderExtensionV1Ext::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(LedgerHeaderExtensionV1Ext::V0),
            code => Ok(LedgerHeaderExtensionV1Ext::Default(code)),
        }
    }
}

/// Autogenerated definition for type LedgerHeaderExt
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum LedgerHeaderExt {
    V0,
    V1(LedgerHeaderExtensionV1),
    Default(i32),
}

#[cfg(feature = "all-types")]
impl XdrCodec for LedgerHeaderExt {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            LedgerHeaderExt::V0 => (0 as i32).to_xdr_buffered(write_stream),
            LedgerHeaderExt::V1(value) => {
                (1 as i32).to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerHeaderExt::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(LedgerHeaderExt::V0),
            1 => Ok(LedgerHeaderExt::V1(LedgerHeaderExtensionV1::from_xdr_buffered(read_stream)?)),
            code => Ok(LedgerHeaderExt::Default(code)),
        }
    }
}

/// Autogenerated definition for type LedgerUpgrade
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum LedgerUpgrade {
    LedgerUpgradeVersion(Uint32),
    LedgerUpgradeBaseFee(Uint32),
    LedgerUpgradeMaxTxSetSize(Uint32),
    LedgerUpgradeBaseReserve(Uint32),
    LedgerUpgradeFlags(Uint32),
    LedgerUpgradeConfig(ConfigUpgradeSetKey),
    LedgerUpgradeMaxSorobanTxSetSize(Uint32),
}

#[cfg(feature = "all-types")]
impl XdrCodec for LedgerUpgrade {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            LedgerUpgrade::LedgerUpgradeVersion(value) => {
                LedgerUpgradeType::LedgerUpgradeVersion.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerUpgrade::LedgerUpgradeBaseFee(value) => {
                LedgerUpgradeType::LedgerUpgradeBaseFee.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerUpgrade::LedgerUpgradeMaxTxSetSize(value) => {
                LedgerUpgradeType::LedgerUpgradeMaxTxSetSize.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerUpgrade::LedgerUpgradeBaseReserve(value) => {
                LedgerUpgradeType::LedgerUpgradeBaseReserve.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerUpgrade::LedgerUpgradeFlags(value) => {
                LedgerUpgradeType::LedgerUpgradeFlags.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerUpgrade::LedgerUpgradeConfig(value) => {
                LedgerUpgradeType::LedgerUpgradeConfig.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerUpgrade::LedgerUpgradeMaxSorobanTxSetSize(value) => {
                LedgerUpgradeType::LedgerUpgradeMaxSorobanTxSetSize.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match LedgerUpgradeType::from_xdr_buffered(read_stream)? {
            LedgerUpgradeType::LedgerUpgradeVersion =>
                Ok(LedgerUpgrade::LedgerUpgradeVersion(Uint32::from_xdr_buffered(read_stream)?)),
            LedgerUpgradeType::LedgerUpgradeBaseFee =>
                Ok(LedgerUpgrade::LedgerUpgradeBaseFee(Uint32::from_xdr_buffered(read_stream)?)),
            LedgerUpgradeType::LedgerUpgradeMaxTxSetSize =>
                Ok(LedgerUpgrade::LedgerUpgradeMaxTxSetSize(Uint32::from_xdr_buffered(read_stream)?)),
            LedgerUpgradeType::LedgerUpgradeBaseReserve =>
                Ok(LedgerUpgrade::LedgerUpgradeBaseReserve(Uint32::from_xdr_buffered(read_stream)?)),
            LedgerUpgradeType::LedgerUpgradeFlags =>
                Ok(LedgerUpgrade::LedgerUpgradeFlags(Uint32::from_xdr_buffered(read_stream)?)),
            LedgerUpgradeType::LedgerUpgradeConfig =>
                Ok(LedgerUpgrade::LedgerUpgradeConfig(ConfigUpgradeSetKey::from_xdr_buffered(read_stream)?)),
            LedgerUpgradeType::LedgerUpgradeMaxSorobanTxSetSize =>
                Ok(LedgerUpgrade::LedgerUpgradeMaxSorobanTxSetSize(Uint32::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type BucketMetadataExt
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum BucketMetadataExt {
    V0,
    Default(i32),
}

#[cfg(feature = "all-types")]
impl XdrCodec for BucketMetadataExt {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            BucketMetadataExt::V0 => (0 as i32).to_xdr_buffered(write_stream),
            BucketMetadataExt::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(BucketMetadataExt::V0),
            code => Ok(BucketMetadataExt::Default(code)),
        }
    }
}

/// Autogenerated definition for type BucketEntry
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum BucketEntry {
    Liveentry(LedgerEntry),
    Initentry(LedgerEntry),
    Deadentry(LedgerKey),
    Metaentry(BucketMetadata),
}

#[cfg(feature = "all-types")]
impl XdrCodec for BucketEntry {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            BucketEntry::Liveentry(value) => {
                BucketEntryType::Liveentry.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            BucketEntry::Initentry(value) => {
                BucketEntryType::Initentry.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            BucketEntry::Deadentry(value) => {
                BucketEntryType::Deadentry.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            BucketEntry::Metaentry(value) => {
                BucketEntryType::Metaentry.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match BucketEntryType::from_xdr_buffered(read_stream)? {
            BucketEntryType::Liveentry => Ok(BucketEntry::Liveentry(LedgerEntry::from_xdr_buffered(read_stream)?)),
            BucketEntryType::Initentry => Ok(BucketEntry::Initentry(LedgerEntry::from_xdr_buffered(read_stream)?)),
            BucketEntryType::Deadentry => Ok(BucketEntry::Deadentry(LedgerKey::from_xdr_buffered(read_stream)?)),
            BucketEntryType::Metaentry => Ok(BucketEntry::Metaentry(BucketMetadata::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type TxSetComponent
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum TxSetComponent {
    TxsetCompTxsMaybeDiscountedFee(TxSetComponentTxsMaybeDiscountedFee),
}

#[cfg(feature = "all-types")]
impl XdrCodec for TxSetComponent {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            TxSetComponent::TxsetCompTxsMaybeDiscountedFee(value) => {
                TxSetComponentType::TxsetCompTxsMaybeDiscountedFee.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match TxSetComponentType::from_xdr_buffered(read_stream)? {
            TxSetComponentType::TxsetCompTxsMaybeDiscountedFee => Ok(TxSetComponent::TxsetCompTxsMaybeDiscountedFee(
                TxSetComponentTxsMaybeDiscountedFee::from_xdr_buffered(read_stream)?,
            )),
        }
    }
}

/// Autogenerated definition for type TransactionPhase
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum TransactionPhase {
    V0(UnlimitedVarArray<TxSetComponent>),
    Default(i32),
}

#[cfg(feature = "all-types")]
impl XdrCodec for TransactionPhase {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            TransactionPhase::V0(value) => {
                (0 as i32).to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            TransactionPhase::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(TransactionPhase::V0(UnlimitedVarArray::<TxSetComponent>::from_xdr_buffered(read_stream)?)),
            code => Ok(TransactionPhase::Default(code)),
        }
    }
}

/// Autogenerated definition for type GeneralizedTransactionSet
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum GeneralizedTransactionSet {
    V1(TransactionSetV1),
    Default(i32),
}

#[cfg(feature = "all-types")]
impl XdrCodec for GeneralizedTransactionSet {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            GeneralizedTransactionSet::V1(value) => {
                (1 as i32).to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            GeneralizedTransactionSet::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            1 => Ok(GeneralizedTransactionSet::V1(TransactionSetV1::from_xdr_buffered(read_stream)?)),
            code => Ok(GeneralizedTransactionSet::Default(code)),
        }
    }
}

/// Autogenerated definition for type TransactionHistoryEntryExt
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum TransactionHistoryEntryExt {
    V0,
    V1(GeneralizedTransactionSet),
    Default(i32),
}

#[cfg(feature = "all-types")]
impl XdrCodec for TransactionHistoryEntryExt {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            TransactionHistoryEntryExt::V0 => (0 as i32).to_xdr_buffered(write_stream),
            TransactionHistoryEntryExt::V1(value) => {
                (1 as i32).to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            TransactionHistoryEntryExt::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(TransactionHistoryEntryExt::V0),
            1 => Ok(TransactionHistoryEntryExt::V1(GeneralizedTransactionSet::from_xdr_buffered(read_stream)?)),
            code => Ok(TransactionHistoryEntryExt::Default(code)),
        }
    }
}

/// Autogenerated definition for type TransactionHistoryResultEntryExt
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum TransactionHistoryResultEntryExt {
    V0,
    Default(i32),
}

#[cfg(feature = "all-types")]
impl XdrCodec for TransactionHistoryResultEntryExt {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            TransactionHistoryResultEntryExt::V0 => (0 as i32).to_xdr_buffered(write_stream),
            TransactionHistoryResultEntryExt::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(TransactionHistoryResultEntryExt::V0),
            code => Ok(TransactionHistoryResultEntryExt::Default(code)),
        }
    }
}

/// Autogenerated definition for type LedgerHeaderHistoryEntryExt
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum LedgerHeaderHistoryEntryExt {
    V0,
    Default(i32),
}

#[cfg(feature = "all-types")]
impl XdrCodec for LedgerHeaderHistoryEntryExt {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            LedgerHeaderHistoryEntryExt::V0 => (0 as i32).to_xdr_buffered(write_stream),
            LedgerHeaderHistoryEntryExt::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(LedgerHeaderHistoryEntryExt::V0),
            code => Ok(LedgerHeaderHistoryEntryExt::Default(code)),
        }
    }
}

/// Autogenerated definition for type ScpHistoryEntry
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ScpHistoryEntry {
    V0(ScpHistoryEntryV0),
    Default(i32),
}

#[cfg(feature = "all-types")]
impl XdrCodec for ScpHistoryEntry {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ScpHistoryEntry::V0(value) => {
                (0 as i32).to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ScpHistoryEntry::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(ScpHistoryEntry::V0(ScpHistoryEntryV0::from_xdr_buffered(read_stream)?)),
            code => Ok(ScpHistoryEntry::Default(code)),
        }
    }
}

/// Autogenerated definition for type LedgerEntryChange
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum LedgerEntryChange {
    LedgerEntryCreated(LedgerEntry),
    LedgerEntryUpdated(LedgerEntry),
    LedgerEntryRemoved(LedgerKey),
    LedgerEntryState(LedgerEntry),
}

impl XdrCodec for LedgerEntryChange {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            LedgerEntryChange::LedgerEntryCreated(value) => {
                LedgerEntryChangeType::LedgerEntryCreated.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerEntryChange::LedgerEntryUpdated(value) => {
                LedgerEntryChangeType::LedgerEntryUpdated.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerEntryChange::LedgerEntryRemoved(value) => {
                LedgerEntryChangeType::LedgerEntryRemoved.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerEntryChange::LedgerEntryState(value) => {
                LedgerEntryChangeType::LedgerEntryState.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match LedgerEntryChangeType::from_xdr_buffered(read_stream)? {
            LedgerEntryChangeType::LedgerEntryCreated =>
                Ok(LedgerEntryChange::LedgerEntryCreated(LedgerEntry::from_xdr_buffered(read_stream)?)),
            LedgerEntryChangeType::LedgerEntryUpdated =>
                Ok(LedgerEntryChange::LedgerEntryUpdated(LedgerEntry::from_xdr_buffered(read_stream)?)),
            LedgerEntryChangeType::LedgerEntryRemoved =>
                Ok(LedgerEntryChange::LedgerEntryRemoved(LedgerKey::from_xdr_buffered(read_stream)?)),
            LedgerEntryChangeType::LedgerEntryState =>
                Ok(LedgerEntryChange::LedgerEntryState(LedgerEntry::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type ContractEventBody
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ContractEventBody {
    V0(ContractEventV0),
    Default(i32),
}

impl XdrCodec for ContractEventBody {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ContractEventBody::V0(value) => {
                (0 as i32).to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ContractEventBody::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(ContractEventBody::V0(ContractEventV0::from_xdr_buffered(read_stream)?)),
            code => Ok(ContractEventBody::Default(code)),
        }
    }
}

/// Autogenerated definition for type TransactionMeta
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum TransactionMeta {
    V0(UnlimitedVarArray<OperationMeta>),
    V1(TransactionMetaV1),
    V2(TransactionMetaV2),
    V3(TransactionMetaV3),
    Default(i32),
}

impl XdrCodec for TransactionMeta {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            TransactionMeta::V0(value) => {
                (0 as i32).to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            TransactionMeta::V1(value) => {
                (1 as i32).to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            TransactionMeta::V2(value) => {
                (2 as i32).to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            TransactionMeta::V3(value) => {
                (3 as i32).to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            TransactionMeta::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(TransactionMeta::V0(UnlimitedVarArray::<OperationMeta>::from_xdr_buffered(read_stream)?)),
            1 => Ok(TransactionMeta::V1(TransactionMetaV1::from_xdr_buffered(read_stream)?)),
            2 => Ok(TransactionMeta::V2(TransactionMetaV2::from_xdr_buffered(read_stream)?)),
            3 => Ok(TransactionMeta::V3(TransactionMetaV3::from_xdr_buffered(read_stream)?)),
            code => Ok(TransactionMeta::Default(code)),
        }
    }
}

/// Autogenerated definition for type LedgerCloseMeta
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum LedgerCloseMeta {
    V0(LedgerCloseMetaV0),
    V1(LedgerCloseMetaV1),
    Default(i32),
}

#[cfg(feature = "all-types")]
impl XdrCodec for LedgerCloseMeta {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            LedgerCloseMeta::V0(value) => {
                (0 as i32).to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerCloseMeta::V1(value) => {
                (1 as i32).to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            LedgerCloseMeta::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(LedgerCloseMeta::V0(LedgerCloseMetaV0::from_xdr_buffered(read_stream)?)),
            1 => Ok(LedgerCloseMeta::V1(LedgerCloseMetaV1::from_xdr_buffered(read_stream)?)),
            code => Ok(LedgerCloseMeta::Default(code)),
        }
    }
}

/// Autogenerated definition for type PeerAddressIp
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum PeerAddressIp {
    IPv4([u8; 4]),
    IPv6([u8; 16]),
}

#[cfg(feature = "all-types")]
impl XdrCodec for PeerAddressIp {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            PeerAddressIp::IPv4(value) => {
                IpAddrType::IPv4.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            PeerAddressIp::IPv6(value) => {
                IpAddrType::IPv6.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match IpAddrType::from_xdr_buffered(read_stream)? {
            IpAddrType::IPv4 => Ok(PeerAddressIp::IPv4(<[u8; 4]>::from_xdr_buffered(read_stream)?)),
            IpAddrType::IPv6 => Ok(PeerAddressIp::IPv6(<[u8; 16]>::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type SurveyResponseBody
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum SurveyResponseBody {
    SurveyTopologyResponseV0(TopologyResponseBodyV0),
    SurveyTopologyResponseV1(TopologyResponseBodyV1),
}

#[cfg(feature = "all-types")]
impl XdrCodec for SurveyResponseBody {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            SurveyResponseBody::SurveyTopologyResponseV0(value) => {
                SurveyMessageResponseType::SurveyTopologyResponseV0.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            SurveyResponseBody::SurveyTopologyResponseV1(value) => {
                SurveyMessageResponseType::SurveyTopologyResponseV1.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match SurveyMessageResponseType::from_xdr_buffered(read_stream)? {
            SurveyMessageResponseType::SurveyTopologyResponseV0 => Ok(SurveyResponseBody::SurveyTopologyResponseV0(
                TopologyResponseBodyV0::from_xdr_buffered(read_stream)?,
            )),
            SurveyMessageResponseType::SurveyTopologyResponseV1 => Ok(SurveyResponseBody::SurveyTopologyResponseV1(
                TopologyResponseBodyV1::from_xdr_buffered(read_stream)?,
            )),
        }
    }
}

/// Autogenerated definition for type StellarMessage
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum StellarMessage {
    ErrorMsg(Error),
    Hello(Hello),
    Auth(Auth),
    DontHave(DontHave),
    GetPeers,
    Peers(LimitedVarArray<PeerAddress, 100>),
    GetTxSet(Uint256),
    TxSet(TransactionSet),
    GeneralizedTxSet(GeneralizedTransactionSet),
    Transaction(TransactionEnvelope),
    SurveyRequest(SignedSurveyRequestMessage),
    SurveyResponse(SignedSurveyResponseMessage),
    GetScpQuorumset(Uint256),
    ScpQuorumset(ScpQuorumSet),
    ScpMessage(ScpEnvelope),
    GetScpState(Uint32),
    SendMore(SendMore),
    SendMoreExtended(SendMoreExtended),
    FloodAdvert(FloodAdvert),
    FloodDemand(FloodDemand),
}

#[cfg(feature = "all-types")]
impl XdrCodec for StellarMessage {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            StellarMessage::ErrorMsg(value) => {
                MessageType::ErrorMsg.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            StellarMessage::Hello(value) => {
                MessageType::Hello.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            StellarMessage::Auth(value) => {
                MessageType::Auth.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            StellarMessage::DontHave(value) => {
                MessageType::DontHave.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            StellarMessage::GetPeers => MessageType::GetPeers.to_xdr_buffered(write_stream),
            StellarMessage::Peers(value) => {
                MessageType::Peers.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            StellarMessage::GetTxSet(value) => {
                MessageType::GetTxSet.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            StellarMessage::TxSet(value) => {
                MessageType::TxSet.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            StellarMessage::GeneralizedTxSet(value) => {
                MessageType::GeneralizedTxSet.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            StellarMessage::Transaction(value) => {
                MessageType::Transaction.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            StellarMessage::SurveyRequest(value) => {
                MessageType::SurveyRequest.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            StellarMessage::SurveyResponse(value) => {
                MessageType::SurveyResponse.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            StellarMessage::GetScpQuorumset(value) => {
                MessageType::GetScpQuorumset.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            StellarMessage::ScpQuorumset(value) => {
                MessageType::ScpQuorumset.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            StellarMessage::ScpMessage(value) => {
                MessageType::ScpMessage.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            StellarMessage::GetScpState(value) => {
                MessageType::GetScpState.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            StellarMessage::SendMore(value) => {
                MessageType::SendMore.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            StellarMessage::SendMoreExtended(value) => {
                MessageType::SendMoreExtended.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            StellarMessage::FloodAdvert(value) => {
                MessageType::FloodAdvert.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            StellarMessage::FloodDemand(value) => {
                MessageType::FloodDemand.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match MessageType::from_xdr_buffered(read_stream)? {
            MessageType::ErrorMsg => Ok(StellarMessage::ErrorMsg(Error::from_xdr_buffered(read_stream)?)),
            MessageType::Hello => Ok(StellarMessage::Hello(Hello::from_xdr_buffered(read_stream)?)),
            MessageType::Auth => Ok(StellarMessage::Auth(Auth::from_xdr_buffered(read_stream)?)),
            MessageType::DontHave => Ok(StellarMessage::DontHave(DontHave::from_xdr_buffered(read_stream)?)),
            MessageType::GetPeers => Ok(StellarMessage::GetPeers),
            MessageType::Peers =>
                Ok(StellarMessage::Peers(LimitedVarArray::<PeerAddress, 100>::from_xdr_buffered(read_stream)?)),
            MessageType::GetTxSet => Ok(StellarMessage::GetTxSet(Uint256::from_xdr_buffered(read_stream)?)),
            MessageType::TxSet => Ok(StellarMessage::TxSet(TransactionSet::from_xdr_buffered(read_stream)?)),
            MessageType::GeneralizedTxSet =>
                Ok(StellarMessage::GeneralizedTxSet(GeneralizedTransactionSet::from_xdr_buffered(read_stream)?)),
            MessageType::Transaction =>
                Ok(StellarMessage::Transaction(TransactionEnvelope::from_xdr_buffered(read_stream)?)),
            MessageType::SurveyRequest =>
                Ok(StellarMessage::SurveyRequest(SignedSurveyRequestMessage::from_xdr_buffered(read_stream)?)),
            MessageType::SurveyResponse =>
                Ok(StellarMessage::SurveyResponse(SignedSurveyResponseMessage::from_xdr_buffered(read_stream)?)),
            MessageType::GetScpQuorumset =>
                Ok(StellarMessage::GetScpQuorumset(Uint256::from_xdr_buffered(read_stream)?)),
            MessageType::ScpQuorumset =>
                Ok(StellarMessage::ScpQuorumset(ScpQuorumSet::from_xdr_buffered(read_stream)?)),
            MessageType::ScpMessage => Ok(StellarMessage::ScpMessage(ScpEnvelope::from_xdr_buffered(read_stream)?)),
            MessageType::GetScpState => Ok(StellarMessage::GetScpState(Uint32::from_xdr_buffered(read_stream)?)),
            MessageType::SendMore => Ok(StellarMessage::SendMore(SendMore::from_xdr_buffered(read_stream)?)),
            MessageType::SendMoreExtended =>
                Ok(StellarMessage::SendMoreExtended(SendMoreExtended::from_xdr_buffered(read_stream)?)),
            MessageType::FloodAdvert => Ok(StellarMessage::FloodAdvert(FloodAdvert::from_xdr_buffered(read_stream)?)),
            MessageType::FloodDemand => Ok(StellarMessage::FloodDemand(FloodDemand::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type AuthenticatedMessage
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum AuthenticatedMessage {
    V0(AuthenticatedMessageV0),
    Default(Uint32),
}

#[cfg(feature = "all-types")]
impl XdrCodec for AuthenticatedMessage {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            AuthenticatedMessage::V0(value) => {
                (0 as Uint32).to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            AuthenticatedMessage::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match Uint32::from_xdr_buffered(read_stream)? {
            0 => Ok(AuthenticatedMessage::V0(AuthenticatedMessageV0::from_xdr_buffered(read_stream)?)),
            code => Ok(AuthenticatedMessage::Default(code)),
        }
    }
}

/// Autogenerated definition for type LiquidityPoolParameters
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum LiquidityPoolParameters {
    LiquidityPoolConstantProduct(LiquidityPoolConstantProductParameters),
}

impl XdrCodec for LiquidityPoolParameters {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            LiquidityPoolParameters::LiquidityPoolConstantProduct(value) => {
                LiquidityPoolType::LiquidityPoolConstantProduct.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match LiquidityPoolType::from_xdr_buffered(read_stream)? {
            LiquidityPoolType::LiquidityPoolConstantProduct =>
                Ok(LiquidityPoolParameters::LiquidityPoolConstantProduct(
                    LiquidityPoolConstantProductParameters::from_xdr_buffered(read_stream)?,
                )),
        }
    }
}

/// Autogenerated definition for type MuxedAccount
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum MuxedAccount {
    KeyTypeEd25519(Uint256),
    KeyTypeMuxedEd25519(MuxedAccountMed25519),
    Default(CryptoKeyType),
}

impl XdrCodec for MuxedAccount {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            MuxedAccount::KeyTypeEd25519(value) => {
                CryptoKeyType::KeyTypeEd25519.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            MuxedAccount::KeyTypeMuxedEd25519(value) => {
                CryptoKeyType::KeyTypeMuxedEd25519.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            MuxedAccount::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match CryptoKeyType::from_xdr_buffered(read_stream)? {
            CryptoKeyType::KeyTypeEd25519 => Ok(MuxedAccount::KeyTypeEd25519(Uint256::from_xdr_buffered(read_stream)?)),
            CryptoKeyType::KeyTypeMuxedEd25519 =>
                Ok(MuxedAccount::KeyTypeMuxedEd25519(MuxedAccountMed25519::from_xdr_buffered(read_stream)?)),
            code => Ok(MuxedAccount::Default(code)),
        }
    }
}

/// Autogenerated definition for type ChangeTrustAsset
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ChangeTrustAsset {
    AssetTypeNative,
    AssetTypeCreditAlphanum4(AlphaNum4),
    AssetTypeCreditAlphanum12(AlphaNum12),
    AssetTypePoolShare(LiquidityPoolParameters),
}

impl XdrCodec for ChangeTrustAsset {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ChangeTrustAsset::AssetTypeNative => AssetType::AssetTypeNative.to_xdr_buffered(write_stream),
            ChangeTrustAsset::AssetTypeCreditAlphanum4(value) => {
                AssetType::AssetTypeCreditAlphanum4.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ChangeTrustAsset::AssetTypeCreditAlphanum12(value) => {
                AssetType::AssetTypeCreditAlphanum12.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ChangeTrustAsset::AssetTypePoolShare(value) => {
                AssetType::AssetTypePoolShare.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match AssetType::from_xdr_buffered(read_stream)? {
            AssetType::AssetTypeNative => Ok(ChangeTrustAsset::AssetTypeNative),
            AssetType::AssetTypeCreditAlphanum4 =>
                Ok(ChangeTrustAsset::AssetTypeCreditAlphanum4(AlphaNum4::from_xdr_buffered(read_stream)?)),
            AssetType::AssetTypeCreditAlphanum12 =>
                Ok(ChangeTrustAsset::AssetTypeCreditAlphanum12(AlphaNum12::from_xdr_buffered(read_stream)?)),
            AssetType::AssetTypePoolShare =>
                Ok(ChangeTrustAsset::AssetTypePoolShare(LiquidityPoolParameters::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type RevokeSponsorshipOp
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum RevokeSponsorshipOp {
    RevokeSponsorshipLedgerEntry(LedgerKey),
    RevokeSponsorshipSigner(RevokeSponsorshipOpSigner),
}

impl XdrCodec for RevokeSponsorshipOp {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            RevokeSponsorshipOp::RevokeSponsorshipLedgerEntry(value) => {
                RevokeSponsorshipType::RevokeSponsorshipLedgerEntry.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            RevokeSponsorshipOp::RevokeSponsorshipSigner(value) => {
                RevokeSponsorshipType::RevokeSponsorshipSigner.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match RevokeSponsorshipType::from_xdr_buffered(read_stream)? {
            RevokeSponsorshipType::RevokeSponsorshipLedgerEntry =>
                Ok(RevokeSponsorshipOp::RevokeSponsorshipLedgerEntry(LedgerKey::from_xdr_buffered(read_stream)?)),
            RevokeSponsorshipType::RevokeSponsorshipSigner => Ok(RevokeSponsorshipOp::RevokeSponsorshipSigner(
                RevokeSponsorshipOpSigner::from_xdr_buffered(read_stream)?,
            )),
        }
    }
}

/// Autogenerated definition for type ContractIdPreimage
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ContractIdPreimage {
    ContractIdPreimageFromAddress(ContractIdPreimageFromAddress),
    ContractIdPreimageFromAsset(Asset),
}

impl XdrCodec for ContractIdPreimage {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ContractIdPreimage::ContractIdPreimageFromAddress(value) => {
                ContractIdPreimageType::ContractIdPreimageFromAddress.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ContractIdPreimage::ContractIdPreimageFromAsset(value) => {
                ContractIdPreimageType::ContractIdPreimageFromAsset.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match ContractIdPreimageType::from_xdr_buffered(read_stream)? {
            ContractIdPreimageType::ContractIdPreimageFromAddress =>
                Ok(ContractIdPreimage::ContractIdPreimageFromAddress(ContractIdPreimageFromAddress::from_xdr_buffered(
                    read_stream,
                )?)),
            ContractIdPreimageType::ContractIdPreimageFromAsset =>
                Ok(ContractIdPreimage::ContractIdPreimageFromAsset(Asset::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type HostFunction
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum HostFunction {
    HostFunctionTypeInvokeContract(InvokeContractArgs),
    HostFunctionTypeCreateContract(CreateContractArgs),
    HostFunctionTypeUploadContractWasm(UnlimitedVarOpaque),
}

impl XdrCodec for HostFunction {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            HostFunction::HostFunctionTypeInvokeContract(value) => {
                HostFunctionType::HostFunctionTypeInvokeContract.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            HostFunction::HostFunctionTypeCreateContract(value) => {
                HostFunctionType::HostFunctionTypeCreateContract.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            HostFunction::HostFunctionTypeUploadContractWasm(value) => {
                HostFunctionType::HostFunctionTypeUploadContractWasm.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match HostFunctionType::from_xdr_buffered(read_stream)? {
            HostFunctionType::HostFunctionTypeInvokeContract =>
                Ok(HostFunction::HostFunctionTypeInvokeContract(InvokeContractArgs::from_xdr_buffered(read_stream)?)),
            HostFunctionType::HostFunctionTypeCreateContract =>
                Ok(HostFunction::HostFunctionTypeCreateContract(CreateContractArgs::from_xdr_buffered(read_stream)?)),
            HostFunctionType::HostFunctionTypeUploadContractWasm => Ok(
                HostFunction::HostFunctionTypeUploadContractWasm(UnlimitedVarOpaque::from_xdr_buffered(read_stream)?),
            ),
        }
    }
}

/// Autogenerated definition for type SorobanAuthorizedFunction
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum SorobanAuthorizedFunction {
    SorobanAuthorizedFunctionTypeContractFn(InvokeContractArgs),
    SorobanAuthorizedFunctionTypeCreateContractHostFn(CreateContractArgs),
}

impl XdrCodec for SorobanAuthorizedFunction {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            SorobanAuthorizedFunction::SorobanAuthorizedFunctionTypeContractFn(value) => {
                SorobanAuthorizedFunctionType::SorobanAuthorizedFunctionTypeContractFn.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            SorobanAuthorizedFunction::SorobanAuthorizedFunctionTypeCreateContractHostFn(value) => {
                SorobanAuthorizedFunctionType::SorobanAuthorizedFunctionTypeCreateContractHostFn
                    .to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match SorobanAuthorizedFunctionType::from_xdr_buffered(read_stream)? {
            SorobanAuthorizedFunctionType::SorobanAuthorizedFunctionTypeContractFn =>
                Ok(SorobanAuthorizedFunction::SorobanAuthorizedFunctionTypeContractFn(
                    InvokeContractArgs::from_xdr_buffered(read_stream)?,
                )),
            SorobanAuthorizedFunctionType::SorobanAuthorizedFunctionTypeCreateContractHostFn =>
                Ok(SorobanAuthorizedFunction::SorobanAuthorizedFunctionTypeCreateContractHostFn(
                    CreateContractArgs::from_xdr_buffered(read_stream)?,
                )),
        }
    }
}

/// Autogenerated definition for type SorobanCredentials
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum SorobanCredentials {
    SorobanCredentialsSourceAccount,
    SorobanCredentialsAddress(SorobanAddressCredentials),
}

impl XdrCodec for SorobanCredentials {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            SorobanCredentials::SorobanCredentialsSourceAccount =>
                SorobanCredentialsType::SorobanCredentialsSourceAccount.to_xdr_buffered(write_stream),
            SorobanCredentials::SorobanCredentialsAddress(value) => {
                SorobanCredentialsType::SorobanCredentialsAddress.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match SorobanCredentialsType::from_xdr_buffered(read_stream)? {
            SorobanCredentialsType::SorobanCredentialsSourceAccount =>
                Ok(SorobanCredentials::SorobanCredentialsSourceAccount),
            SorobanCredentialsType::SorobanCredentialsAddress => Ok(SorobanCredentials::SorobanCredentialsAddress(
                SorobanAddressCredentials::from_xdr_buffered(read_stream)?,
            )),
        }
    }
}

/// Autogenerated definition for type OperationBody
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum OperationBody {
    CreateAccount(CreateAccountOp),
    Payment(PaymentOp),
    PathPaymentStrictReceive(PathPaymentStrictReceiveOp),
    ManageSellOffer(ManageSellOfferOp),
    CreatePassiveSellOffer(CreatePassiveSellOfferOp),
    SetOptions(SetOptionsOp),
    ChangeTrust(ChangeTrustOp),
    AllowTrust(AllowTrustOp),
    AccountMerge(MuxedAccount),
    Inflation,
    ManageData(ManageDataOp),
    BumpSequence(BumpSequenceOp),
    ManageBuyOffer(ManageBuyOfferOp),
    PathPaymentStrictSend(PathPaymentStrictSendOp),
    CreateClaimableBalance(CreateClaimableBalanceOp),
    ClaimClaimableBalance(ClaimClaimableBalanceOp),
    BeginSponsoringFutureReserves(BeginSponsoringFutureReservesOp),
    EndSponsoringFutureReserves,
    RevokeSponsorship(RevokeSponsorshipOp),
    Clawback(ClawbackOp),
    ClawbackClaimableBalance(ClawbackClaimableBalanceOp),
    SetTrustLineFlags(SetTrustLineFlagsOp),
    LiquidityPoolDeposit(LiquidityPoolDepositOp),
    LiquidityPoolWithdraw(LiquidityPoolWithdrawOp),
    InvokeHostFunction(InvokeHostFunctionOp),
    ExtendFootprintTtl(ExtendFootprintTtlOp),
    RestoreFootprint(RestoreFootprintOp),
}

impl XdrCodec for OperationBody {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            OperationBody::CreateAccount(value) => {
                OperationType::CreateAccount.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationBody::Payment(value) => {
                OperationType::Payment.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationBody::PathPaymentStrictReceive(value) => {
                OperationType::PathPaymentStrictReceive.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationBody::ManageSellOffer(value) => {
                OperationType::ManageSellOffer.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationBody::CreatePassiveSellOffer(value) => {
                OperationType::CreatePassiveSellOffer.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationBody::SetOptions(value) => {
                OperationType::SetOptions.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationBody::ChangeTrust(value) => {
                OperationType::ChangeTrust.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationBody::AllowTrust(value) => {
                OperationType::AllowTrust.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationBody::AccountMerge(value) => {
                OperationType::AccountMerge.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationBody::Inflation => OperationType::Inflation.to_xdr_buffered(write_stream),
            OperationBody::ManageData(value) => {
                OperationType::ManageData.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationBody::BumpSequence(value) => {
                OperationType::BumpSequence.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationBody::ManageBuyOffer(value) => {
                OperationType::ManageBuyOffer.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationBody::PathPaymentStrictSend(value) => {
                OperationType::PathPaymentStrictSend.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationBody::CreateClaimableBalance(value) => {
                OperationType::CreateClaimableBalance.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationBody::ClaimClaimableBalance(value) => {
                OperationType::ClaimClaimableBalance.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationBody::BeginSponsoringFutureReserves(value) => {
                OperationType::BeginSponsoringFutureReserves.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationBody::EndSponsoringFutureReserves =>
                OperationType::EndSponsoringFutureReserves.to_xdr_buffered(write_stream),
            OperationBody::RevokeSponsorship(value) => {
                OperationType::RevokeSponsorship.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationBody::Clawback(value) => {
                OperationType::Clawback.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationBody::ClawbackClaimableBalance(value) => {
                OperationType::ClawbackClaimableBalance.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationBody::SetTrustLineFlags(value) => {
                OperationType::SetTrustLineFlags.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationBody::LiquidityPoolDeposit(value) => {
                OperationType::LiquidityPoolDeposit.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationBody::LiquidityPoolWithdraw(value) => {
                OperationType::LiquidityPoolWithdraw.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationBody::InvokeHostFunction(value) => {
                OperationType::InvokeHostFunction.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationBody::ExtendFootprintTtl(value) => {
                OperationType::ExtendFootprintTtl.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationBody::RestoreFootprint(value) => {
                OperationType::RestoreFootprint.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match OperationType::from_xdr_buffered(read_stream)? {
            OperationType::CreateAccount =>
                Ok(OperationBody::CreateAccount(CreateAccountOp::from_xdr_buffered(read_stream)?)),
            OperationType::Payment => Ok(OperationBody::Payment(PaymentOp::from_xdr_buffered(read_stream)?)),
            OperationType::PathPaymentStrictReceive =>
                Ok(OperationBody::PathPaymentStrictReceive(PathPaymentStrictReceiveOp::from_xdr_buffered(read_stream)?)),
            OperationType::ManageSellOffer =>
                Ok(OperationBody::ManageSellOffer(ManageSellOfferOp::from_xdr_buffered(read_stream)?)),
            OperationType::CreatePassiveSellOffer =>
                Ok(OperationBody::CreatePassiveSellOffer(CreatePassiveSellOfferOp::from_xdr_buffered(read_stream)?)),
            OperationType::SetOptions => Ok(OperationBody::SetOptions(SetOptionsOp::from_xdr_buffered(read_stream)?)),
            OperationType::ChangeTrust =>
                Ok(OperationBody::ChangeTrust(ChangeTrustOp::from_xdr_buffered(read_stream)?)),
            OperationType::AllowTrust => Ok(OperationBody::AllowTrust(AllowTrustOp::from_xdr_buffered(read_stream)?)),
            OperationType::AccountMerge =>
                Ok(OperationBody::AccountMerge(MuxedAccount::from_xdr_buffered(read_stream)?)),
            OperationType::Inflation => Ok(OperationBody::Inflation),
            OperationType::ManageData => Ok(OperationBody::ManageData(ManageDataOp::from_xdr_buffered(read_stream)?)),
            OperationType::BumpSequence =>
                Ok(OperationBody::BumpSequence(BumpSequenceOp::from_xdr_buffered(read_stream)?)),
            OperationType::ManageBuyOffer =>
                Ok(OperationBody::ManageBuyOffer(ManageBuyOfferOp::from_xdr_buffered(read_stream)?)),
            OperationType::PathPaymentStrictSend =>
                Ok(OperationBody::PathPaymentStrictSend(PathPaymentStrictSendOp::from_xdr_buffered(read_stream)?)),
            OperationType::CreateClaimableBalance =>
                Ok(OperationBody::CreateClaimableBalance(CreateClaimableBalanceOp::from_xdr_buffered(read_stream)?)),
            OperationType::ClaimClaimableBalance =>
                Ok(OperationBody::ClaimClaimableBalance(ClaimClaimableBalanceOp::from_xdr_buffered(read_stream)?)),
            OperationType::BeginSponsoringFutureReserves => Ok(OperationBody::BeginSponsoringFutureReserves(
                BeginSponsoringFutureReservesOp::from_xdr_buffered(read_stream)?,
            )),
            OperationType::EndSponsoringFutureReserves => Ok(OperationBody::EndSponsoringFutureReserves),
            OperationType::RevokeSponsorship =>
                Ok(OperationBody::RevokeSponsorship(RevokeSponsorshipOp::from_xdr_buffered(read_stream)?)),
            OperationType::Clawback => Ok(OperationBody::Clawback(ClawbackOp::from_xdr_buffered(read_stream)?)),
            OperationType::ClawbackClaimableBalance =>
                Ok(OperationBody::ClawbackClaimableBalance(ClawbackClaimableBalanceOp::from_xdr_buffered(read_stream)?)),
            OperationType::SetTrustLineFlags =>
                Ok(OperationBody::SetTrustLineFlags(SetTrustLineFlagsOp::from_xdr_buffered(read_stream)?)),
            OperationType::LiquidityPoolDeposit =>
                Ok(OperationBody::LiquidityPoolDeposit(LiquidityPoolDepositOp::from_xdr_buffered(read_stream)?)),
            OperationType::LiquidityPoolWithdraw =>
                Ok(OperationBody::LiquidityPoolWithdraw(LiquidityPoolWithdrawOp::from_xdr_buffered(read_stream)?)),
            OperationType::InvokeHostFunction =>
                Ok(OperationBody::InvokeHostFunction(InvokeHostFunctionOp::from_xdr_buffered(read_stream)?)),
            OperationType::ExtendFootprintTtl =>
                Ok(OperationBody::ExtendFootprintTtl(ExtendFootprintTtlOp::from_xdr_buffered(read_stream)?)),
            OperationType::RestoreFootprint =>
                Ok(OperationBody::RestoreFootprint(RestoreFootprintOp::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type HashIdPreimage
#[allow(dead_code)]
#[cfg(feature = "all-types")]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum HashIdPreimage {
    EnvelopeTypeOpId(HashIdPreimageOperationId),
    EnvelopeTypePoolRevokeOpId(HashIdPreimageRevokeId),
    EnvelopeTypeContractId(HashIdPreimageContractId),
    EnvelopeTypeSorobanAuthorization(HashIdPreimageSorobanAuthorization),
    Default(EnvelopeType),
}

#[cfg(feature = "all-types")]
impl XdrCodec for HashIdPreimage {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            HashIdPreimage::EnvelopeTypeOpId(value) => {
                EnvelopeType::EnvelopeTypeOpId.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            HashIdPreimage::EnvelopeTypePoolRevokeOpId(value) => {
                EnvelopeType::EnvelopeTypePoolRevokeOpId.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            HashIdPreimage::EnvelopeTypeContractId(value) => {
                EnvelopeType::EnvelopeTypeContractId.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            HashIdPreimage::EnvelopeTypeSorobanAuthorization(value) => {
                EnvelopeType::EnvelopeTypeSorobanAuthorization.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            HashIdPreimage::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match EnvelopeType::from_xdr_buffered(read_stream)? {
            EnvelopeType::EnvelopeTypeOpId =>
                Ok(HashIdPreimage::EnvelopeTypeOpId(HashIdPreimageOperationId::from_xdr_buffered(read_stream)?)),
            EnvelopeType::EnvelopeTypePoolRevokeOpId =>
                Ok(HashIdPreimage::EnvelopeTypePoolRevokeOpId(HashIdPreimageRevokeId::from_xdr_buffered(read_stream)?)),
            EnvelopeType::EnvelopeTypeContractId =>
                Ok(HashIdPreimage::EnvelopeTypeContractId(HashIdPreimageContractId::from_xdr_buffered(read_stream)?)),
            EnvelopeType::EnvelopeTypeSorobanAuthorization => Ok(HashIdPreimage::EnvelopeTypeSorobanAuthorization(
                HashIdPreimageSorobanAuthorization::from_xdr_buffered(read_stream)?,
            )),
            code => Ok(HashIdPreimage::Default(code)),
        }
    }
}

/// Autogenerated definition for type Memo
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum Memo {
    MemoNone,
    MemoText(LimitedString<28>),
    MemoId(Uint64),
    MemoHash(Hash),
    MemoReturn(Hash),
}

impl XdrCodec for Memo {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            Memo::MemoNone => MemoType::MemoNone.to_xdr_buffered(write_stream),
            Memo::MemoText(value) => {
                MemoType::MemoText.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            Memo::MemoId(value) => {
                MemoType::MemoId.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            Memo::MemoHash(value) => {
                MemoType::MemoHash.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            Memo::MemoReturn(value) => {
                MemoType::MemoReturn.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match MemoType::from_xdr_buffered(read_stream)? {
            MemoType::MemoNone => Ok(Memo::MemoNone),
            MemoType::MemoText => Ok(Memo::MemoText(LimitedString::<28>::from_xdr_buffered(read_stream)?)),
            MemoType::MemoId => Ok(Memo::MemoId(Uint64::from_xdr_buffered(read_stream)?)),
            MemoType::MemoHash => Ok(Memo::MemoHash(Hash::from_xdr_buffered(read_stream)?)),
            MemoType::MemoReturn => Ok(Memo::MemoReturn(Hash::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type Preconditions
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum Preconditions {
    PrecondNone,
    PrecondTime(TimeBounds),
    PrecondV2(PreconditionsV2),
}

impl XdrCodec for Preconditions {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            Preconditions::PrecondNone => PreconditionType::PrecondNone.to_xdr_buffered(write_stream),
            Preconditions::PrecondTime(value) => {
                PreconditionType::PrecondTime.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            Preconditions::PrecondV2(value) => {
                PreconditionType::PrecondV2.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match PreconditionType::from_xdr_buffered(read_stream)? {
            PreconditionType::PrecondNone => Ok(Preconditions::PrecondNone),
            PreconditionType::PrecondTime =>
                Ok(Preconditions::PrecondTime(TimeBounds::from_xdr_buffered(read_stream)?)),
            PreconditionType::PrecondV2 =>
                Ok(Preconditions::PrecondV2(PreconditionsV2::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type TransactionV0Ext
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum TransactionV0Ext {
    V0,
    Default(i32),
}

impl XdrCodec for TransactionV0Ext {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            TransactionV0Ext::V0 => (0 as i32).to_xdr_buffered(write_stream),
            TransactionV0Ext::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(TransactionV0Ext::V0),
            code => Ok(TransactionV0Ext::Default(code)),
        }
    }
}

/// Autogenerated definition for type TransactionExt
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum TransactionExt {
    V0,
    V1(SorobanTransactionData),
    Default(i32),
}

impl XdrCodec for TransactionExt {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            TransactionExt::V0 => (0 as i32).to_xdr_buffered(write_stream),
            TransactionExt::V1(value) => {
                (1 as i32).to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            TransactionExt::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(TransactionExt::V0),
            1 => Ok(TransactionExt::V1(SorobanTransactionData::from_xdr_buffered(read_stream)?)),
            code => Ok(TransactionExt::Default(code)),
        }
    }
}

/// Autogenerated definition for type FeeBumpTransactionInnerTx
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum FeeBumpTransactionInnerTx {
    EnvelopeTypeTx(TransactionV1Envelope),
    Default(EnvelopeType),
}

impl XdrCodec for FeeBumpTransactionInnerTx {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            FeeBumpTransactionInnerTx::EnvelopeTypeTx(value) => {
                EnvelopeType::EnvelopeTypeTx.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            FeeBumpTransactionInnerTx::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match EnvelopeType::from_xdr_buffered(read_stream)? {
            EnvelopeType::EnvelopeTypeTx =>
                Ok(FeeBumpTransactionInnerTx::EnvelopeTypeTx(TransactionV1Envelope::from_xdr_buffered(read_stream)?)),
            code => Ok(FeeBumpTransactionInnerTx::Default(code)),
        }
    }
}

/// Autogenerated definition for type FeeBumpTransactionExt
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum FeeBumpTransactionExt {
    V0,
    Default(i32),
}

impl XdrCodec for FeeBumpTransactionExt {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            FeeBumpTransactionExt::V0 => (0 as i32).to_xdr_buffered(write_stream),
            FeeBumpTransactionExt::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(FeeBumpTransactionExt::V0),
            code => Ok(FeeBumpTransactionExt::Default(code)),
        }
    }
}

/// Autogenerated definition for type TransactionEnvelope
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum TransactionEnvelope {
    EnvelopeTypeTxV0(TransactionV0Envelope),
    EnvelopeTypeTx(TransactionV1Envelope),
    EnvelopeTypeTxFeeBump(FeeBumpTransactionEnvelope),
    Default(EnvelopeType),
}

impl XdrCodec for TransactionEnvelope {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            TransactionEnvelope::EnvelopeTypeTxV0(value) => {
                EnvelopeType::EnvelopeTypeTxV0.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            TransactionEnvelope::EnvelopeTypeTx(value) => {
                EnvelopeType::EnvelopeTypeTx.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            TransactionEnvelope::EnvelopeTypeTxFeeBump(value) => {
                EnvelopeType::EnvelopeTypeTxFeeBump.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            TransactionEnvelope::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match EnvelopeType::from_xdr_buffered(read_stream)? {
            EnvelopeType::EnvelopeTypeTxV0 =>
                Ok(TransactionEnvelope::EnvelopeTypeTxV0(TransactionV0Envelope::from_xdr_buffered(read_stream)?)),
            EnvelopeType::EnvelopeTypeTx =>
                Ok(TransactionEnvelope::EnvelopeTypeTx(TransactionV1Envelope::from_xdr_buffered(read_stream)?)),
            EnvelopeType::EnvelopeTypeTxFeeBump => Ok(TransactionEnvelope::EnvelopeTypeTxFeeBump(
                FeeBumpTransactionEnvelope::from_xdr_buffered(read_stream)?,
            )),
            code => Ok(TransactionEnvelope::Default(code)),
        }
    }
}

/// Autogenerated definition for type TransactionSignaturePayloadTaggedTransaction
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum TransactionSignaturePayloadTaggedTransaction {
    EnvelopeTypeTx(Transaction),
    EnvelopeTypeTxFeeBump(FeeBumpTransaction),
    Default(EnvelopeType),
}

impl XdrCodec for TransactionSignaturePayloadTaggedTransaction {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            TransactionSignaturePayloadTaggedTransaction::EnvelopeTypeTx(value) => {
                EnvelopeType::EnvelopeTypeTx.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            TransactionSignaturePayloadTaggedTransaction::EnvelopeTypeTxFeeBump(value) => {
                EnvelopeType::EnvelopeTypeTxFeeBump.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            TransactionSignaturePayloadTaggedTransaction::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match EnvelopeType::from_xdr_buffered(read_stream)? {
            EnvelopeType::EnvelopeTypeTx => Ok(TransactionSignaturePayloadTaggedTransaction::EnvelopeTypeTx(
                Transaction::from_xdr_buffered(read_stream)?,
            )),
            EnvelopeType::EnvelopeTypeTxFeeBump =>
                Ok(TransactionSignaturePayloadTaggedTransaction::EnvelopeTypeTxFeeBump(
                    FeeBumpTransaction::from_xdr_buffered(read_stream)?,
                )),
            code => Ok(TransactionSignaturePayloadTaggedTransaction::Default(code)),
        }
    }
}

/// Autogenerated definition for type ClaimAtom
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ClaimAtom {
    ClaimAtomTypeV0(ClaimOfferAtomV0),
    ClaimAtomTypeOrderBook(ClaimOfferAtom),
    ClaimAtomTypeLiquidityPool(ClaimLiquidityAtom),
}

impl XdrCodec for ClaimAtom {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ClaimAtom::ClaimAtomTypeV0(value) => {
                ClaimAtomType::ClaimAtomTypeV0.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ClaimAtom::ClaimAtomTypeOrderBook(value) => {
                ClaimAtomType::ClaimAtomTypeOrderBook.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ClaimAtom::ClaimAtomTypeLiquidityPool(value) => {
                ClaimAtomType::ClaimAtomTypeLiquidityPool.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match ClaimAtomType::from_xdr_buffered(read_stream)? {
            ClaimAtomType::ClaimAtomTypeV0 =>
                Ok(ClaimAtom::ClaimAtomTypeV0(ClaimOfferAtomV0::from_xdr_buffered(read_stream)?)),
            ClaimAtomType::ClaimAtomTypeOrderBook =>
                Ok(ClaimAtom::ClaimAtomTypeOrderBook(ClaimOfferAtom::from_xdr_buffered(read_stream)?)),
            ClaimAtomType::ClaimAtomTypeLiquidityPool =>
                Ok(ClaimAtom::ClaimAtomTypeLiquidityPool(ClaimLiquidityAtom::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type CreateAccountResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum CreateAccountResult {
    CreateAccountSuccess,
    CreateAccountMalformed,
    CreateAccountUnderfunded,
    CreateAccountLowReserve,
    CreateAccountAlreadyExist,
}

impl XdrCodec for CreateAccountResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            CreateAccountResult::CreateAccountSuccess =>
                CreateAccountResultCode::CreateAccountSuccess.to_xdr_buffered(write_stream),
            CreateAccountResult::CreateAccountMalformed =>
                CreateAccountResultCode::CreateAccountMalformed.to_xdr_buffered(write_stream),
            CreateAccountResult::CreateAccountUnderfunded =>
                CreateAccountResultCode::CreateAccountUnderfunded.to_xdr_buffered(write_stream),
            CreateAccountResult::CreateAccountLowReserve =>
                CreateAccountResultCode::CreateAccountLowReserve.to_xdr_buffered(write_stream),
            CreateAccountResult::CreateAccountAlreadyExist =>
                CreateAccountResultCode::CreateAccountAlreadyExist.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match CreateAccountResultCode::from_xdr_buffered(read_stream)? {
            CreateAccountResultCode::CreateAccountSuccess => Ok(CreateAccountResult::CreateAccountSuccess),
            CreateAccountResultCode::CreateAccountMalformed => Ok(CreateAccountResult::CreateAccountMalformed),
            CreateAccountResultCode::CreateAccountUnderfunded => Ok(CreateAccountResult::CreateAccountUnderfunded),
            CreateAccountResultCode::CreateAccountLowReserve => Ok(CreateAccountResult::CreateAccountLowReserve),
            CreateAccountResultCode::CreateAccountAlreadyExist => Ok(CreateAccountResult::CreateAccountAlreadyExist),
        }
    }
}

/// Autogenerated definition for type PaymentResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum PaymentResult {
    PaymentSuccess,
    PaymentMalformed,
    PaymentUnderfunded,
    PaymentSrcNoTrust,
    PaymentSrcNotAuthorized,
    PaymentNoDestination,
    PaymentNoTrust,
    PaymentNotAuthorized,
    PaymentLineFull,
    PaymentNoIssuer,
}

impl XdrCodec for PaymentResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            PaymentResult::PaymentSuccess => PaymentResultCode::PaymentSuccess.to_xdr_buffered(write_stream),
            PaymentResult::PaymentMalformed => PaymentResultCode::PaymentMalformed.to_xdr_buffered(write_stream),
            PaymentResult::PaymentUnderfunded => PaymentResultCode::PaymentUnderfunded.to_xdr_buffered(write_stream),
            PaymentResult::PaymentSrcNoTrust => PaymentResultCode::PaymentSrcNoTrust.to_xdr_buffered(write_stream),
            PaymentResult::PaymentSrcNotAuthorized =>
                PaymentResultCode::PaymentSrcNotAuthorized.to_xdr_buffered(write_stream),
            PaymentResult::PaymentNoDestination =>
                PaymentResultCode::PaymentNoDestination.to_xdr_buffered(write_stream),
            PaymentResult::PaymentNoTrust => PaymentResultCode::PaymentNoTrust.to_xdr_buffered(write_stream),
            PaymentResult::PaymentNotAuthorized =>
                PaymentResultCode::PaymentNotAuthorized.to_xdr_buffered(write_stream),
            PaymentResult::PaymentLineFull => PaymentResultCode::PaymentLineFull.to_xdr_buffered(write_stream),
            PaymentResult::PaymentNoIssuer => PaymentResultCode::PaymentNoIssuer.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match PaymentResultCode::from_xdr_buffered(read_stream)? {
            PaymentResultCode::PaymentSuccess => Ok(PaymentResult::PaymentSuccess),
            PaymentResultCode::PaymentMalformed => Ok(PaymentResult::PaymentMalformed),
            PaymentResultCode::PaymentUnderfunded => Ok(PaymentResult::PaymentUnderfunded),
            PaymentResultCode::PaymentSrcNoTrust => Ok(PaymentResult::PaymentSrcNoTrust),
            PaymentResultCode::PaymentSrcNotAuthorized => Ok(PaymentResult::PaymentSrcNotAuthorized),
            PaymentResultCode::PaymentNoDestination => Ok(PaymentResult::PaymentNoDestination),
            PaymentResultCode::PaymentNoTrust => Ok(PaymentResult::PaymentNoTrust),
            PaymentResultCode::PaymentNotAuthorized => Ok(PaymentResult::PaymentNotAuthorized),
            PaymentResultCode::PaymentLineFull => Ok(PaymentResult::PaymentLineFull),
            PaymentResultCode::PaymentNoIssuer => Ok(PaymentResult::PaymentNoIssuer),
        }
    }
}

/// Autogenerated definition for type PathPaymentStrictReceiveResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum PathPaymentStrictReceiveResult {
    PathPaymentStrictReceiveSuccess(PathPaymentStrictReceiveResultSuccess),
    PathPaymentStrictReceiveMalformed,
    PathPaymentStrictReceiveUnderfunded,
    PathPaymentStrictReceiveSrcNoTrust,
    PathPaymentStrictReceiveSrcNotAuthorized,
    PathPaymentStrictReceiveNoDestination,
    PathPaymentStrictReceiveNoTrust,
    PathPaymentStrictReceiveNotAuthorized,
    PathPaymentStrictReceiveLineFull,
    PathPaymentStrictReceiveNoIssuer(Asset),
    PathPaymentStrictReceiveTooFewOffers,
    PathPaymentStrictReceiveOfferCrossSelf,
    PathPaymentStrictReceiveOverSendmax,
}

impl XdrCodec for PathPaymentStrictReceiveResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            PathPaymentStrictReceiveResult::PathPaymentStrictReceiveSuccess(value) => {
                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveSuccess.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            PathPaymentStrictReceiveResult::PathPaymentStrictReceiveMalformed =>
                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveMalformed.to_xdr_buffered(write_stream),
            PathPaymentStrictReceiveResult::PathPaymentStrictReceiveUnderfunded =>
                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveUnderfunded.to_xdr_buffered(write_stream),
            PathPaymentStrictReceiveResult::PathPaymentStrictReceiveSrcNoTrust =>
                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveSrcNoTrust.to_xdr_buffered(write_stream),
            PathPaymentStrictReceiveResult::PathPaymentStrictReceiveSrcNotAuthorized =>
                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveSrcNotAuthorized
                    .to_xdr_buffered(write_stream),
            PathPaymentStrictReceiveResult::PathPaymentStrictReceiveNoDestination =>
                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNoDestination.to_xdr_buffered(write_stream),
            PathPaymentStrictReceiveResult::PathPaymentStrictReceiveNoTrust =>
                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNoTrust.to_xdr_buffered(write_stream),
            PathPaymentStrictReceiveResult::PathPaymentStrictReceiveNotAuthorized =>
                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNotAuthorized.to_xdr_buffered(write_stream),
            PathPaymentStrictReceiveResult::PathPaymentStrictReceiveLineFull =>
                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveLineFull.to_xdr_buffered(write_stream),
            PathPaymentStrictReceiveResult::PathPaymentStrictReceiveNoIssuer(value) => {
                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNoIssuer.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            PathPaymentStrictReceiveResult::PathPaymentStrictReceiveTooFewOffers =>
                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveTooFewOffers.to_xdr_buffered(write_stream),
            PathPaymentStrictReceiveResult::PathPaymentStrictReceiveOfferCrossSelf =>
                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveOfferCrossSelf.to_xdr_buffered(write_stream),
            PathPaymentStrictReceiveResult::PathPaymentStrictReceiveOverSendmax =>
                PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveOverSendmax.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match PathPaymentStrictReceiveResultCode::from_xdr_buffered(read_stream)? {
            PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveSuccess =>
                Ok(PathPaymentStrictReceiveResult::PathPaymentStrictReceiveSuccess(
                    PathPaymentStrictReceiveResultSuccess::from_xdr_buffered(read_stream)?,
                )),
            PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveMalformed =>
                Ok(PathPaymentStrictReceiveResult::PathPaymentStrictReceiveMalformed),
            PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveUnderfunded =>
                Ok(PathPaymentStrictReceiveResult::PathPaymentStrictReceiveUnderfunded),
            PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveSrcNoTrust =>
                Ok(PathPaymentStrictReceiveResult::PathPaymentStrictReceiveSrcNoTrust),
            PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveSrcNotAuthorized =>
                Ok(PathPaymentStrictReceiveResult::PathPaymentStrictReceiveSrcNotAuthorized),
            PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNoDestination =>
                Ok(PathPaymentStrictReceiveResult::PathPaymentStrictReceiveNoDestination),
            PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNoTrust =>
                Ok(PathPaymentStrictReceiveResult::PathPaymentStrictReceiveNoTrust),
            PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNotAuthorized =>
                Ok(PathPaymentStrictReceiveResult::PathPaymentStrictReceiveNotAuthorized),
            PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveLineFull =>
                Ok(PathPaymentStrictReceiveResult::PathPaymentStrictReceiveLineFull),
            PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveNoIssuer =>
                Ok(PathPaymentStrictReceiveResult::PathPaymentStrictReceiveNoIssuer(Asset::from_xdr_buffered(
                    read_stream,
                )?)),
            PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveTooFewOffers =>
                Ok(PathPaymentStrictReceiveResult::PathPaymentStrictReceiveTooFewOffers),
            PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveOfferCrossSelf =>
                Ok(PathPaymentStrictReceiveResult::PathPaymentStrictReceiveOfferCrossSelf),
            PathPaymentStrictReceiveResultCode::PathPaymentStrictReceiveOverSendmax =>
                Ok(PathPaymentStrictReceiveResult::PathPaymentStrictReceiveOverSendmax),
        }
    }
}

/// Autogenerated definition for type PathPaymentStrictSendResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum PathPaymentStrictSendResult {
    PathPaymentStrictSendSuccess(PathPaymentStrictSendResultSuccess),
    PathPaymentStrictSendMalformed,
    PathPaymentStrictSendUnderfunded,
    PathPaymentStrictSendSrcNoTrust,
    PathPaymentStrictSendSrcNotAuthorized,
    PathPaymentStrictSendNoDestination,
    PathPaymentStrictSendNoTrust,
    PathPaymentStrictSendNotAuthorized,
    PathPaymentStrictSendLineFull,
    PathPaymentStrictSendNoIssuer(Asset),
    PathPaymentStrictSendTooFewOffers,
    PathPaymentStrictSendOfferCrossSelf,
    PathPaymentStrictSendUnderDestmin,
}

impl XdrCodec for PathPaymentStrictSendResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            PathPaymentStrictSendResult::PathPaymentStrictSendSuccess(value) => {
                PathPaymentStrictSendResultCode::PathPaymentStrictSendSuccess.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            PathPaymentStrictSendResult::PathPaymentStrictSendMalformed =>
                PathPaymentStrictSendResultCode::PathPaymentStrictSendMalformed.to_xdr_buffered(write_stream),
            PathPaymentStrictSendResult::PathPaymentStrictSendUnderfunded =>
                PathPaymentStrictSendResultCode::PathPaymentStrictSendUnderfunded.to_xdr_buffered(write_stream),
            PathPaymentStrictSendResult::PathPaymentStrictSendSrcNoTrust =>
                PathPaymentStrictSendResultCode::PathPaymentStrictSendSrcNoTrust.to_xdr_buffered(write_stream),
            PathPaymentStrictSendResult::PathPaymentStrictSendSrcNotAuthorized =>
                PathPaymentStrictSendResultCode::PathPaymentStrictSendSrcNotAuthorized.to_xdr_buffered(write_stream),
            PathPaymentStrictSendResult::PathPaymentStrictSendNoDestination =>
                PathPaymentStrictSendResultCode::PathPaymentStrictSendNoDestination.to_xdr_buffered(write_stream),
            PathPaymentStrictSendResult::PathPaymentStrictSendNoTrust =>
                PathPaymentStrictSendResultCode::PathPaymentStrictSendNoTrust.to_xdr_buffered(write_stream),
            PathPaymentStrictSendResult::PathPaymentStrictSendNotAuthorized =>
                PathPaymentStrictSendResultCode::PathPaymentStrictSendNotAuthorized.to_xdr_buffered(write_stream),
            PathPaymentStrictSendResult::PathPaymentStrictSendLineFull =>
                PathPaymentStrictSendResultCode::PathPaymentStrictSendLineFull.to_xdr_buffered(write_stream),
            PathPaymentStrictSendResult::PathPaymentStrictSendNoIssuer(value) => {
                PathPaymentStrictSendResultCode::PathPaymentStrictSendNoIssuer.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            PathPaymentStrictSendResult::PathPaymentStrictSendTooFewOffers =>
                PathPaymentStrictSendResultCode::PathPaymentStrictSendTooFewOffers.to_xdr_buffered(write_stream),
            PathPaymentStrictSendResult::PathPaymentStrictSendOfferCrossSelf =>
                PathPaymentStrictSendResultCode::PathPaymentStrictSendOfferCrossSelf.to_xdr_buffered(write_stream),
            PathPaymentStrictSendResult::PathPaymentStrictSendUnderDestmin =>
                PathPaymentStrictSendResultCode::PathPaymentStrictSendUnderDestmin.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match PathPaymentStrictSendResultCode::from_xdr_buffered(read_stream)? {
            PathPaymentStrictSendResultCode::PathPaymentStrictSendSuccess =>
                Ok(PathPaymentStrictSendResult::PathPaymentStrictSendSuccess(
                    PathPaymentStrictSendResultSuccess::from_xdr_buffered(read_stream)?,
                )),
            PathPaymentStrictSendResultCode::PathPaymentStrictSendMalformed =>
                Ok(PathPaymentStrictSendResult::PathPaymentStrictSendMalformed),
            PathPaymentStrictSendResultCode::PathPaymentStrictSendUnderfunded =>
                Ok(PathPaymentStrictSendResult::PathPaymentStrictSendUnderfunded),
            PathPaymentStrictSendResultCode::PathPaymentStrictSendSrcNoTrust =>
                Ok(PathPaymentStrictSendResult::PathPaymentStrictSendSrcNoTrust),
            PathPaymentStrictSendResultCode::PathPaymentStrictSendSrcNotAuthorized =>
                Ok(PathPaymentStrictSendResult::PathPaymentStrictSendSrcNotAuthorized),
            PathPaymentStrictSendResultCode::PathPaymentStrictSendNoDestination =>
                Ok(PathPaymentStrictSendResult::PathPaymentStrictSendNoDestination),
            PathPaymentStrictSendResultCode::PathPaymentStrictSendNoTrust =>
                Ok(PathPaymentStrictSendResult::PathPaymentStrictSendNoTrust),
            PathPaymentStrictSendResultCode::PathPaymentStrictSendNotAuthorized =>
                Ok(PathPaymentStrictSendResult::PathPaymentStrictSendNotAuthorized),
            PathPaymentStrictSendResultCode::PathPaymentStrictSendLineFull =>
                Ok(PathPaymentStrictSendResult::PathPaymentStrictSendLineFull),
            PathPaymentStrictSendResultCode::PathPaymentStrictSendNoIssuer =>
                Ok(PathPaymentStrictSendResult::PathPaymentStrictSendNoIssuer(Asset::from_xdr_buffered(read_stream)?)),
            PathPaymentStrictSendResultCode::PathPaymentStrictSendTooFewOffers =>
                Ok(PathPaymentStrictSendResult::PathPaymentStrictSendTooFewOffers),
            PathPaymentStrictSendResultCode::PathPaymentStrictSendOfferCrossSelf =>
                Ok(PathPaymentStrictSendResult::PathPaymentStrictSendOfferCrossSelf),
            PathPaymentStrictSendResultCode::PathPaymentStrictSendUnderDestmin =>
                Ok(PathPaymentStrictSendResult::PathPaymentStrictSendUnderDestmin),
        }
    }
}

/// Autogenerated definition for type ManageOfferSuccessResultOffer
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ManageOfferSuccessResultOffer {
    ManageOfferCreated(OfferEntry),
    ManageOfferUpdated(OfferEntry),
    ManageOfferDeleted,
}

impl XdrCodec for ManageOfferSuccessResultOffer {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ManageOfferSuccessResultOffer::ManageOfferCreated(value) => {
                ManageOfferEffect::ManageOfferCreated.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ManageOfferSuccessResultOffer::ManageOfferUpdated(value) => {
                ManageOfferEffect::ManageOfferUpdated.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ManageOfferSuccessResultOffer::ManageOfferDeleted =>
                ManageOfferEffect::ManageOfferDeleted.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match ManageOfferEffect::from_xdr_buffered(read_stream)? {
            ManageOfferEffect::ManageOfferCreated =>
                Ok(ManageOfferSuccessResultOffer::ManageOfferCreated(OfferEntry::from_xdr_buffered(read_stream)?)),
            ManageOfferEffect::ManageOfferUpdated =>
                Ok(ManageOfferSuccessResultOffer::ManageOfferUpdated(OfferEntry::from_xdr_buffered(read_stream)?)),
            ManageOfferEffect::ManageOfferDeleted => Ok(ManageOfferSuccessResultOffer::ManageOfferDeleted),
        }
    }
}

/// Autogenerated definition for type ManageSellOfferResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ManageSellOfferResult {
    ManageSellOfferSuccess(ManageOfferSuccessResult),
    ManageSellOfferMalformed,
    ManageSellOfferSellNoTrust,
    ManageSellOfferBuyNoTrust,
    ManageSellOfferSellNotAuthorized,
    ManageSellOfferBuyNotAuthorized,
    ManageSellOfferLineFull,
    ManageSellOfferUnderfunded,
    ManageSellOfferCrossSelf,
    ManageSellOfferSellNoIssuer,
    ManageSellOfferBuyNoIssuer,
    ManageSellOfferNotFound,
    ManageSellOfferLowReserve,
}

impl XdrCodec for ManageSellOfferResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ManageSellOfferResult::ManageSellOfferSuccess(value) => {
                ManageSellOfferResultCode::ManageSellOfferSuccess.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ManageSellOfferResult::ManageSellOfferMalformed =>
                ManageSellOfferResultCode::ManageSellOfferMalformed.to_xdr_buffered(write_stream),
            ManageSellOfferResult::ManageSellOfferSellNoTrust =>
                ManageSellOfferResultCode::ManageSellOfferSellNoTrust.to_xdr_buffered(write_stream),
            ManageSellOfferResult::ManageSellOfferBuyNoTrust =>
                ManageSellOfferResultCode::ManageSellOfferBuyNoTrust.to_xdr_buffered(write_stream),
            ManageSellOfferResult::ManageSellOfferSellNotAuthorized =>
                ManageSellOfferResultCode::ManageSellOfferSellNotAuthorized.to_xdr_buffered(write_stream),
            ManageSellOfferResult::ManageSellOfferBuyNotAuthorized =>
                ManageSellOfferResultCode::ManageSellOfferBuyNotAuthorized.to_xdr_buffered(write_stream),
            ManageSellOfferResult::ManageSellOfferLineFull =>
                ManageSellOfferResultCode::ManageSellOfferLineFull.to_xdr_buffered(write_stream),
            ManageSellOfferResult::ManageSellOfferUnderfunded =>
                ManageSellOfferResultCode::ManageSellOfferUnderfunded.to_xdr_buffered(write_stream),
            ManageSellOfferResult::ManageSellOfferCrossSelf =>
                ManageSellOfferResultCode::ManageSellOfferCrossSelf.to_xdr_buffered(write_stream),
            ManageSellOfferResult::ManageSellOfferSellNoIssuer =>
                ManageSellOfferResultCode::ManageSellOfferSellNoIssuer.to_xdr_buffered(write_stream),
            ManageSellOfferResult::ManageSellOfferBuyNoIssuer =>
                ManageSellOfferResultCode::ManageSellOfferBuyNoIssuer.to_xdr_buffered(write_stream),
            ManageSellOfferResult::ManageSellOfferNotFound =>
                ManageSellOfferResultCode::ManageSellOfferNotFound.to_xdr_buffered(write_stream),
            ManageSellOfferResult::ManageSellOfferLowReserve =>
                ManageSellOfferResultCode::ManageSellOfferLowReserve.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match ManageSellOfferResultCode::from_xdr_buffered(read_stream)? {
            ManageSellOfferResultCode::ManageSellOfferSuccess => Ok(ManageSellOfferResult::ManageSellOfferSuccess(
                ManageOfferSuccessResult::from_xdr_buffered(read_stream)?,
            )),
            ManageSellOfferResultCode::ManageSellOfferMalformed => Ok(ManageSellOfferResult::ManageSellOfferMalformed),
            ManageSellOfferResultCode::ManageSellOfferSellNoTrust =>
                Ok(ManageSellOfferResult::ManageSellOfferSellNoTrust),
            ManageSellOfferResultCode::ManageSellOfferBuyNoTrust =>
                Ok(ManageSellOfferResult::ManageSellOfferBuyNoTrust),
            ManageSellOfferResultCode::ManageSellOfferSellNotAuthorized =>
                Ok(ManageSellOfferResult::ManageSellOfferSellNotAuthorized),
            ManageSellOfferResultCode::ManageSellOfferBuyNotAuthorized =>
                Ok(ManageSellOfferResult::ManageSellOfferBuyNotAuthorized),
            ManageSellOfferResultCode::ManageSellOfferLineFull => Ok(ManageSellOfferResult::ManageSellOfferLineFull),
            ManageSellOfferResultCode::ManageSellOfferUnderfunded =>
                Ok(ManageSellOfferResult::ManageSellOfferUnderfunded),
            ManageSellOfferResultCode::ManageSellOfferCrossSelf => Ok(ManageSellOfferResult::ManageSellOfferCrossSelf),
            ManageSellOfferResultCode::ManageSellOfferSellNoIssuer =>
                Ok(ManageSellOfferResult::ManageSellOfferSellNoIssuer),
            ManageSellOfferResultCode::ManageSellOfferBuyNoIssuer =>
                Ok(ManageSellOfferResult::ManageSellOfferBuyNoIssuer),
            ManageSellOfferResultCode::ManageSellOfferNotFound => Ok(ManageSellOfferResult::ManageSellOfferNotFound),
            ManageSellOfferResultCode::ManageSellOfferLowReserve =>
                Ok(ManageSellOfferResult::ManageSellOfferLowReserve),
        }
    }
}

/// Autogenerated definition for type ManageBuyOfferResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ManageBuyOfferResult {
    ManageBuyOfferSuccess(ManageOfferSuccessResult),
    ManageBuyOfferMalformed,
    ManageBuyOfferSellNoTrust,
    ManageBuyOfferBuyNoTrust,
    ManageBuyOfferSellNotAuthorized,
    ManageBuyOfferBuyNotAuthorized,
    ManageBuyOfferLineFull,
    ManageBuyOfferUnderfunded,
    ManageBuyOfferCrossSelf,
    ManageBuyOfferSellNoIssuer,
    ManageBuyOfferBuyNoIssuer,
    ManageBuyOfferNotFound,
    ManageBuyOfferLowReserve,
}

impl XdrCodec for ManageBuyOfferResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ManageBuyOfferResult::ManageBuyOfferSuccess(value) => {
                ManageBuyOfferResultCode::ManageBuyOfferSuccess.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            ManageBuyOfferResult::ManageBuyOfferMalformed =>
                ManageBuyOfferResultCode::ManageBuyOfferMalformed.to_xdr_buffered(write_stream),
            ManageBuyOfferResult::ManageBuyOfferSellNoTrust =>
                ManageBuyOfferResultCode::ManageBuyOfferSellNoTrust.to_xdr_buffered(write_stream),
            ManageBuyOfferResult::ManageBuyOfferBuyNoTrust =>
                ManageBuyOfferResultCode::ManageBuyOfferBuyNoTrust.to_xdr_buffered(write_stream),
            ManageBuyOfferResult::ManageBuyOfferSellNotAuthorized =>
                ManageBuyOfferResultCode::ManageBuyOfferSellNotAuthorized.to_xdr_buffered(write_stream),
            ManageBuyOfferResult::ManageBuyOfferBuyNotAuthorized =>
                ManageBuyOfferResultCode::ManageBuyOfferBuyNotAuthorized.to_xdr_buffered(write_stream),
            ManageBuyOfferResult::ManageBuyOfferLineFull =>
                ManageBuyOfferResultCode::ManageBuyOfferLineFull.to_xdr_buffered(write_stream),
            ManageBuyOfferResult::ManageBuyOfferUnderfunded =>
                ManageBuyOfferResultCode::ManageBuyOfferUnderfunded.to_xdr_buffered(write_stream),
            ManageBuyOfferResult::ManageBuyOfferCrossSelf =>
                ManageBuyOfferResultCode::ManageBuyOfferCrossSelf.to_xdr_buffered(write_stream),
            ManageBuyOfferResult::ManageBuyOfferSellNoIssuer =>
                ManageBuyOfferResultCode::ManageBuyOfferSellNoIssuer.to_xdr_buffered(write_stream),
            ManageBuyOfferResult::ManageBuyOfferBuyNoIssuer =>
                ManageBuyOfferResultCode::ManageBuyOfferBuyNoIssuer.to_xdr_buffered(write_stream),
            ManageBuyOfferResult::ManageBuyOfferNotFound =>
                ManageBuyOfferResultCode::ManageBuyOfferNotFound.to_xdr_buffered(write_stream),
            ManageBuyOfferResult::ManageBuyOfferLowReserve =>
                ManageBuyOfferResultCode::ManageBuyOfferLowReserve.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match ManageBuyOfferResultCode::from_xdr_buffered(read_stream)? {
            ManageBuyOfferResultCode::ManageBuyOfferSuccess => Ok(ManageBuyOfferResult::ManageBuyOfferSuccess(
                ManageOfferSuccessResult::from_xdr_buffered(read_stream)?,
            )),
            ManageBuyOfferResultCode::ManageBuyOfferMalformed => Ok(ManageBuyOfferResult::ManageBuyOfferMalformed),
            ManageBuyOfferResultCode::ManageBuyOfferSellNoTrust => Ok(ManageBuyOfferResult::ManageBuyOfferSellNoTrust),
            ManageBuyOfferResultCode::ManageBuyOfferBuyNoTrust => Ok(ManageBuyOfferResult::ManageBuyOfferBuyNoTrust),
            ManageBuyOfferResultCode::ManageBuyOfferSellNotAuthorized =>
                Ok(ManageBuyOfferResult::ManageBuyOfferSellNotAuthorized),
            ManageBuyOfferResultCode::ManageBuyOfferBuyNotAuthorized =>
                Ok(ManageBuyOfferResult::ManageBuyOfferBuyNotAuthorized),
            ManageBuyOfferResultCode::ManageBuyOfferLineFull => Ok(ManageBuyOfferResult::ManageBuyOfferLineFull),
            ManageBuyOfferResultCode::ManageBuyOfferUnderfunded => Ok(ManageBuyOfferResult::ManageBuyOfferUnderfunded),
            ManageBuyOfferResultCode::ManageBuyOfferCrossSelf => Ok(ManageBuyOfferResult::ManageBuyOfferCrossSelf),
            ManageBuyOfferResultCode::ManageBuyOfferSellNoIssuer =>
                Ok(ManageBuyOfferResult::ManageBuyOfferSellNoIssuer),
            ManageBuyOfferResultCode::ManageBuyOfferBuyNoIssuer => Ok(ManageBuyOfferResult::ManageBuyOfferBuyNoIssuer),
            ManageBuyOfferResultCode::ManageBuyOfferNotFound => Ok(ManageBuyOfferResult::ManageBuyOfferNotFound),
            ManageBuyOfferResultCode::ManageBuyOfferLowReserve => Ok(ManageBuyOfferResult::ManageBuyOfferLowReserve),
        }
    }
}

/// Autogenerated definition for type SetOptionsResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum SetOptionsResult {
    SetOptionsSuccess,
    SetOptionsLowReserve,
    SetOptionsTooManySigners,
    SetOptionsBadFlags,
    SetOptionsInvalidInflation,
    SetOptionsCantChange,
    SetOptionsUnknownFlag,
    SetOptionsThresholdOutOfRange,
    SetOptionsBadSigner,
    SetOptionsInvalidHomeDomain,
    SetOptionsAuthRevocableRequired,
}

impl XdrCodec for SetOptionsResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            SetOptionsResult::SetOptionsSuccess =>
                SetOptionsResultCode::SetOptionsSuccess.to_xdr_buffered(write_stream),
            SetOptionsResult::SetOptionsLowReserve =>
                SetOptionsResultCode::SetOptionsLowReserve.to_xdr_buffered(write_stream),
            SetOptionsResult::SetOptionsTooManySigners =>
                SetOptionsResultCode::SetOptionsTooManySigners.to_xdr_buffered(write_stream),
            SetOptionsResult::SetOptionsBadFlags =>
                SetOptionsResultCode::SetOptionsBadFlags.to_xdr_buffered(write_stream),
            SetOptionsResult::SetOptionsInvalidInflation =>
                SetOptionsResultCode::SetOptionsInvalidInflation.to_xdr_buffered(write_stream),
            SetOptionsResult::SetOptionsCantChange =>
                SetOptionsResultCode::SetOptionsCantChange.to_xdr_buffered(write_stream),
            SetOptionsResult::SetOptionsUnknownFlag =>
                SetOptionsResultCode::SetOptionsUnknownFlag.to_xdr_buffered(write_stream),
            SetOptionsResult::SetOptionsThresholdOutOfRange =>
                SetOptionsResultCode::SetOptionsThresholdOutOfRange.to_xdr_buffered(write_stream),
            SetOptionsResult::SetOptionsBadSigner =>
                SetOptionsResultCode::SetOptionsBadSigner.to_xdr_buffered(write_stream),
            SetOptionsResult::SetOptionsInvalidHomeDomain =>
                SetOptionsResultCode::SetOptionsInvalidHomeDomain.to_xdr_buffered(write_stream),
            SetOptionsResult::SetOptionsAuthRevocableRequired =>
                SetOptionsResultCode::SetOptionsAuthRevocableRequired.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match SetOptionsResultCode::from_xdr_buffered(read_stream)? {
            SetOptionsResultCode::SetOptionsSuccess => Ok(SetOptionsResult::SetOptionsSuccess),
            SetOptionsResultCode::SetOptionsLowReserve => Ok(SetOptionsResult::SetOptionsLowReserve),
            SetOptionsResultCode::SetOptionsTooManySigners => Ok(SetOptionsResult::SetOptionsTooManySigners),
            SetOptionsResultCode::SetOptionsBadFlags => Ok(SetOptionsResult::SetOptionsBadFlags),
            SetOptionsResultCode::SetOptionsInvalidInflation => Ok(SetOptionsResult::SetOptionsInvalidInflation),
            SetOptionsResultCode::SetOptionsCantChange => Ok(SetOptionsResult::SetOptionsCantChange),
            SetOptionsResultCode::SetOptionsUnknownFlag => Ok(SetOptionsResult::SetOptionsUnknownFlag),
            SetOptionsResultCode::SetOptionsThresholdOutOfRange => Ok(SetOptionsResult::SetOptionsThresholdOutOfRange),
            SetOptionsResultCode::SetOptionsBadSigner => Ok(SetOptionsResult::SetOptionsBadSigner),
            SetOptionsResultCode::SetOptionsInvalidHomeDomain => Ok(SetOptionsResult::SetOptionsInvalidHomeDomain),
            SetOptionsResultCode::SetOptionsAuthRevocableRequired =>
                Ok(SetOptionsResult::SetOptionsAuthRevocableRequired),
        }
    }
}

/// Autogenerated definition for type ChangeTrustResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ChangeTrustResult {
    ChangeTrustSuccess,
    ChangeTrustMalformed,
    ChangeTrustNoIssuer,
    ChangeTrustInvalidLimit,
    ChangeTrustLowReserve,
    ChangeTrustSelfNotAllowed,
    ChangeTrustTrustLineMissing,
    ChangeTrustCannotDelete,
    ChangeTrustNotAuthMaintainLiabilities,
}

impl XdrCodec for ChangeTrustResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ChangeTrustResult::ChangeTrustSuccess =>
                ChangeTrustResultCode::ChangeTrustSuccess.to_xdr_buffered(write_stream),
            ChangeTrustResult::ChangeTrustMalformed =>
                ChangeTrustResultCode::ChangeTrustMalformed.to_xdr_buffered(write_stream),
            ChangeTrustResult::ChangeTrustNoIssuer =>
                ChangeTrustResultCode::ChangeTrustNoIssuer.to_xdr_buffered(write_stream),
            ChangeTrustResult::ChangeTrustInvalidLimit =>
                ChangeTrustResultCode::ChangeTrustInvalidLimit.to_xdr_buffered(write_stream),
            ChangeTrustResult::ChangeTrustLowReserve =>
                ChangeTrustResultCode::ChangeTrustLowReserve.to_xdr_buffered(write_stream),
            ChangeTrustResult::ChangeTrustSelfNotAllowed =>
                ChangeTrustResultCode::ChangeTrustSelfNotAllowed.to_xdr_buffered(write_stream),
            ChangeTrustResult::ChangeTrustTrustLineMissing =>
                ChangeTrustResultCode::ChangeTrustTrustLineMissing.to_xdr_buffered(write_stream),
            ChangeTrustResult::ChangeTrustCannotDelete =>
                ChangeTrustResultCode::ChangeTrustCannotDelete.to_xdr_buffered(write_stream),
            ChangeTrustResult::ChangeTrustNotAuthMaintainLiabilities =>
                ChangeTrustResultCode::ChangeTrustNotAuthMaintainLiabilities.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match ChangeTrustResultCode::from_xdr_buffered(read_stream)? {
            ChangeTrustResultCode::ChangeTrustSuccess => Ok(ChangeTrustResult::ChangeTrustSuccess),
            ChangeTrustResultCode::ChangeTrustMalformed => Ok(ChangeTrustResult::ChangeTrustMalformed),
            ChangeTrustResultCode::ChangeTrustNoIssuer => Ok(ChangeTrustResult::ChangeTrustNoIssuer),
            ChangeTrustResultCode::ChangeTrustInvalidLimit => Ok(ChangeTrustResult::ChangeTrustInvalidLimit),
            ChangeTrustResultCode::ChangeTrustLowReserve => Ok(ChangeTrustResult::ChangeTrustLowReserve),
            ChangeTrustResultCode::ChangeTrustSelfNotAllowed => Ok(ChangeTrustResult::ChangeTrustSelfNotAllowed),
            ChangeTrustResultCode::ChangeTrustTrustLineMissing => Ok(ChangeTrustResult::ChangeTrustTrustLineMissing),
            ChangeTrustResultCode::ChangeTrustCannotDelete => Ok(ChangeTrustResult::ChangeTrustCannotDelete),
            ChangeTrustResultCode::ChangeTrustNotAuthMaintainLiabilities =>
                Ok(ChangeTrustResult::ChangeTrustNotAuthMaintainLiabilities),
        }
    }
}

/// Autogenerated definition for type AllowTrustResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum AllowTrustResult {
    AllowTrustSuccess,
    AllowTrustMalformed,
    AllowTrustNoTrustLine,
    AllowTrustTrustNotRequired,
    AllowTrustCantRevoke,
    AllowTrustSelfNotAllowed,
    AllowTrustLowReserve,
}

impl XdrCodec for AllowTrustResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            AllowTrustResult::AllowTrustSuccess =>
                AllowTrustResultCode::AllowTrustSuccess.to_xdr_buffered(write_stream),
            AllowTrustResult::AllowTrustMalformed =>
                AllowTrustResultCode::AllowTrustMalformed.to_xdr_buffered(write_stream),
            AllowTrustResult::AllowTrustNoTrustLine =>
                AllowTrustResultCode::AllowTrustNoTrustLine.to_xdr_buffered(write_stream),
            AllowTrustResult::AllowTrustTrustNotRequired =>
                AllowTrustResultCode::AllowTrustTrustNotRequired.to_xdr_buffered(write_stream),
            AllowTrustResult::AllowTrustCantRevoke =>
                AllowTrustResultCode::AllowTrustCantRevoke.to_xdr_buffered(write_stream),
            AllowTrustResult::AllowTrustSelfNotAllowed =>
                AllowTrustResultCode::AllowTrustSelfNotAllowed.to_xdr_buffered(write_stream),
            AllowTrustResult::AllowTrustLowReserve =>
                AllowTrustResultCode::AllowTrustLowReserve.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match AllowTrustResultCode::from_xdr_buffered(read_stream)? {
            AllowTrustResultCode::AllowTrustSuccess => Ok(AllowTrustResult::AllowTrustSuccess),
            AllowTrustResultCode::AllowTrustMalformed => Ok(AllowTrustResult::AllowTrustMalformed),
            AllowTrustResultCode::AllowTrustNoTrustLine => Ok(AllowTrustResult::AllowTrustNoTrustLine),
            AllowTrustResultCode::AllowTrustTrustNotRequired => Ok(AllowTrustResult::AllowTrustTrustNotRequired),
            AllowTrustResultCode::AllowTrustCantRevoke => Ok(AllowTrustResult::AllowTrustCantRevoke),
            AllowTrustResultCode::AllowTrustSelfNotAllowed => Ok(AllowTrustResult::AllowTrustSelfNotAllowed),
            AllowTrustResultCode::AllowTrustLowReserve => Ok(AllowTrustResult::AllowTrustLowReserve),
        }
    }
}

/// Autogenerated definition for type AccountMergeResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum AccountMergeResult {
    AccountMergeSuccess(Int64),
    AccountMergeMalformed,
    AccountMergeNoAccount,
    AccountMergeImmutableSet,
    AccountMergeHasSubEntries,
    AccountMergeSeqnumTooFar,
    AccountMergeDestFull,
    AccountMergeIsSponsor,
}

impl XdrCodec for AccountMergeResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            AccountMergeResult::AccountMergeSuccess(value) => {
                AccountMergeResultCode::AccountMergeSuccess.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            AccountMergeResult::AccountMergeMalformed =>
                AccountMergeResultCode::AccountMergeMalformed.to_xdr_buffered(write_stream),
            AccountMergeResult::AccountMergeNoAccount =>
                AccountMergeResultCode::AccountMergeNoAccount.to_xdr_buffered(write_stream),
            AccountMergeResult::AccountMergeImmutableSet =>
                AccountMergeResultCode::AccountMergeImmutableSet.to_xdr_buffered(write_stream),
            AccountMergeResult::AccountMergeHasSubEntries =>
                AccountMergeResultCode::AccountMergeHasSubEntries.to_xdr_buffered(write_stream),
            AccountMergeResult::AccountMergeSeqnumTooFar =>
                AccountMergeResultCode::AccountMergeSeqnumTooFar.to_xdr_buffered(write_stream),
            AccountMergeResult::AccountMergeDestFull =>
                AccountMergeResultCode::AccountMergeDestFull.to_xdr_buffered(write_stream),
            AccountMergeResult::AccountMergeIsSponsor =>
                AccountMergeResultCode::AccountMergeIsSponsor.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match AccountMergeResultCode::from_xdr_buffered(read_stream)? {
            AccountMergeResultCode::AccountMergeSuccess =>
                Ok(AccountMergeResult::AccountMergeSuccess(Int64::from_xdr_buffered(read_stream)?)),
            AccountMergeResultCode::AccountMergeMalformed => Ok(AccountMergeResult::AccountMergeMalformed),
            AccountMergeResultCode::AccountMergeNoAccount => Ok(AccountMergeResult::AccountMergeNoAccount),
            AccountMergeResultCode::AccountMergeImmutableSet => Ok(AccountMergeResult::AccountMergeImmutableSet),
            AccountMergeResultCode::AccountMergeHasSubEntries => Ok(AccountMergeResult::AccountMergeHasSubEntries),
            AccountMergeResultCode::AccountMergeSeqnumTooFar => Ok(AccountMergeResult::AccountMergeSeqnumTooFar),
            AccountMergeResultCode::AccountMergeDestFull => Ok(AccountMergeResult::AccountMergeDestFull),
            AccountMergeResultCode::AccountMergeIsSponsor => Ok(AccountMergeResult::AccountMergeIsSponsor),
        }
    }
}

/// Autogenerated definition for type InflationResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum InflationResult {
    InflationSuccess(UnlimitedVarArray<InflationPayout>),
    InflationNotTime,
}

impl XdrCodec for InflationResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            InflationResult::InflationSuccess(value) => {
                InflationResultCode::InflationSuccess.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            InflationResult::InflationNotTime => InflationResultCode::InflationNotTime.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match InflationResultCode::from_xdr_buffered(read_stream)? {
            InflationResultCode::InflationSuccess =>
                Ok(InflationResult::InflationSuccess(UnlimitedVarArray::<InflationPayout>::from_xdr_buffered(
                    read_stream,
                )?)),
            InflationResultCode::InflationNotTime => Ok(InflationResult::InflationNotTime),
        }
    }
}

/// Autogenerated definition for type ManageDataResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ManageDataResult {
    ManageDataSuccess,
    ManageDataNotSupportedYet,
    ManageDataNameNotFound,
    ManageDataLowReserve,
    ManageDataInvalidName,
}

impl XdrCodec for ManageDataResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ManageDataResult::ManageDataSuccess =>
                ManageDataResultCode::ManageDataSuccess.to_xdr_buffered(write_stream),
            ManageDataResult::ManageDataNotSupportedYet =>
                ManageDataResultCode::ManageDataNotSupportedYet.to_xdr_buffered(write_stream),
            ManageDataResult::ManageDataNameNotFound =>
                ManageDataResultCode::ManageDataNameNotFound.to_xdr_buffered(write_stream),
            ManageDataResult::ManageDataLowReserve =>
                ManageDataResultCode::ManageDataLowReserve.to_xdr_buffered(write_stream),
            ManageDataResult::ManageDataInvalidName =>
                ManageDataResultCode::ManageDataInvalidName.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match ManageDataResultCode::from_xdr_buffered(read_stream)? {
            ManageDataResultCode::ManageDataSuccess => Ok(ManageDataResult::ManageDataSuccess),
            ManageDataResultCode::ManageDataNotSupportedYet => Ok(ManageDataResult::ManageDataNotSupportedYet),
            ManageDataResultCode::ManageDataNameNotFound => Ok(ManageDataResult::ManageDataNameNotFound),
            ManageDataResultCode::ManageDataLowReserve => Ok(ManageDataResult::ManageDataLowReserve),
            ManageDataResultCode::ManageDataInvalidName => Ok(ManageDataResult::ManageDataInvalidName),
        }
    }
}

/// Autogenerated definition for type BumpSequenceResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum BumpSequenceResult {
    BumpSequenceSuccess,
    BumpSequenceBadSeq,
}

impl XdrCodec for BumpSequenceResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            BumpSequenceResult::BumpSequenceSuccess =>
                BumpSequenceResultCode::BumpSequenceSuccess.to_xdr_buffered(write_stream),
            BumpSequenceResult::BumpSequenceBadSeq =>
                BumpSequenceResultCode::BumpSequenceBadSeq.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match BumpSequenceResultCode::from_xdr_buffered(read_stream)? {
            BumpSequenceResultCode::BumpSequenceSuccess => Ok(BumpSequenceResult::BumpSequenceSuccess),
            BumpSequenceResultCode::BumpSequenceBadSeq => Ok(BumpSequenceResult::BumpSequenceBadSeq),
        }
    }
}

/// Autogenerated definition for type CreateClaimableBalanceResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum CreateClaimableBalanceResult {
    CreateClaimableBalanceSuccess(ClaimableBalanceId),
    CreateClaimableBalanceMalformed,
    CreateClaimableBalanceLowReserve,
    CreateClaimableBalanceNoTrust,
    CreateClaimableBalanceNotAuthorized,
    CreateClaimableBalanceUnderfunded,
}

impl XdrCodec for CreateClaimableBalanceResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            CreateClaimableBalanceResult::CreateClaimableBalanceSuccess(value) => {
                CreateClaimableBalanceResultCode::CreateClaimableBalanceSuccess.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            CreateClaimableBalanceResult::CreateClaimableBalanceMalformed =>
                CreateClaimableBalanceResultCode::CreateClaimableBalanceMalformed.to_xdr_buffered(write_stream),
            CreateClaimableBalanceResult::CreateClaimableBalanceLowReserve =>
                CreateClaimableBalanceResultCode::CreateClaimableBalanceLowReserve.to_xdr_buffered(write_stream),
            CreateClaimableBalanceResult::CreateClaimableBalanceNoTrust =>
                CreateClaimableBalanceResultCode::CreateClaimableBalanceNoTrust.to_xdr_buffered(write_stream),
            CreateClaimableBalanceResult::CreateClaimableBalanceNotAuthorized =>
                CreateClaimableBalanceResultCode::CreateClaimableBalanceNotAuthorized.to_xdr_buffered(write_stream),
            CreateClaimableBalanceResult::CreateClaimableBalanceUnderfunded =>
                CreateClaimableBalanceResultCode::CreateClaimableBalanceUnderfunded.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match CreateClaimableBalanceResultCode::from_xdr_buffered(read_stream)? {
            CreateClaimableBalanceResultCode::CreateClaimableBalanceSuccess =>
                Ok(CreateClaimableBalanceResult::CreateClaimableBalanceSuccess(ClaimableBalanceId::from_xdr_buffered(
                    read_stream,
                )?)),
            CreateClaimableBalanceResultCode::CreateClaimableBalanceMalformed =>
                Ok(CreateClaimableBalanceResult::CreateClaimableBalanceMalformed),
            CreateClaimableBalanceResultCode::CreateClaimableBalanceLowReserve =>
                Ok(CreateClaimableBalanceResult::CreateClaimableBalanceLowReserve),
            CreateClaimableBalanceResultCode::CreateClaimableBalanceNoTrust =>
                Ok(CreateClaimableBalanceResult::CreateClaimableBalanceNoTrust),
            CreateClaimableBalanceResultCode::CreateClaimableBalanceNotAuthorized =>
                Ok(CreateClaimableBalanceResult::CreateClaimableBalanceNotAuthorized),
            CreateClaimableBalanceResultCode::CreateClaimableBalanceUnderfunded =>
                Ok(CreateClaimableBalanceResult::CreateClaimableBalanceUnderfunded),
        }
    }
}

/// Autogenerated definition for type ClaimClaimableBalanceResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ClaimClaimableBalanceResult {
    ClaimClaimableBalanceSuccess,
    ClaimClaimableBalanceDoesNotExist,
    ClaimClaimableBalanceCannotClaim,
    ClaimClaimableBalanceLineFull,
    ClaimClaimableBalanceNoTrust,
    ClaimClaimableBalanceNotAuthorized,
}

impl XdrCodec for ClaimClaimableBalanceResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ClaimClaimableBalanceResult::ClaimClaimableBalanceSuccess =>
                ClaimClaimableBalanceResultCode::ClaimClaimableBalanceSuccess.to_xdr_buffered(write_stream),
            ClaimClaimableBalanceResult::ClaimClaimableBalanceDoesNotExist =>
                ClaimClaimableBalanceResultCode::ClaimClaimableBalanceDoesNotExist.to_xdr_buffered(write_stream),
            ClaimClaimableBalanceResult::ClaimClaimableBalanceCannotClaim =>
                ClaimClaimableBalanceResultCode::ClaimClaimableBalanceCannotClaim.to_xdr_buffered(write_stream),
            ClaimClaimableBalanceResult::ClaimClaimableBalanceLineFull =>
                ClaimClaimableBalanceResultCode::ClaimClaimableBalanceLineFull.to_xdr_buffered(write_stream),
            ClaimClaimableBalanceResult::ClaimClaimableBalanceNoTrust =>
                ClaimClaimableBalanceResultCode::ClaimClaimableBalanceNoTrust.to_xdr_buffered(write_stream),
            ClaimClaimableBalanceResult::ClaimClaimableBalanceNotAuthorized =>
                ClaimClaimableBalanceResultCode::ClaimClaimableBalanceNotAuthorized.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match ClaimClaimableBalanceResultCode::from_xdr_buffered(read_stream)? {
            ClaimClaimableBalanceResultCode::ClaimClaimableBalanceSuccess =>
                Ok(ClaimClaimableBalanceResult::ClaimClaimableBalanceSuccess),
            ClaimClaimableBalanceResultCode::ClaimClaimableBalanceDoesNotExist =>
                Ok(ClaimClaimableBalanceResult::ClaimClaimableBalanceDoesNotExist),
            ClaimClaimableBalanceResultCode::ClaimClaimableBalanceCannotClaim =>
                Ok(ClaimClaimableBalanceResult::ClaimClaimableBalanceCannotClaim),
            ClaimClaimableBalanceResultCode::ClaimClaimableBalanceLineFull =>
                Ok(ClaimClaimableBalanceResult::ClaimClaimableBalanceLineFull),
            ClaimClaimableBalanceResultCode::ClaimClaimableBalanceNoTrust =>
                Ok(ClaimClaimableBalanceResult::ClaimClaimableBalanceNoTrust),
            ClaimClaimableBalanceResultCode::ClaimClaimableBalanceNotAuthorized =>
                Ok(ClaimClaimableBalanceResult::ClaimClaimableBalanceNotAuthorized),
        }
    }
}

/// Autogenerated definition for type BeginSponsoringFutureReservesResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum BeginSponsoringFutureReservesResult {
    BeginSponsoringFutureReservesSuccess,
    BeginSponsoringFutureReservesMalformed,
    BeginSponsoringFutureReservesAlreadySponsored,
    BeginSponsoringFutureReservesRecursive,
}

impl XdrCodec for BeginSponsoringFutureReservesResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            BeginSponsoringFutureReservesResult::BeginSponsoringFutureReservesSuccess =>
                BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesSuccess
                    .to_xdr_buffered(write_stream),
            BeginSponsoringFutureReservesResult::BeginSponsoringFutureReservesMalformed =>
                BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesMalformed
                    .to_xdr_buffered(write_stream),
            BeginSponsoringFutureReservesResult::BeginSponsoringFutureReservesAlreadySponsored =>
                BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesAlreadySponsored
                    .to_xdr_buffered(write_stream),
            BeginSponsoringFutureReservesResult::BeginSponsoringFutureReservesRecursive =>
                BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesRecursive
                    .to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match BeginSponsoringFutureReservesResultCode::from_xdr_buffered(read_stream)? {
            BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesSuccess =>
                Ok(BeginSponsoringFutureReservesResult::BeginSponsoringFutureReservesSuccess),
            BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesMalformed =>
                Ok(BeginSponsoringFutureReservesResult::BeginSponsoringFutureReservesMalformed),
            BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesAlreadySponsored =>
                Ok(BeginSponsoringFutureReservesResult::BeginSponsoringFutureReservesAlreadySponsored),
            BeginSponsoringFutureReservesResultCode::BeginSponsoringFutureReservesRecursive =>
                Ok(BeginSponsoringFutureReservesResult::BeginSponsoringFutureReservesRecursive),
        }
    }
}

/// Autogenerated definition for type EndSponsoringFutureReservesResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum EndSponsoringFutureReservesResult {
    EndSponsoringFutureReservesSuccess,
    EndSponsoringFutureReservesNotSponsored,
}

impl XdrCodec for EndSponsoringFutureReservesResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            EndSponsoringFutureReservesResult::EndSponsoringFutureReservesSuccess =>
                EndSponsoringFutureReservesResultCode::EndSponsoringFutureReservesSuccess.to_xdr_buffered(write_stream),
            EndSponsoringFutureReservesResult::EndSponsoringFutureReservesNotSponsored =>
                EndSponsoringFutureReservesResultCode::EndSponsoringFutureReservesNotSponsored
                    .to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match EndSponsoringFutureReservesResultCode::from_xdr_buffered(read_stream)? {
            EndSponsoringFutureReservesResultCode::EndSponsoringFutureReservesSuccess =>
                Ok(EndSponsoringFutureReservesResult::EndSponsoringFutureReservesSuccess),
            EndSponsoringFutureReservesResultCode::EndSponsoringFutureReservesNotSponsored =>
                Ok(EndSponsoringFutureReservesResult::EndSponsoringFutureReservesNotSponsored),
        }
    }
}

/// Autogenerated definition for type RevokeSponsorshipResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum RevokeSponsorshipResult {
    RevokeSponsorshipSuccess,
    RevokeSponsorshipDoesNotExist,
    RevokeSponsorshipNotSponsor,
    RevokeSponsorshipLowReserve,
    RevokeSponsorshipOnlyTransferable,
    RevokeSponsorshipMalformed,
}

impl XdrCodec for RevokeSponsorshipResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            RevokeSponsorshipResult::RevokeSponsorshipSuccess =>
                RevokeSponsorshipResultCode::RevokeSponsorshipSuccess.to_xdr_buffered(write_stream),
            RevokeSponsorshipResult::RevokeSponsorshipDoesNotExist =>
                RevokeSponsorshipResultCode::RevokeSponsorshipDoesNotExist.to_xdr_buffered(write_stream),
            RevokeSponsorshipResult::RevokeSponsorshipNotSponsor =>
                RevokeSponsorshipResultCode::RevokeSponsorshipNotSponsor.to_xdr_buffered(write_stream),
            RevokeSponsorshipResult::RevokeSponsorshipLowReserve =>
                RevokeSponsorshipResultCode::RevokeSponsorshipLowReserve.to_xdr_buffered(write_stream),
            RevokeSponsorshipResult::RevokeSponsorshipOnlyTransferable =>
                RevokeSponsorshipResultCode::RevokeSponsorshipOnlyTransferable.to_xdr_buffered(write_stream),
            RevokeSponsorshipResult::RevokeSponsorshipMalformed =>
                RevokeSponsorshipResultCode::RevokeSponsorshipMalformed.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match RevokeSponsorshipResultCode::from_xdr_buffered(read_stream)? {
            RevokeSponsorshipResultCode::RevokeSponsorshipSuccess =>
                Ok(RevokeSponsorshipResult::RevokeSponsorshipSuccess),
            RevokeSponsorshipResultCode::RevokeSponsorshipDoesNotExist =>
                Ok(RevokeSponsorshipResult::RevokeSponsorshipDoesNotExist),
            RevokeSponsorshipResultCode::RevokeSponsorshipNotSponsor =>
                Ok(RevokeSponsorshipResult::RevokeSponsorshipNotSponsor),
            RevokeSponsorshipResultCode::RevokeSponsorshipLowReserve =>
                Ok(RevokeSponsorshipResult::RevokeSponsorshipLowReserve),
            RevokeSponsorshipResultCode::RevokeSponsorshipOnlyTransferable =>
                Ok(RevokeSponsorshipResult::RevokeSponsorshipOnlyTransferable),
            RevokeSponsorshipResultCode::RevokeSponsorshipMalformed =>
                Ok(RevokeSponsorshipResult::RevokeSponsorshipMalformed),
        }
    }
}

/// Autogenerated definition for type ClawbackResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ClawbackResult {
    ClawbackSuccess,
    ClawbackMalformed,
    ClawbackNotClawbackEnabled,
    ClawbackNoTrust,
    ClawbackUnderfunded,
}

impl XdrCodec for ClawbackResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ClawbackResult::ClawbackSuccess => ClawbackResultCode::ClawbackSuccess.to_xdr_buffered(write_stream),
            ClawbackResult::ClawbackMalformed => ClawbackResultCode::ClawbackMalformed.to_xdr_buffered(write_stream),
            ClawbackResult::ClawbackNotClawbackEnabled =>
                ClawbackResultCode::ClawbackNotClawbackEnabled.to_xdr_buffered(write_stream),
            ClawbackResult::ClawbackNoTrust => ClawbackResultCode::ClawbackNoTrust.to_xdr_buffered(write_stream),
            ClawbackResult::ClawbackUnderfunded =>
                ClawbackResultCode::ClawbackUnderfunded.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match ClawbackResultCode::from_xdr_buffered(read_stream)? {
            ClawbackResultCode::ClawbackSuccess => Ok(ClawbackResult::ClawbackSuccess),
            ClawbackResultCode::ClawbackMalformed => Ok(ClawbackResult::ClawbackMalformed),
            ClawbackResultCode::ClawbackNotClawbackEnabled => Ok(ClawbackResult::ClawbackNotClawbackEnabled),
            ClawbackResultCode::ClawbackNoTrust => Ok(ClawbackResult::ClawbackNoTrust),
            ClawbackResultCode::ClawbackUnderfunded => Ok(ClawbackResult::ClawbackUnderfunded),
        }
    }
}

/// Autogenerated definition for type ClawbackClaimableBalanceResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ClawbackClaimableBalanceResult {
    ClawbackClaimableBalanceSuccess,
    ClawbackClaimableBalanceDoesNotExist,
    ClawbackClaimableBalanceNotIssuer,
    ClawbackClaimableBalanceNotClawbackEnabled,
}

impl XdrCodec for ClawbackClaimableBalanceResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ClawbackClaimableBalanceResult::ClawbackClaimableBalanceSuccess =>
                ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceSuccess.to_xdr_buffered(write_stream),
            ClawbackClaimableBalanceResult::ClawbackClaimableBalanceDoesNotExist =>
                ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceDoesNotExist.to_xdr_buffered(write_stream),
            ClawbackClaimableBalanceResult::ClawbackClaimableBalanceNotIssuer =>
                ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceNotIssuer.to_xdr_buffered(write_stream),
            ClawbackClaimableBalanceResult::ClawbackClaimableBalanceNotClawbackEnabled =>
                ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceNotClawbackEnabled
                    .to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match ClawbackClaimableBalanceResultCode::from_xdr_buffered(read_stream)? {
            ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceSuccess =>
                Ok(ClawbackClaimableBalanceResult::ClawbackClaimableBalanceSuccess),
            ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceDoesNotExist =>
                Ok(ClawbackClaimableBalanceResult::ClawbackClaimableBalanceDoesNotExist),
            ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceNotIssuer =>
                Ok(ClawbackClaimableBalanceResult::ClawbackClaimableBalanceNotIssuer),
            ClawbackClaimableBalanceResultCode::ClawbackClaimableBalanceNotClawbackEnabled =>
                Ok(ClawbackClaimableBalanceResult::ClawbackClaimableBalanceNotClawbackEnabled),
        }
    }
}

/// Autogenerated definition for type SetTrustLineFlagsResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum SetTrustLineFlagsResult {
    SetTrustLineFlagsSuccess,
    SetTrustLineFlagsMalformed,
    SetTrustLineFlagsNoTrustLine,
    SetTrustLineFlagsCantRevoke,
    SetTrustLineFlagsInvalidState,
    SetTrustLineFlagsLowReserve,
}

impl XdrCodec for SetTrustLineFlagsResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            SetTrustLineFlagsResult::SetTrustLineFlagsSuccess =>
                SetTrustLineFlagsResultCode::SetTrustLineFlagsSuccess.to_xdr_buffered(write_stream),
            SetTrustLineFlagsResult::SetTrustLineFlagsMalformed =>
                SetTrustLineFlagsResultCode::SetTrustLineFlagsMalformed.to_xdr_buffered(write_stream),
            SetTrustLineFlagsResult::SetTrustLineFlagsNoTrustLine =>
                SetTrustLineFlagsResultCode::SetTrustLineFlagsNoTrustLine.to_xdr_buffered(write_stream),
            SetTrustLineFlagsResult::SetTrustLineFlagsCantRevoke =>
                SetTrustLineFlagsResultCode::SetTrustLineFlagsCantRevoke.to_xdr_buffered(write_stream),
            SetTrustLineFlagsResult::SetTrustLineFlagsInvalidState =>
                SetTrustLineFlagsResultCode::SetTrustLineFlagsInvalidState.to_xdr_buffered(write_stream),
            SetTrustLineFlagsResult::SetTrustLineFlagsLowReserve =>
                SetTrustLineFlagsResultCode::SetTrustLineFlagsLowReserve.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match SetTrustLineFlagsResultCode::from_xdr_buffered(read_stream)? {
            SetTrustLineFlagsResultCode::SetTrustLineFlagsSuccess =>
                Ok(SetTrustLineFlagsResult::SetTrustLineFlagsSuccess),
            SetTrustLineFlagsResultCode::SetTrustLineFlagsMalformed =>
                Ok(SetTrustLineFlagsResult::SetTrustLineFlagsMalformed),
            SetTrustLineFlagsResultCode::SetTrustLineFlagsNoTrustLine =>
                Ok(SetTrustLineFlagsResult::SetTrustLineFlagsNoTrustLine),
            SetTrustLineFlagsResultCode::SetTrustLineFlagsCantRevoke =>
                Ok(SetTrustLineFlagsResult::SetTrustLineFlagsCantRevoke),
            SetTrustLineFlagsResultCode::SetTrustLineFlagsInvalidState =>
                Ok(SetTrustLineFlagsResult::SetTrustLineFlagsInvalidState),
            SetTrustLineFlagsResultCode::SetTrustLineFlagsLowReserve =>
                Ok(SetTrustLineFlagsResult::SetTrustLineFlagsLowReserve),
        }
    }
}

/// Autogenerated definition for type LiquidityPoolDepositResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum LiquidityPoolDepositResult {
    LiquidityPoolDepositSuccess,
    LiquidityPoolDepositMalformed,
    LiquidityPoolDepositNoTrust,
    LiquidityPoolDepositNotAuthorized,
    LiquidityPoolDepositUnderfunded,
    LiquidityPoolDepositLineFull,
    LiquidityPoolDepositBadPrice,
    LiquidityPoolDepositPoolFull,
}

impl XdrCodec for LiquidityPoolDepositResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            LiquidityPoolDepositResult::LiquidityPoolDepositSuccess =>
                LiquidityPoolDepositResultCode::LiquidityPoolDepositSuccess.to_xdr_buffered(write_stream),
            LiquidityPoolDepositResult::LiquidityPoolDepositMalformed =>
                LiquidityPoolDepositResultCode::LiquidityPoolDepositMalformed.to_xdr_buffered(write_stream),
            LiquidityPoolDepositResult::LiquidityPoolDepositNoTrust =>
                LiquidityPoolDepositResultCode::LiquidityPoolDepositNoTrust.to_xdr_buffered(write_stream),
            LiquidityPoolDepositResult::LiquidityPoolDepositNotAuthorized =>
                LiquidityPoolDepositResultCode::LiquidityPoolDepositNotAuthorized.to_xdr_buffered(write_stream),
            LiquidityPoolDepositResult::LiquidityPoolDepositUnderfunded =>
                LiquidityPoolDepositResultCode::LiquidityPoolDepositUnderfunded.to_xdr_buffered(write_stream),
            LiquidityPoolDepositResult::LiquidityPoolDepositLineFull =>
                LiquidityPoolDepositResultCode::LiquidityPoolDepositLineFull.to_xdr_buffered(write_stream),
            LiquidityPoolDepositResult::LiquidityPoolDepositBadPrice =>
                LiquidityPoolDepositResultCode::LiquidityPoolDepositBadPrice.to_xdr_buffered(write_stream),
            LiquidityPoolDepositResult::LiquidityPoolDepositPoolFull =>
                LiquidityPoolDepositResultCode::LiquidityPoolDepositPoolFull.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match LiquidityPoolDepositResultCode::from_xdr_buffered(read_stream)? {
            LiquidityPoolDepositResultCode::LiquidityPoolDepositSuccess =>
                Ok(LiquidityPoolDepositResult::LiquidityPoolDepositSuccess),
            LiquidityPoolDepositResultCode::LiquidityPoolDepositMalformed =>
                Ok(LiquidityPoolDepositResult::LiquidityPoolDepositMalformed),
            LiquidityPoolDepositResultCode::LiquidityPoolDepositNoTrust =>
                Ok(LiquidityPoolDepositResult::LiquidityPoolDepositNoTrust),
            LiquidityPoolDepositResultCode::LiquidityPoolDepositNotAuthorized =>
                Ok(LiquidityPoolDepositResult::LiquidityPoolDepositNotAuthorized),
            LiquidityPoolDepositResultCode::LiquidityPoolDepositUnderfunded =>
                Ok(LiquidityPoolDepositResult::LiquidityPoolDepositUnderfunded),
            LiquidityPoolDepositResultCode::LiquidityPoolDepositLineFull =>
                Ok(LiquidityPoolDepositResult::LiquidityPoolDepositLineFull),
            LiquidityPoolDepositResultCode::LiquidityPoolDepositBadPrice =>
                Ok(LiquidityPoolDepositResult::LiquidityPoolDepositBadPrice),
            LiquidityPoolDepositResultCode::LiquidityPoolDepositPoolFull =>
                Ok(LiquidityPoolDepositResult::LiquidityPoolDepositPoolFull),
        }
    }
}

/// Autogenerated definition for type LiquidityPoolWithdrawResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum LiquidityPoolWithdrawResult {
    LiquidityPoolWithdrawSuccess,
    LiquidityPoolWithdrawMalformed,
    LiquidityPoolWithdrawNoTrust,
    LiquidityPoolWithdrawUnderfunded,
    LiquidityPoolWithdrawLineFull,
    LiquidityPoolWithdrawUnderMinimum,
}

impl XdrCodec for LiquidityPoolWithdrawResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            LiquidityPoolWithdrawResult::LiquidityPoolWithdrawSuccess =>
                LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawSuccess.to_xdr_buffered(write_stream),
            LiquidityPoolWithdrawResult::LiquidityPoolWithdrawMalformed =>
                LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawMalformed.to_xdr_buffered(write_stream),
            LiquidityPoolWithdrawResult::LiquidityPoolWithdrawNoTrust =>
                LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawNoTrust.to_xdr_buffered(write_stream),
            LiquidityPoolWithdrawResult::LiquidityPoolWithdrawUnderfunded =>
                LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawUnderfunded.to_xdr_buffered(write_stream),
            LiquidityPoolWithdrawResult::LiquidityPoolWithdrawLineFull =>
                LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawLineFull.to_xdr_buffered(write_stream),
            LiquidityPoolWithdrawResult::LiquidityPoolWithdrawUnderMinimum =>
                LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawUnderMinimum.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match LiquidityPoolWithdrawResultCode::from_xdr_buffered(read_stream)? {
            LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawSuccess =>
                Ok(LiquidityPoolWithdrawResult::LiquidityPoolWithdrawSuccess),
            LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawMalformed =>
                Ok(LiquidityPoolWithdrawResult::LiquidityPoolWithdrawMalformed),
            LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawNoTrust =>
                Ok(LiquidityPoolWithdrawResult::LiquidityPoolWithdrawNoTrust),
            LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawUnderfunded =>
                Ok(LiquidityPoolWithdrawResult::LiquidityPoolWithdrawUnderfunded),
            LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawLineFull =>
                Ok(LiquidityPoolWithdrawResult::LiquidityPoolWithdrawLineFull),
            LiquidityPoolWithdrawResultCode::LiquidityPoolWithdrawUnderMinimum =>
                Ok(LiquidityPoolWithdrawResult::LiquidityPoolWithdrawUnderMinimum),
        }
    }
}

/// Autogenerated definition for type InvokeHostFunctionResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum InvokeHostFunctionResult {
    InvokeHostFunctionSuccess(Hash),
    InvokeHostFunctionMalformed,
    InvokeHostFunctionTrapped,
    InvokeHostFunctionResourceLimitExceeded,
    InvokeHostFunctionEntryArchived,
    InvokeHostFunctionInsufficientRefundableFee,
}

impl XdrCodec for InvokeHostFunctionResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            InvokeHostFunctionResult::InvokeHostFunctionSuccess(value) => {
                InvokeHostFunctionResultCode::InvokeHostFunctionSuccess.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            InvokeHostFunctionResult::InvokeHostFunctionMalformed =>
                InvokeHostFunctionResultCode::InvokeHostFunctionMalformed.to_xdr_buffered(write_stream),
            InvokeHostFunctionResult::InvokeHostFunctionTrapped =>
                InvokeHostFunctionResultCode::InvokeHostFunctionTrapped.to_xdr_buffered(write_stream),
            InvokeHostFunctionResult::InvokeHostFunctionResourceLimitExceeded =>
                InvokeHostFunctionResultCode::InvokeHostFunctionResourceLimitExceeded.to_xdr_buffered(write_stream),
            InvokeHostFunctionResult::InvokeHostFunctionEntryArchived =>
                InvokeHostFunctionResultCode::InvokeHostFunctionEntryArchived.to_xdr_buffered(write_stream),
            InvokeHostFunctionResult::InvokeHostFunctionInsufficientRefundableFee =>
                InvokeHostFunctionResultCode::InvokeHostFunctionInsufficientRefundableFee.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match InvokeHostFunctionResultCode::from_xdr_buffered(read_stream)? {
            InvokeHostFunctionResultCode::InvokeHostFunctionSuccess =>
                Ok(InvokeHostFunctionResult::InvokeHostFunctionSuccess(Hash::from_xdr_buffered(read_stream)?)),
            InvokeHostFunctionResultCode::InvokeHostFunctionMalformed =>
                Ok(InvokeHostFunctionResult::InvokeHostFunctionMalformed),
            InvokeHostFunctionResultCode::InvokeHostFunctionTrapped =>
                Ok(InvokeHostFunctionResult::InvokeHostFunctionTrapped),
            InvokeHostFunctionResultCode::InvokeHostFunctionResourceLimitExceeded =>
                Ok(InvokeHostFunctionResult::InvokeHostFunctionResourceLimitExceeded),
            InvokeHostFunctionResultCode::InvokeHostFunctionEntryArchived =>
                Ok(InvokeHostFunctionResult::InvokeHostFunctionEntryArchived),
            InvokeHostFunctionResultCode::InvokeHostFunctionInsufficientRefundableFee =>
                Ok(InvokeHostFunctionResult::InvokeHostFunctionInsufficientRefundableFee),
        }
    }
}

/// Autogenerated definition for type ExtendFootprintTtlResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ExtendFootprintTtlResult {
    ExtendFootprintTtlSuccess,
    ExtendFootprintTtlMalformed,
    ExtendFootprintTtlResourceLimitExceeded,
    ExtendFootprintTtlInsufficientRefundableFee,
}

impl XdrCodec for ExtendFootprintTtlResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ExtendFootprintTtlResult::ExtendFootprintTtlSuccess =>
                ExtendFootprintTtlResultCode::ExtendFootprintTtlSuccess.to_xdr_buffered(write_stream),
            ExtendFootprintTtlResult::ExtendFootprintTtlMalformed =>
                ExtendFootprintTtlResultCode::ExtendFootprintTtlMalformed.to_xdr_buffered(write_stream),
            ExtendFootprintTtlResult::ExtendFootprintTtlResourceLimitExceeded =>
                ExtendFootprintTtlResultCode::ExtendFootprintTtlResourceLimitExceeded.to_xdr_buffered(write_stream),
            ExtendFootprintTtlResult::ExtendFootprintTtlInsufficientRefundableFee =>
                ExtendFootprintTtlResultCode::ExtendFootprintTtlInsufficientRefundableFee.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match ExtendFootprintTtlResultCode::from_xdr_buffered(read_stream)? {
            ExtendFootprintTtlResultCode::ExtendFootprintTtlSuccess =>
                Ok(ExtendFootprintTtlResult::ExtendFootprintTtlSuccess),
            ExtendFootprintTtlResultCode::ExtendFootprintTtlMalformed =>
                Ok(ExtendFootprintTtlResult::ExtendFootprintTtlMalformed),
            ExtendFootprintTtlResultCode::ExtendFootprintTtlResourceLimitExceeded =>
                Ok(ExtendFootprintTtlResult::ExtendFootprintTtlResourceLimitExceeded),
            ExtendFootprintTtlResultCode::ExtendFootprintTtlInsufficientRefundableFee =>
                Ok(ExtendFootprintTtlResult::ExtendFootprintTtlInsufficientRefundableFee),
        }
    }
}

/// Autogenerated definition for type RestoreFootprintResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum RestoreFootprintResult {
    RestoreFootprintSuccess,
    RestoreFootprintMalformed,
    RestoreFootprintResourceLimitExceeded,
    RestoreFootprintInsufficientRefundableFee,
}

impl XdrCodec for RestoreFootprintResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            RestoreFootprintResult::RestoreFootprintSuccess =>
                RestoreFootprintResultCode::RestoreFootprintSuccess.to_xdr_buffered(write_stream),
            RestoreFootprintResult::RestoreFootprintMalformed =>
                RestoreFootprintResultCode::RestoreFootprintMalformed.to_xdr_buffered(write_stream),
            RestoreFootprintResult::RestoreFootprintResourceLimitExceeded =>
                RestoreFootprintResultCode::RestoreFootprintResourceLimitExceeded.to_xdr_buffered(write_stream),
            RestoreFootprintResult::RestoreFootprintInsufficientRefundableFee =>
                RestoreFootprintResultCode::RestoreFootprintInsufficientRefundableFee.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match RestoreFootprintResultCode::from_xdr_buffered(read_stream)? {
            RestoreFootprintResultCode::RestoreFootprintSuccess => Ok(RestoreFootprintResult::RestoreFootprintSuccess),
            RestoreFootprintResultCode::RestoreFootprintMalformed =>
                Ok(RestoreFootprintResult::RestoreFootprintMalformed),
            RestoreFootprintResultCode::RestoreFootprintResourceLimitExceeded =>
                Ok(RestoreFootprintResult::RestoreFootprintResourceLimitExceeded),
            RestoreFootprintResultCode::RestoreFootprintInsufficientRefundableFee =>
                Ok(RestoreFootprintResult::RestoreFootprintInsufficientRefundableFee),
        }
    }
}

/// Autogenerated definition for type OperationResultTr
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum OperationResultTr {
    CreateAccount(CreateAccountResult),
    Payment(PaymentResult),
    PathPaymentStrictReceive(PathPaymentStrictReceiveResult),
    ManageSellOffer(ManageSellOfferResult),
    CreatePassiveSellOffer(ManageSellOfferResult),
    SetOptions(SetOptionsResult),
    ChangeTrust(ChangeTrustResult),
    AllowTrust(AllowTrustResult),
    AccountMerge(AccountMergeResult),
    Inflation(InflationResult),
    ManageData(ManageDataResult),
    BumpSequence(BumpSequenceResult),
    ManageBuyOffer(ManageBuyOfferResult),
    PathPaymentStrictSend(PathPaymentStrictSendResult),
    CreateClaimableBalance(CreateClaimableBalanceResult),
    ClaimClaimableBalance(ClaimClaimableBalanceResult),
    BeginSponsoringFutureReserves(BeginSponsoringFutureReservesResult),
    EndSponsoringFutureReserves(EndSponsoringFutureReservesResult),
    RevokeSponsorship(RevokeSponsorshipResult),
    Clawback(ClawbackResult),
    ClawbackClaimableBalance(ClawbackClaimableBalanceResult),
    SetTrustLineFlags(SetTrustLineFlagsResult),
    LiquidityPoolDeposit(LiquidityPoolDepositResult),
    LiquidityPoolWithdraw(LiquidityPoolWithdrawResult),
    InvokeHostFunction(InvokeHostFunctionResult),
    ExtendFootprintTtl(ExtendFootprintTtlResult),
    RestoreFootprint(RestoreFootprintResult),
}

impl XdrCodec for OperationResultTr {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            OperationResultTr::CreateAccount(value) => {
                OperationType::CreateAccount.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationResultTr::Payment(value) => {
                OperationType::Payment.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationResultTr::PathPaymentStrictReceive(value) => {
                OperationType::PathPaymentStrictReceive.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationResultTr::ManageSellOffer(value) => {
                OperationType::ManageSellOffer.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationResultTr::CreatePassiveSellOffer(value) => {
                OperationType::CreatePassiveSellOffer.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationResultTr::SetOptions(value) => {
                OperationType::SetOptions.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationResultTr::ChangeTrust(value) => {
                OperationType::ChangeTrust.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationResultTr::AllowTrust(value) => {
                OperationType::AllowTrust.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationResultTr::AccountMerge(value) => {
                OperationType::AccountMerge.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationResultTr::Inflation(value) => {
                OperationType::Inflation.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationResultTr::ManageData(value) => {
                OperationType::ManageData.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationResultTr::BumpSequence(value) => {
                OperationType::BumpSequence.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationResultTr::ManageBuyOffer(value) => {
                OperationType::ManageBuyOffer.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationResultTr::PathPaymentStrictSend(value) => {
                OperationType::PathPaymentStrictSend.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationResultTr::CreateClaimableBalance(value) => {
                OperationType::CreateClaimableBalance.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationResultTr::ClaimClaimableBalance(value) => {
                OperationType::ClaimClaimableBalance.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationResultTr::BeginSponsoringFutureReserves(value) => {
                OperationType::BeginSponsoringFutureReserves.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationResultTr::EndSponsoringFutureReserves(value) => {
                OperationType::EndSponsoringFutureReserves.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationResultTr::RevokeSponsorship(value) => {
                OperationType::RevokeSponsorship.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationResultTr::Clawback(value) => {
                OperationType::Clawback.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationResultTr::ClawbackClaimableBalance(value) => {
                OperationType::ClawbackClaimableBalance.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationResultTr::SetTrustLineFlags(value) => {
                OperationType::SetTrustLineFlags.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationResultTr::LiquidityPoolDeposit(value) => {
                OperationType::LiquidityPoolDeposit.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationResultTr::LiquidityPoolWithdraw(value) => {
                OperationType::LiquidityPoolWithdraw.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationResultTr::InvokeHostFunction(value) => {
                OperationType::InvokeHostFunction.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationResultTr::ExtendFootprintTtl(value) => {
                OperationType::ExtendFootprintTtl.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationResultTr::RestoreFootprint(value) => {
                OperationType::RestoreFootprint.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match OperationType::from_xdr_buffered(read_stream)? {
            OperationType::CreateAccount =>
                Ok(OperationResultTr::CreateAccount(CreateAccountResult::from_xdr_buffered(read_stream)?)),
            OperationType::Payment => Ok(OperationResultTr::Payment(PaymentResult::from_xdr_buffered(read_stream)?)),
            OperationType::PathPaymentStrictReceive => Ok(OperationResultTr::PathPaymentStrictReceive(
                PathPaymentStrictReceiveResult::from_xdr_buffered(read_stream)?,
            )),
            OperationType::ManageSellOffer =>
                Ok(OperationResultTr::ManageSellOffer(ManageSellOfferResult::from_xdr_buffered(read_stream)?)),
            OperationType::CreatePassiveSellOffer =>
                Ok(OperationResultTr::CreatePassiveSellOffer(ManageSellOfferResult::from_xdr_buffered(read_stream)?)),
            OperationType::SetOptions =>
                Ok(OperationResultTr::SetOptions(SetOptionsResult::from_xdr_buffered(read_stream)?)),
            OperationType::ChangeTrust =>
                Ok(OperationResultTr::ChangeTrust(ChangeTrustResult::from_xdr_buffered(read_stream)?)),
            OperationType::AllowTrust =>
                Ok(OperationResultTr::AllowTrust(AllowTrustResult::from_xdr_buffered(read_stream)?)),
            OperationType::AccountMerge =>
                Ok(OperationResultTr::AccountMerge(AccountMergeResult::from_xdr_buffered(read_stream)?)),
            OperationType::Inflation =>
                Ok(OperationResultTr::Inflation(InflationResult::from_xdr_buffered(read_stream)?)),
            OperationType::ManageData =>
                Ok(OperationResultTr::ManageData(ManageDataResult::from_xdr_buffered(read_stream)?)),
            OperationType::BumpSequence =>
                Ok(OperationResultTr::BumpSequence(BumpSequenceResult::from_xdr_buffered(read_stream)?)),
            OperationType::ManageBuyOffer =>
                Ok(OperationResultTr::ManageBuyOffer(ManageBuyOfferResult::from_xdr_buffered(read_stream)?)),
            OperationType::PathPaymentStrictSend => Ok(OperationResultTr::PathPaymentStrictSend(
                PathPaymentStrictSendResult::from_xdr_buffered(read_stream)?,
            )),
            OperationType::CreateClaimableBalance => Ok(OperationResultTr::CreateClaimableBalance(
                CreateClaimableBalanceResult::from_xdr_buffered(read_stream)?,
            )),
            OperationType::ClaimClaimableBalance => Ok(OperationResultTr::ClaimClaimableBalance(
                ClaimClaimableBalanceResult::from_xdr_buffered(read_stream)?,
            )),
            OperationType::BeginSponsoringFutureReserves => Ok(OperationResultTr::BeginSponsoringFutureReserves(
                BeginSponsoringFutureReservesResult::from_xdr_buffered(read_stream)?,
            )),
            OperationType::EndSponsoringFutureReserves => Ok(OperationResultTr::EndSponsoringFutureReserves(
                EndSponsoringFutureReservesResult::from_xdr_buffered(read_stream)?,
            )),
            OperationType::RevokeSponsorship =>
                Ok(OperationResultTr::RevokeSponsorship(RevokeSponsorshipResult::from_xdr_buffered(read_stream)?)),
            OperationType::Clawback => Ok(OperationResultTr::Clawback(ClawbackResult::from_xdr_buffered(read_stream)?)),
            OperationType::ClawbackClaimableBalance => Ok(OperationResultTr::ClawbackClaimableBalance(
                ClawbackClaimableBalanceResult::from_xdr_buffered(read_stream)?,
            )),
            OperationType::SetTrustLineFlags =>
                Ok(OperationResultTr::SetTrustLineFlags(SetTrustLineFlagsResult::from_xdr_buffered(read_stream)?)),
            OperationType::LiquidityPoolDeposit =>
                Ok(OperationResultTr::LiquidityPoolDeposit(LiquidityPoolDepositResult::from_xdr_buffered(read_stream)?)),
            OperationType::LiquidityPoolWithdraw => Ok(OperationResultTr::LiquidityPoolWithdraw(
                LiquidityPoolWithdrawResult::from_xdr_buffered(read_stream)?,
            )),
            OperationType::InvokeHostFunction =>
                Ok(OperationResultTr::InvokeHostFunction(InvokeHostFunctionResult::from_xdr_buffered(read_stream)?)),
            OperationType::ExtendFootprintTtl =>
                Ok(OperationResultTr::ExtendFootprintTtl(ExtendFootprintTtlResult::from_xdr_buffered(read_stream)?)),
            OperationType::RestoreFootprint =>
                Ok(OperationResultTr::RestoreFootprint(RestoreFootprintResult::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type OperationResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum OperationResult {
    OpInner(OperationResultTr),
    OpBadAuth,
    OpNoAccount,
    OpNotSupported,
    OpTooManySubentries,
    OpExceededWorkLimit,
    OpTooManySponsoring,
}

impl XdrCodec for OperationResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            OperationResult::OpInner(value) => {
                OperationResultCode::OpInner.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            OperationResult::OpBadAuth => OperationResultCode::OpBadAuth.to_xdr_buffered(write_stream),
            OperationResult::OpNoAccount => OperationResultCode::OpNoAccount.to_xdr_buffered(write_stream),
            OperationResult::OpNotSupported => OperationResultCode::OpNotSupported.to_xdr_buffered(write_stream),
            OperationResult::OpTooManySubentries =>
                OperationResultCode::OpTooManySubentries.to_xdr_buffered(write_stream),
            OperationResult::OpExceededWorkLimit =>
                OperationResultCode::OpExceededWorkLimit.to_xdr_buffered(write_stream),
            OperationResult::OpTooManySponsoring =>
                OperationResultCode::OpTooManySponsoring.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match OperationResultCode::from_xdr_buffered(read_stream)? {
            OperationResultCode::OpInner =>
                Ok(OperationResult::OpInner(OperationResultTr::from_xdr_buffered(read_stream)?)),
            OperationResultCode::OpBadAuth => Ok(OperationResult::OpBadAuth),
            OperationResultCode::OpNoAccount => Ok(OperationResult::OpNoAccount),
            OperationResultCode::OpNotSupported => Ok(OperationResult::OpNotSupported),
            OperationResultCode::OpTooManySubentries => Ok(OperationResult::OpTooManySubentries),
            OperationResultCode::OpExceededWorkLimit => Ok(OperationResult::OpExceededWorkLimit),
            OperationResultCode::OpTooManySponsoring => Ok(OperationResult::OpTooManySponsoring),
        }
    }
}

/// Autogenerated definition for type InnerTransactionResultResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum InnerTransactionResultResult {
    TxSuccess(UnlimitedVarArray<OperationResult>),
    TxFailed(UnlimitedVarArray<OperationResult>),
    TxTooEarly,
    TxTooLate,
    TxMissingOperation,
    TxBadSeq,
    TxBadAuth,
    TxInsufficientBalance,
    TxNoAccount,
    TxInsufficientFee,
    TxBadAuthExtra,
    TxInternalError,
    TxNotSupported,
    TxBadSponsorship,
    TxBadMinSeqAgeOrGap,
    TxMalformed,
    TxSorobanInvalid,
    Default(TransactionResultCode),
}

impl XdrCodec for InnerTransactionResultResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            InnerTransactionResultResult::TxSuccess(value) => {
                TransactionResultCode::TxSuccess.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            InnerTransactionResultResult::TxFailed(value) => {
                TransactionResultCode::TxFailed.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            InnerTransactionResultResult::TxTooEarly => TransactionResultCode::TxTooEarly.to_xdr_buffered(write_stream),
            InnerTransactionResultResult::TxTooLate => TransactionResultCode::TxTooLate.to_xdr_buffered(write_stream),
            InnerTransactionResultResult::TxMissingOperation =>
                TransactionResultCode::TxMissingOperation.to_xdr_buffered(write_stream),
            InnerTransactionResultResult::TxBadSeq => TransactionResultCode::TxBadSeq.to_xdr_buffered(write_stream),
            InnerTransactionResultResult::TxBadAuth => TransactionResultCode::TxBadAuth.to_xdr_buffered(write_stream),
            InnerTransactionResultResult::TxInsufficientBalance =>
                TransactionResultCode::TxInsufficientBalance.to_xdr_buffered(write_stream),
            InnerTransactionResultResult::TxNoAccount =>
                TransactionResultCode::TxNoAccount.to_xdr_buffered(write_stream),
            InnerTransactionResultResult::TxInsufficientFee =>
                TransactionResultCode::TxInsufficientFee.to_xdr_buffered(write_stream),
            InnerTransactionResultResult::TxBadAuthExtra =>
                TransactionResultCode::TxBadAuthExtra.to_xdr_buffered(write_stream),
            InnerTransactionResultResult::TxInternalError =>
                TransactionResultCode::TxInternalError.to_xdr_buffered(write_stream),
            InnerTransactionResultResult::TxNotSupported =>
                TransactionResultCode::TxNotSupported.to_xdr_buffered(write_stream),
            InnerTransactionResultResult::TxBadSponsorship =>
                TransactionResultCode::TxBadSponsorship.to_xdr_buffered(write_stream),
            InnerTransactionResultResult::TxBadMinSeqAgeOrGap =>
                TransactionResultCode::TxBadMinSeqAgeOrGap.to_xdr_buffered(write_stream),
            InnerTransactionResultResult::TxMalformed =>
                TransactionResultCode::TxMalformed.to_xdr_buffered(write_stream),
            InnerTransactionResultResult::TxSorobanInvalid =>
                TransactionResultCode::TxSorobanInvalid.to_xdr_buffered(write_stream),
            InnerTransactionResultResult::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match TransactionResultCode::from_xdr_buffered(read_stream)? {
            TransactionResultCode::TxSuccess =>
                Ok(InnerTransactionResultResult::TxSuccess(UnlimitedVarArray::<OperationResult>::from_xdr_buffered(
                    read_stream,
                )?)),
            TransactionResultCode::TxFailed =>
                Ok(InnerTransactionResultResult::TxFailed(UnlimitedVarArray::<OperationResult>::from_xdr_buffered(
                    read_stream,
                )?)),
            TransactionResultCode::TxTooEarly => Ok(InnerTransactionResultResult::TxTooEarly),
            TransactionResultCode::TxTooLate => Ok(InnerTransactionResultResult::TxTooLate),
            TransactionResultCode::TxMissingOperation => Ok(InnerTransactionResultResult::TxMissingOperation),
            TransactionResultCode::TxBadSeq => Ok(InnerTransactionResultResult::TxBadSeq),
            TransactionResultCode::TxBadAuth => Ok(InnerTransactionResultResult::TxBadAuth),
            TransactionResultCode::TxInsufficientBalance => Ok(InnerTransactionResultResult::TxInsufficientBalance),
            TransactionResultCode::TxNoAccount => Ok(InnerTransactionResultResult::TxNoAccount),
            TransactionResultCode::TxInsufficientFee => Ok(InnerTransactionResultResult::TxInsufficientFee),
            TransactionResultCode::TxBadAuthExtra => Ok(InnerTransactionResultResult::TxBadAuthExtra),
            TransactionResultCode::TxInternalError => Ok(InnerTransactionResultResult::TxInternalError),
            TransactionResultCode::TxNotSupported => Ok(InnerTransactionResultResult::TxNotSupported),
            TransactionResultCode::TxBadSponsorship => Ok(InnerTransactionResultResult::TxBadSponsorship),
            TransactionResultCode::TxBadMinSeqAgeOrGap => Ok(InnerTransactionResultResult::TxBadMinSeqAgeOrGap),
            TransactionResultCode::TxMalformed => Ok(InnerTransactionResultResult::TxMalformed),
            TransactionResultCode::TxSorobanInvalid => Ok(InnerTransactionResultResult::TxSorobanInvalid),
            code => Ok(InnerTransactionResultResult::Default(code)),
        }
    }
}

/// Autogenerated definition for type InnerTransactionResultExt
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum InnerTransactionResultExt {
    V0,
    Default(i32),
}

impl XdrCodec for InnerTransactionResultExt {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            InnerTransactionResultExt::V0 => (0 as i32).to_xdr_buffered(write_stream),
            InnerTransactionResultExt::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(InnerTransactionResultExt::V0),
            code => Ok(InnerTransactionResultExt::Default(code)),
        }
    }
}

/// Autogenerated definition for type TransactionResultResult
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum TransactionResultResult {
    TxFeeBumpInnerSuccess(InnerTransactionResultPair),
    TxFeeBumpInnerFailed(InnerTransactionResultPair),
    TxSuccess(UnlimitedVarArray<OperationResult>),
    TxFailed(UnlimitedVarArray<OperationResult>),
    TxTooEarly,
    TxTooLate,
    TxMissingOperation,
    TxBadSeq,
    TxBadAuth,
    TxInsufficientBalance,
    TxNoAccount,
    TxInsufficientFee,
    TxBadAuthExtra,
    TxInternalError,
    TxNotSupported,
    TxBadSponsorship,
    TxBadMinSeqAgeOrGap,
    TxMalformed,
    TxSorobanInvalid,
}

impl XdrCodec for TransactionResultResult {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            TransactionResultResult::TxFeeBumpInnerSuccess(value) => {
                TransactionResultCode::TxFeeBumpInnerSuccess.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            TransactionResultResult::TxFeeBumpInnerFailed(value) => {
                TransactionResultCode::TxFeeBumpInnerFailed.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            TransactionResultResult::TxSuccess(value) => {
                TransactionResultCode::TxSuccess.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            TransactionResultResult::TxFailed(value) => {
                TransactionResultCode::TxFailed.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            TransactionResultResult::TxTooEarly => TransactionResultCode::TxTooEarly.to_xdr_buffered(write_stream),
            TransactionResultResult::TxTooLate => TransactionResultCode::TxTooLate.to_xdr_buffered(write_stream),
            TransactionResultResult::TxMissingOperation =>
                TransactionResultCode::TxMissingOperation.to_xdr_buffered(write_stream),
            TransactionResultResult::TxBadSeq => TransactionResultCode::TxBadSeq.to_xdr_buffered(write_stream),
            TransactionResultResult::TxBadAuth => TransactionResultCode::TxBadAuth.to_xdr_buffered(write_stream),
            TransactionResultResult::TxInsufficientBalance =>
                TransactionResultCode::TxInsufficientBalance.to_xdr_buffered(write_stream),
            TransactionResultResult::TxNoAccount => TransactionResultCode::TxNoAccount.to_xdr_buffered(write_stream),
            TransactionResultResult::TxInsufficientFee =>
                TransactionResultCode::TxInsufficientFee.to_xdr_buffered(write_stream),
            TransactionResultResult::TxBadAuthExtra =>
                TransactionResultCode::TxBadAuthExtra.to_xdr_buffered(write_stream),
            TransactionResultResult::TxInternalError =>
                TransactionResultCode::TxInternalError.to_xdr_buffered(write_stream),
            TransactionResultResult::TxNotSupported =>
                TransactionResultCode::TxNotSupported.to_xdr_buffered(write_stream),
            TransactionResultResult::TxBadSponsorship =>
                TransactionResultCode::TxBadSponsorship.to_xdr_buffered(write_stream),
            TransactionResultResult::TxBadMinSeqAgeOrGap =>
                TransactionResultCode::TxBadMinSeqAgeOrGap.to_xdr_buffered(write_stream),
            TransactionResultResult::TxMalformed => TransactionResultCode::TxMalformed.to_xdr_buffered(write_stream),
            TransactionResultResult::TxSorobanInvalid =>
                TransactionResultCode::TxSorobanInvalid.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match TransactionResultCode::from_xdr_buffered(read_stream)? {
            TransactionResultCode::TxFeeBumpInnerSuccess => Ok(TransactionResultResult::TxFeeBumpInnerSuccess(
                InnerTransactionResultPair::from_xdr_buffered(read_stream)?,
            )),
            TransactionResultCode::TxFeeBumpInnerFailed => Ok(TransactionResultResult::TxFeeBumpInnerFailed(
                InnerTransactionResultPair::from_xdr_buffered(read_stream)?,
            )),
            TransactionResultCode::TxSuccess =>
                Ok(TransactionResultResult::TxSuccess(UnlimitedVarArray::<OperationResult>::from_xdr_buffered(
                    read_stream,
                )?)),
            TransactionResultCode::TxFailed =>
                Ok(TransactionResultResult::TxFailed(UnlimitedVarArray::<OperationResult>::from_xdr_buffered(
                    read_stream,
                )?)),
            TransactionResultCode::TxTooEarly => Ok(TransactionResultResult::TxTooEarly),
            TransactionResultCode::TxTooLate => Ok(TransactionResultResult::TxTooLate),
            TransactionResultCode::TxMissingOperation => Ok(TransactionResultResult::TxMissingOperation),
            TransactionResultCode::TxBadSeq => Ok(TransactionResultResult::TxBadSeq),
            TransactionResultCode::TxBadAuth => Ok(TransactionResultResult::TxBadAuth),
            TransactionResultCode::TxInsufficientBalance => Ok(TransactionResultResult::TxInsufficientBalance),
            TransactionResultCode::TxNoAccount => Ok(TransactionResultResult::TxNoAccount),
            TransactionResultCode::TxInsufficientFee => Ok(TransactionResultResult::TxInsufficientFee),
            TransactionResultCode::TxBadAuthExtra => Ok(TransactionResultResult::TxBadAuthExtra),
            TransactionResultCode::TxInternalError => Ok(TransactionResultResult::TxInternalError),
            TransactionResultCode::TxNotSupported => Ok(TransactionResultResult::TxNotSupported),
            TransactionResultCode::TxBadSponsorship => Ok(TransactionResultResult::TxBadSponsorship),
            TransactionResultCode::TxBadMinSeqAgeOrGap => Ok(TransactionResultResult::TxBadMinSeqAgeOrGap),
            TransactionResultCode::TxMalformed => Ok(TransactionResultResult::TxMalformed),
            TransactionResultCode::TxSorobanInvalid => Ok(TransactionResultResult::TxSorobanInvalid),
        }
    }
}

/// Autogenerated definition for type TransactionResultExt
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum TransactionResultExt {
    V0,
    Default(i32),
}

impl XdrCodec for TransactionResultExt {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            TransactionResultExt::V0 => (0 as i32).to_xdr_buffered(write_stream),
            TransactionResultExt::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(TransactionResultExt::V0),
            code => Ok(TransactionResultExt::Default(code)),
        }
    }
}

/// Autogenerated definition for type ExtensionPoint
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum ExtensionPoint {
    V0,
    Default(i32),
}

impl XdrCodec for ExtensionPoint {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            ExtensionPoint::V0 => (0 as i32).to_xdr_buffered(write_stream),
            ExtensionPoint::Default(code) => code.to_xdr_buffered(write_stream),
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match i32::from_xdr_buffered(read_stream)? {
            0 => Ok(ExtensionPoint::V0),
            code => Ok(ExtensionPoint::Default(code)),
        }
    }
}

/// Autogenerated definition for type PublicKey
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum PublicKey {
    PublicKeyTypeEd25519(Uint256),
}

impl XdrCodec for PublicKey {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            PublicKey::PublicKeyTypeEd25519(value) => {
                PublicKeyType::PublicKeyTypeEd25519.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match PublicKeyType::from_xdr_buffered(read_stream)? {
            PublicKeyType::PublicKeyTypeEd25519 =>
                Ok(PublicKey::PublicKeyTypeEd25519(Uint256::from_xdr_buffered(read_stream)?)),
        }
    }
}

/// Autogenerated definition for type SignerKey
#[allow(dead_code)]
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum SignerKey {
    SignerKeyTypeEd25519(Uint256),
    SignerKeyTypePreAuthTx(Uint256),
    SignerKeyTypeHashX(Uint256),
    SignerKeyTypeEd25519SignedPayload(SignerKeyEd25519SignedPayload),
}

impl XdrCodec for SignerKey {
    fn to_xdr_buffered(&self, write_stream: &mut WriteStream) {
        match self {
            SignerKey::SignerKeyTypeEd25519(value) => {
                SignerKeyType::SignerKeyTypeEd25519.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            SignerKey::SignerKeyTypePreAuthTx(value) => {
                SignerKeyType::SignerKeyTypePreAuthTx.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            SignerKey::SignerKeyTypeHashX(value) => {
                SignerKeyType::SignerKeyTypeHashX.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
            SignerKey::SignerKeyTypeEd25519SignedPayload(value) => {
                SignerKeyType::SignerKeyTypeEd25519SignedPayload.to_xdr_buffered(write_stream);
                value.to_xdr_buffered(write_stream)
            },
        }
    }

    fn from_xdr_buffered<T: AsRef<[u8]>>(read_stream: &mut ReadStream<T>) -> Result<Self, DecodeError> {
        match SignerKeyType::from_xdr_buffered(read_stream)? {
            SignerKeyType::SignerKeyTypeEd25519 =>
                Ok(SignerKey::SignerKeyTypeEd25519(Uint256::from_xdr_buffered(read_stream)?)),
            SignerKeyType::SignerKeyTypePreAuthTx =>
                Ok(SignerKey::SignerKeyTypePreAuthTx(Uint256::from_xdr_buffered(read_stream)?)),
            SignerKeyType::SignerKeyTypeHashX =>
                Ok(SignerKey::SignerKeyTypeHashX(Uint256::from_xdr_buffered(read_stream)?)),
            SignerKeyType::SignerKeyTypeEd25519SignedPayload => Ok(SignerKey::SignerKeyTypeEd25519SignedPayload(
                SignerKeyEd25519SignedPayload::from_xdr_buffered(read_stream)?,
            )),
        }
    }
}
